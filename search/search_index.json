{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"home"},{"location":"_algorithm/","text":"","title":"Preface"},{"location":"_algorithm/_advt/1/","text":"1. \u539f\u7406 \ud83e\uddd0 \u8bbe\u8ba1\u4e00\u4e2a\u52a8\u6001\u89c4\u5212\u7b97\u6cd5\u7684\u57fa\u672c\u6b65\u9aa4: \u523b\u753b\u4e00\u4e2a\u6700\u4f18\u89e3\u7684\u7ed3\u6784\u7279\u5f81\uff0c\u5e76\u9012\u5f52\u5b9a\u4e49\u6700\u4f18\u89e3\u7684\u503c \u81ea\u5e95\u5411\u4e0a\u8ba1\u7b97\u6700\u4f18\u89e3\u7684\u503c \u4f9d\u636e\u5df2\u8ba1\u7b97\u51fa\u7684\u4fe1\u606f\uff0c\u6784\u9020\u6700\u4f18\u89e3 \u76f8\u6bd4\u4e8e\u5206\u6cbb\uff0c\u52a8\u6001\u89c4\u5212\u9002\u7528\u4e8e\u5b50\u95ee\u9898\u4e4b\u95f4\u6709\u91cd\u53e0\u7684\u60c5\u51b5 2. \u4e3e\u4f8b \ud83e\uddd0 (1). LCS \ud83e\uddd0 \u4ee4 $X=\\langle x_1, ..., x_m\\rangle$ \u548c $Y=\\langle y_1, ...,y_n \\rangle$ \u4e3a\u4e24\u4e2a\u5e8f\u5217\uff0c$Z=\\langle z_1, ... ,z_k \\rangle$ \u662f $X$ \u548c $Y$ \u7684 LCS, \u90a3\u4e48: \u82e5 $x_m = y_n$\uff0c\u5219 $z_k = x_m = y_n$ \u4e14 $Z_{k-1}$ \u662f $X_{m-1}$ \u548c $Y_{n-1}$ \u7684 LCS \u82e5 $x_m \\ne y_n$ \u4e14 $z_k \\ne x_m$\uff0c \u5219 $Z$ \u662f $X_{m-1}$ \u548c $Y$ \u7684 LCS (\u540c\u7406 $z_k \\ne y_n$) \u7531\u6b64\u53ef\u5f97 $$ lcs(i,j)=\\begin{cases} 0 & \\mathrm{if}\\ i=0\\ \\mathrm{or}\\ j=0 \\\\ lcs(i-1, j-1) + 1 & \\mathrm{if}\\ i,j> 0\\ \\mathrm{and}\\ x_i = y_j \\\\ \\mathrm{max}\\lbrace lcs(i,j-1),\\ lcs(i-1, j)\\rbrace & \\mathrm{if}\\ i,j> 0\\ \\mathrm{and}\\ x_i \\ne y_j \\end{cases} $$","title":"1. dynamic programming"},{"location":"_algorithm/_advt/1/#1","text":"\u8bbe\u8ba1\u4e00\u4e2a\u52a8\u6001\u89c4\u5212\u7b97\u6cd5\u7684\u57fa\u672c\u6b65\u9aa4: \u523b\u753b\u4e00\u4e2a\u6700\u4f18\u89e3\u7684\u7ed3\u6784\u7279\u5f81\uff0c\u5e76\u9012\u5f52\u5b9a\u4e49\u6700\u4f18\u89e3\u7684\u503c \u81ea\u5e95\u5411\u4e0a\u8ba1\u7b97\u6700\u4f18\u89e3\u7684\u503c \u4f9d\u636e\u5df2\u8ba1\u7b97\u51fa\u7684\u4fe1\u606f\uff0c\u6784\u9020\u6700\u4f18\u89e3 \u76f8\u6bd4\u4e8e\u5206\u6cbb\uff0c\u52a8\u6001\u89c4\u5212\u9002\u7528\u4e8e\u5b50\u95ee\u9898\u4e4b\u95f4\u6709\u91cd\u53e0\u7684\u60c5\u51b5","title":"1. \u539f\u7406"},{"location":"_algorithm/_advt/1/#2","text":"","title":"2. \u4e3e\u4f8b"},{"location":"_algorithm/_advt/1/#1-lcs","text":"\u4ee4 $X=\\langle x_1, ..., x_m\\rangle$ \u548c $Y=\\langle y_1, ...,y_n \\rangle$ \u4e3a\u4e24\u4e2a\u5e8f\u5217\uff0c$Z=\\langle z_1, ... ,z_k \\rangle$ \u662f $X$ \u548c $Y$ \u7684 LCS, \u90a3\u4e48: \u82e5 $x_m = y_n$\uff0c\u5219 $z_k = x_m = y_n$ \u4e14 $Z_{k-1}$ \u662f $X_{m-1}$ \u548c $Y_{n-1}$ \u7684 LCS \u82e5 $x_m \\ne y_n$ \u4e14 $z_k \\ne x_m$\uff0c \u5219 $Z$ \u662f $X_{m-1}$ \u548c $Y$ \u7684 LCS (\u540c\u7406 $z_k \\ne y_n$) \u7531\u6b64\u53ef\u5f97 $$ lcs(i,j)=\\begin{cases} 0 & \\mathrm{if}\\ i=0\\ \\mathrm{or}\\ j=0 \\\\ lcs(i-1, j-1) + 1 & \\mathrm{if}\\ i,j> 0\\ \\mathrm{and}\\ x_i = y_j \\\\ \\mathrm{max}\\lbrace lcs(i,j-1),\\ lcs(i-1, j)\\rbrace & \\mathrm{if}\\ i,j> 0\\ \\mathrm{and}\\ x_i \\ne y_j \\end{cases} $$","title":"(1). LCS"},{"location":"_algorithm/_advt/2/","text":"1. \u539f\u7406 \ud83e\uddd0 \u8d2a\u5fc3\u7b97\u6cd5\u603b\u662f\u505a\u51fa\u5c40\u90e8\u6700\u4f18\u9009\u62e9\uff0c\u5bc4\u5e0c\u671b\u4e8e\u5bfc\u81f4\u5168\u5c40\u6700\u4f18\u3002\u8bbe\u8ba1\u6b65\u9aa4\u901a\u5e38\u4e3a: \u5c06\u95ee\u9898\u8f6c\u5316\u4e3a\u5982\u4e0b\u5f62\u5f0f\u7684\u6700\u4f18\u5b50\u7ed3\u6784: \u505a\u51fa\u8d2a\u5fc3\u9009\u62e9\uff0c\u5269\u4e0b\u4e00\u4e2a\u5b50\u95ee\u9898 \u8d2a\u5fc3\u9009\u62e9\u6027: \u8bc1\u660e\u8d2a\u5fc3\u9009\u62e9\u603b\u662f\u5b89\u5168\u7684 \u6700\u4f18\u5b50\u7ed3\u6784: \u8bc1\u660e\u8d2a\u5fc3\u9009\u62e9\u548c\u5b50\u95ee\u9898\u7684\u89e3\u53ef\u4ee5\u7ec4\u6210\u539f\u95ee\u9898\u7684\u6700\u4f18\u89e3 \u8d2a\u5fc3\u7b97\u6cd5\u548c\u52a8\u6001\u89c4\u5212\u7684\u533a\u522b: \u52a8\u89c4: \u81ea\u5e95\u5411\u4e0a\uff0c\u6bcf\u6b21\u9009\u62e9\u4f9d\u8d56\u4e8e\u5b50\u95ee\u9898\u7684\u89e3 \u8d2a\u5fc3: \u81ea\u9876\u5411\u4e0b\uff0c\u6bcf\u6b21\u9009\u62e9\u53ef\u80fd\u4f9d\u8d56\u4e8e\u4e4b\u524d\u7684\u9009\u62e9\uff0c\u4f46\u548c\u5b50\u95ee\u9898\u7684\u89e3\u65e0\u5173; \u8d2a\u5fc3\u7684\u6700\u4f18\u5b50\u7ed3\u6784\u66f4\u76f4\u63a5 2. \u4e3e\u4f8b: \u6d3b\u52a8\u9009\u62e9\u95ee\u9898 \ud83e\uddd0 \u5047\u8bbe\u6709\u4e00\u6d3b\u52a8\u96c6\u5408 $S=\\lbrace a_1, ...,a_n \\rbrace$\uff0c\u8fd9\u4e9b\u6d3b\u52a8\u4f7f\u7528\u540c\u4e00\u4e2a\u8d44\u6e90\uff0c\u800c\u516c\u7528\u7684\u8d44\u6e90\u5728\u540c\u4e00\u65f6\u523b\u53ea\u80fd\u7531\u4e00\u4e2a\u6d3b\u52a8\u4f7f\u7528\u3002\u6d3b\u52a8 $a_i$ \u53d1\u751f\u5728\u65f6\u95f4\u8f74 $[s_i, f_i)$ \u4e2d\uff0c\u5982\u679c\u4e24\u4e2a\u6d3b\u52a8\u65f6\u95f4\u8f74\u4e0d\u51b2\u7a81\uff0c\u5219\u79f0\u5b83\u4eec\u662f\u517c\u5bb9\u7684\u3002\u6d3b\u52a8\u9009\u62e9\u95ee\u9898\u8981\u6c42\u9009\u51fa\u4e00\u4e2a\u6700\u5927\u7684\u517c\u5bb9\u6d3b\u52a8\u96c6\u3002\u5047\u8bbe\u6d3b\u52a8\u5df2\u6309 $f_i$ \u6392\u5e8f\u3002 \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c$\\lbrace a_1,a_4,a_8,a_{11} \\rbrace$ \u548c $\\lbrace a_2,a_4,a_9,a_{11} \\rbrace$ \u90fd\u662f\u6700\u5927\u6d3b\u52a8\u96c6 (1). \u6700\u4f18\u5b50\u7ed3\u6784 \ud83e\uddd0 \u4ee4 $S_{ij}$ \u8868\u793a\u5728 $a_i$ \u7ed3\u675f\u540e\u5f00\u59cb \u4e14 \u5728 $a_j$ \u5f00\u59cb\u524d\u7ed3\u675f\u7684\u6d3b\u52a8\u96c6\u5408\uff0c$c(i,j)$ \u8868\u793a $S_{ij}$ \u7684\u6700\u5927\u6d3b\u52a8\u96c6\uff0c\u5219 $$ \\displaystyle c(i,j)= \\begin{cases} 0 & \\mathrm{if\\ } S_{ij} = \\emptyset \\\\ \\operatorname*{max}\\limits_{a_k \\in S_{ij}}\\lbrace c(i,k) + c(k,j) + 1 \\rbrace & \\mathrm{if\\ } S_{ij} \\ne \\emptyset \\end{cases} $$ (2). \u8d2a\u5fc3\u9009\u62e9 \ud83e\uddd0 \u76f4\u89c2\u4e0a\uff0c\u8d2a\u5fc3\u9009\u62e9\u662f\u7ed3\u675f\u65f6\u95f4\u5c3d\u53ef\u80fd\u65e9\u7684\u6d3b\u52a8\uff0c\u4f7f\u5f97\u5269\u4e0b\u7684\u8d44\u6e90\u5c3d\u53ef\u80fd\u4e3a\u5176\u4ed6\u6d3b\u52a8\u6240\u7528\u3002 $S_k = \\lbrace a_i \\in S:\\ s_i \\geq f_k \\rbrace$ \u8868\u793a $a_k$ \u7ed3\u675f\u540e\u5f00\u59cb\u7684\u4efb\u52a1\u96c6\u5408\uff0c\u9009\u62e9\u4e86 $a_k$ \u540e\uff0c$S_k$ \u5c31\u662f\u8981\u6c42\u89e3\u7684\u5b50\u95ee\u9898\u3002 \u8d2a\u5fc3\u9009\u62e9\u7684\u6b63\u786e\u6027: \u4ee4 $a_m$ \u662f $S_k$ \u4e2d\u6700\u65e9\u7ed3\u675f\u7684\u6d3b\u52a8\uff0c\u5219 $a_m$ \u5728 $S_k$ \u7684\u67d0\u4e2a\u6700\u5927\u517c\u5bb9\u6d3b\u52a8\u5b50\u96c6\u4e2d \u8bbe $A_k$ \u662f $S_k$ \u7684\u4e00\u4e2a\u6700\u5927\u517c\u5bb9\u6d3b\u52a8\u96c6\uff0c$a_j$ \u662f $A_k$ \u6700\u65e9\u7ed3\u675f\u7684\u6d3b\u52a8\uff0c\u82e5 $a_j \\ne a_k$\uff0c\u66ff\u6362\u540e\u5404\u6d3b\u52a8\u4f9d\u7136\u517c\u5bb9 3. \u54c8\u592b\u66fc\u7f16\u7801 \ud83e\uddd0 \u7ed9\u5b9a\u5b57\u6bcd\u8868 $C$, $\\forall c\\in C$ \u90fd\u6709\u4e00\u4e2a\u51fa\u73b0\u9891\u7387\uff0c\u6c42\u6700\u4f18\u53d8\u957f\u524d\u7f00\u7f16\u7801\u6811\uff0c\u4f7f $B(T)=\\sum c.freq \\cdot d_T(c)$ \u6700\u5c0f HUFFMAN ( C ) n = | C | , Q = C for i = 1 to n -1 allocate a new node z z . left = x = EXTRACT - MIN ( Q ) z . right = y = EXTRACT - MIN ( Q ) z . freq = x . freq + y . freq INSERT ( Q , z ) return EXTRACT - MIN ( Q ) // return root node of the tree \u5f15\u7406 1 \u8bc1\u660e\u4e86 Huffman \u7f16\u7801\u7684\u8d2a\u5fc3\u9009\u62e9\u6027 \u5f15\u74061: \u8bbe $x$ \u548c $y$ \u662f $C$ \u4e2d\u9891\u7387\u6700\u5c0f\u7684\u4e24\u4e2a\u5b57\u7b26\uff0c\u5b58\u5728 $C$ \u7684\u4e00\u4e2a\u6700\u4f18\u524d\u7f00\u7801\u6811\uff0c$x$ \u548c $y$ \u7684\u7801\u5b57\u957f\u5ea6\u76f8\u540c\u3001\u4e14\u53ea\u6709\u6700\u540e\u4e00\u4e2a\u4e8c\u8fdb\u5236\u4f4d\u4e0d\u540c\uff0c\u662f\u5176\u4e2d\u6700\u6df1\u7684\u5144\u5f1f\u7ed3\u70b9 \u8bbe $a$ \u548c $b$ \u662f $T$ \u4e2d\u6df1\u5ea6\u6700\u5927\u7684\u5144\u5f1f\u53f6\u7ed3\u70b9\uff0c\u5047\u8bbe $a.freq \\leq b.freq$ \u4e14 $x.freq \\leq y.freq$\uff0c\u7531\u4e8e $x,y$ \u9891\u7387\u6700\u5c0f\uff0c\u6709 $x.freq \\leq a.freq$ \u4e14 $y.freq \\leq b.freq$ $T$ \u4e2d\u4ea4\u6362 $x$ \u548c $a$ \u751f\u6210 $T'$\uff0c\u53ef\u5f97 $B(T) - B(T') \\geq 0$; $T'$ \u4e2d\u4ea4\u6362 $y$ \u548c $b$ \u751f\u6210 $T''$\uff0c\u540c\u7406\u53ef\u5f97 $B(T') - B(T'') \\geq 0$\uff0c\u56e0\u6b64 $B(T'')\\leq B(T)$ \u7531\u4e8e $B(T)$ \u6700\u4f18\uff0c\u6545 $B(T)=B(T'')$ \u5f15\u7406 2 \u8bc1\u660e\u4e86 Huffman \u7f16\u7801\u7684\u6700\u4f18\u5b50\u7ed3\u6784 \u5f15\u74062: \u8bbe $C'=C-\\lbrace x,y \\rbrace \\cup \\lbrace z \\rbrace$ \u4e14 $z.freq = x.freq + y.freq$\uff0c$T_1$ \u662f $C'$ \u7684\u4e00\u4e2a\u6700\u4f18\u7f16\u7801\u6811\uff0c\u5c06 $T_1$ \u7684 $z$ \u7ed3\u70b9\u66ff\u6362\u4e3a\u4ee5 $x,y$ \u4e3a\u5b69\u5b50\u7684\u5185\u90e8\u7ed3\u70b9\u540e\uff0c\u53ef\u5f97\u5230 $C$ \u7684\u6700\u4f18\u7f16\u7801\u6811 $T$ \u5047\u8bbe $T$ \u4e0d\u662f $C$ \u7684\u6700\u4f18\u524d\u7f00\u6811\uff0c\u5b58\u5728 $B(T_2) < B(T)$\uff0c\u5c06 $T_2$ \u7684 $x,y$ \u53ca\u5b83\u4eec\u7684\u7236\u7ed3\u70b9\u66ff\u6362\u4e3a $z$ \u5f97\u5230 $T_3$\uff0c\u53ef\u5f97 $$ B(T_3) = B(T_2) - x.freq - y.freq < B(T) - x.freq - y.freq = B(T_1) $$ \u8fd9\u4e0e $T_1$ \u662f $C'$ \u7684\u6700\u4f18\u6811\u77db\u76fe\uff0c\u56e0\u6b64 $T$ \u662f $C$ \u7684\u6700\u4f18\u6811","title":"2. greedy algorithm"},{"location":"_algorithm/_advt/2/#1","text":"\u8d2a\u5fc3\u7b97\u6cd5\u603b\u662f\u505a\u51fa\u5c40\u90e8\u6700\u4f18\u9009\u62e9\uff0c\u5bc4\u5e0c\u671b\u4e8e\u5bfc\u81f4\u5168\u5c40\u6700\u4f18\u3002\u8bbe\u8ba1\u6b65\u9aa4\u901a\u5e38\u4e3a: \u5c06\u95ee\u9898\u8f6c\u5316\u4e3a\u5982\u4e0b\u5f62\u5f0f\u7684\u6700\u4f18\u5b50\u7ed3\u6784: \u505a\u51fa\u8d2a\u5fc3\u9009\u62e9\uff0c\u5269\u4e0b\u4e00\u4e2a\u5b50\u95ee\u9898 \u8d2a\u5fc3\u9009\u62e9\u6027: \u8bc1\u660e\u8d2a\u5fc3\u9009\u62e9\u603b\u662f\u5b89\u5168\u7684 \u6700\u4f18\u5b50\u7ed3\u6784: \u8bc1\u660e\u8d2a\u5fc3\u9009\u62e9\u548c\u5b50\u95ee\u9898\u7684\u89e3\u53ef\u4ee5\u7ec4\u6210\u539f\u95ee\u9898\u7684\u6700\u4f18\u89e3 \u8d2a\u5fc3\u7b97\u6cd5\u548c\u52a8\u6001\u89c4\u5212\u7684\u533a\u522b: \u52a8\u89c4: \u81ea\u5e95\u5411\u4e0a\uff0c\u6bcf\u6b21\u9009\u62e9\u4f9d\u8d56\u4e8e\u5b50\u95ee\u9898\u7684\u89e3 \u8d2a\u5fc3: \u81ea\u9876\u5411\u4e0b\uff0c\u6bcf\u6b21\u9009\u62e9\u53ef\u80fd\u4f9d\u8d56\u4e8e\u4e4b\u524d\u7684\u9009\u62e9\uff0c\u4f46\u548c\u5b50\u95ee\u9898\u7684\u89e3\u65e0\u5173; \u8d2a\u5fc3\u7684\u6700\u4f18\u5b50\u7ed3\u6784\u66f4\u76f4\u63a5","title":"1. \u539f\u7406"},{"location":"_algorithm/_advt/2/#2","text":"\u5047\u8bbe\u6709\u4e00\u6d3b\u52a8\u96c6\u5408 $S=\\lbrace a_1, ...,a_n \\rbrace$\uff0c\u8fd9\u4e9b\u6d3b\u52a8\u4f7f\u7528\u540c\u4e00\u4e2a\u8d44\u6e90\uff0c\u800c\u516c\u7528\u7684\u8d44\u6e90\u5728\u540c\u4e00\u65f6\u523b\u53ea\u80fd\u7531\u4e00\u4e2a\u6d3b\u52a8\u4f7f\u7528\u3002\u6d3b\u52a8 $a_i$ \u53d1\u751f\u5728\u65f6\u95f4\u8f74 $[s_i, f_i)$ \u4e2d\uff0c\u5982\u679c\u4e24\u4e2a\u6d3b\u52a8\u65f6\u95f4\u8f74\u4e0d\u51b2\u7a81\uff0c\u5219\u79f0\u5b83\u4eec\u662f\u517c\u5bb9\u7684\u3002\u6d3b\u52a8\u9009\u62e9\u95ee\u9898\u8981\u6c42\u9009\u51fa\u4e00\u4e2a\u6700\u5927\u7684\u517c\u5bb9\u6d3b\u52a8\u96c6\u3002\u5047\u8bbe\u6d3b\u52a8\u5df2\u6309 $f_i$ \u6392\u5e8f\u3002 \u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c$\\lbrace a_1,a_4,a_8,a_{11} \\rbrace$ \u548c $\\lbrace a_2,a_4,a_9,a_{11} \\rbrace$ \u90fd\u662f\u6700\u5927\u6d3b\u52a8\u96c6","title":"2. \u4e3e\u4f8b: \u6d3b\u52a8\u9009\u62e9\u95ee\u9898"},{"location":"_algorithm/_advt/2/#1_1","text":"\u4ee4 $S_{ij}$ \u8868\u793a\u5728 $a_i$ \u7ed3\u675f\u540e\u5f00\u59cb \u4e14 \u5728 $a_j$ \u5f00\u59cb\u524d\u7ed3\u675f\u7684\u6d3b\u52a8\u96c6\u5408\uff0c$c(i,j)$ \u8868\u793a $S_{ij}$ \u7684\u6700\u5927\u6d3b\u52a8\u96c6\uff0c\u5219 $$ \\displaystyle c(i,j)= \\begin{cases} 0 & \\mathrm{if\\ } S_{ij} = \\emptyset \\\\ \\operatorname*{max}\\limits_{a_k \\in S_{ij}}\\lbrace c(i,k) + c(k,j) + 1 \\rbrace & \\mathrm{if\\ } S_{ij} \\ne \\emptyset \\end{cases} $$","title":"(1). \u6700\u4f18\u5b50\u7ed3\u6784"},{"location":"_algorithm/_advt/2/#2_1","text":"\u76f4\u89c2\u4e0a\uff0c\u8d2a\u5fc3\u9009\u62e9\u662f\u7ed3\u675f\u65f6\u95f4\u5c3d\u53ef\u80fd\u65e9\u7684\u6d3b\u52a8\uff0c\u4f7f\u5f97\u5269\u4e0b\u7684\u8d44\u6e90\u5c3d\u53ef\u80fd\u4e3a\u5176\u4ed6\u6d3b\u52a8\u6240\u7528\u3002 $S_k = \\lbrace a_i \\in S:\\ s_i \\geq f_k \\rbrace$ \u8868\u793a $a_k$ \u7ed3\u675f\u540e\u5f00\u59cb\u7684\u4efb\u52a1\u96c6\u5408\uff0c\u9009\u62e9\u4e86 $a_k$ \u540e\uff0c$S_k$ \u5c31\u662f\u8981\u6c42\u89e3\u7684\u5b50\u95ee\u9898\u3002 \u8d2a\u5fc3\u9009\u62e9\u7684\u6b63\u786e\u6027: \u4ee4 $a_m$ \u662f $S_k$ \u4e2d\u6700\u65e9\u7ed3\u675f\u7684\u6d3b\u52a8\uff0c\u5219 $a_m$ \u5728 $S_k$ \u7684\u67d0\u4e2a\u6700\u5927\u517c\u5bb9\u6d3b\u52a8\u5b50\u96c6\u4e2d \u8bbe $A_k$ \u662f $S_k$ \u7684\u4e00\u4e2a\u6700\u5927\u517c\u5bb9\u6d3b\u52a8\u96c6\uff0c$a_j$ \u662f $A_k$ \u6700\u65e9\u7ed3\u675f\u7684\u6d3b\u52a8\uff0c\u82e5 $a_j \\ne a_k$\uff0c\u66ff\u6362\u540e\u5404\u6d3b\u52a8\u4f9d\u7136\u517c\u5bb9","title":"(2). \u8d2a\u5fc3\u9009\u62e9"},{"location":"_algorithm/_advt/2/#3","text":"\u7ed9\u5b9a\u5b57\u6bcd\u8868 $C$, $\\forall c\\in C$ \u90fd\u6709\u4e00\u4e2a\u51fa\u73b0\u9891\u7387\uff0c\u6c42\u6700\u4f18\u53d8\u957f\u524d\u7f00\u7f16\u7801\u6811\uff0c\u4f7f $B(T)=\\sum c.freq \\cdot d_T(c)$ \u6700\u5c0f HUFFMAN ( C ) n = | C | , Q = C for i = 1 to n -1 allocate a new node z z . left = x = EXTRACT - MIN ( Q ) z . right = y = EXTRACT - MIN ( Q ) z . freq = x . freq + y . freq INSERT ( Q , z ) return EXTRACT - MIN ( Q ) // return root node of the tree \u5f15\u7406 1 \u8bc1\u660e\u4e86 Huffman \u7f16\u7801\u7684\u8d2a\u5fc3\u9009\u62e9\u6027 \u5f15\u74061: \u8bbe $x$ \u548c $y$ \u662f $C$ \u4e2d\u9891\u7387\u6700\u5c0f\u7684\u4e24\u4e2a\u5b57\u7b26\uff0c\u5b58\u5728 $C$ \u7684\u4e00\u4e2a\u6700\u4f18\u524d\u7f00\u7801\u6811\uff0c$x$ \u548c $y$ \u7684\u7801\u5b57\u957f\u5ea6\u76f8\u540c\u3001\u4e14\u53ea\u6709\u6700\u540e\u4e00\u4e2a\u4e8c\u8fdb\u5236\u4f4d\u4e0d\u540c\uff0c\u662f\u5176\u4e2d\u6700\u6df1\u7684\u5144\u5f1f\u7ed3\u70b9 \u8bbe $a$ \u548c $b$ \u662f $T$ \u4e2d\u6df1\u5ea6\u6700\u5927\u7684\u5144\u5f1f\u53f6\u7ed3\u70b9\uff0c\u5047\u8bbe $a.freq \\leq b.freq$ \u4e14 $x.freq \\leq y.freq$\uff0c\u7531\u4e8e $x,y$ \u9891\u7387\u6700\u5c0f\uff0c\u6709 $x.freq \\leq a.freq$ \u4e14 $y.freq \\leq b.freq$ $T$ \u4e2d\u4ea4\u6362 $x$ \u548c $a$ \u751f\u6210 $T'$\uff0c\u53ef\u5f97 $B(T) - B(T') \\geq 0$; $T'$ \u4e2d\u4ea4\u6362 $y$ \u548c $b$ \u751f\u6210 $T''$\uff0c\u540c\u7406\u53ef\u5f97 $B(T') - B(T'') \\geq 0$\uff0c\u56e0\u6b64 $B(T'')\\leq B(T)$ \u7531\u4e8e $B(T)$ \u6700\u4f18\uff0c\u6545 $B(T)=B(T'')$ \u5f15\u7406 2 \u8bc1\u660e\u4e86 Huffman \u7f16\u7801\u7684\u6700\u4f18\u5b50\u7ed3\u6784 \u5f15\u74062: \u8bbe $C'=C-\\lbrace x,y \\rbrace \\cup \\lbrace z \\rbrace$ \u4e14 $z.freq = x.freq + y.freq$\uff0c$T_1$ \u662f $C'$ \u7684\u4e00\u4e2a\u6700\u4f18\u7f16\u7801\u6811\uff0c\u5c06 $T_1$ \u7684 $z$ \u7ed3\u70b9\u66ff\u6362\u4e3a\u4ee5 $x,y$ \u4e3a\u5b69\u5b50\u7684\u5185\u90e8\u7ed3\u70b9\u540e\uff0c\u53ef\u5f97\u5230 $C$ \u7684\u6700\u4f18\u7f16\u7801\u6811 $T$ \u5047\u8bbe $T$ \u4e0d\u662f $C$ \u7684\u6700\u4f18\u524d\u7f00\u6811\uff0c\u5b58\u5728 $B(T_2) < B(T)$\uff0c\u5c06 $T_2$ \u7684 $x,y$ \u53ca\u5b83\u4eec\u7684\u7236\u7ed3\u70b9\u66ff\u6362\u4e3a $z$ \u5f97\u5230 $T_3$\uff0c\u53ef\u5f97 $$ B(T_3) = B(T_2) - x.freq - y.freq < B(T) - x.freq - y.freq = B(T_1) $$ \u8fd9\u4e0e $T_1$ \u662f $C'$ \u7684\u6700\u4f18\u6811\u77db\u76fe\uff0c\u56e0\u6b64 $T$ \u662f $C$ \u7684\u6700\u4f18\u6811","title":"3. \u54c8\u592b\u66fc\u7f16\u7801"},{"location":"_algorithm/_binary_search/binary_search/","text":"1. \u4e8c\u5206\u67e5\u627e\u7684\u79cd\u7c7b \ud83e\uddd0 \u2003 \u4e0a\u754c\u7684\u60c5\u51b5\u5747\u53ef\u4ee5\u901a\u8fc7\u4e0b\u754c\u7684\u7d22\u5f15\u51cf\u4e00\u5f97\u5230\u3002 2. \u4e0b\u754c\u4e8c\u5206\u67e5\u627e \ud83e\uddd0 def lower_bound ( array , left , right , value ): while left < right : mid = left + ( right - left ) // 2 if array [ mid ] < value : left = mid + 1 # [mid + 1, right) else right = mid # [left, mid) return left \u6ea2\u51fa\u95ee\u9898 \ud83e\uddd0 \u76f4\u63a5 mid = (left + right) // 2 \u53ef\u80fd\u5bfc\u81f4\u6ea2\u51fa \u601d\u8def \ud83e\uddd0 \u5b8c\u6574\u7406\u89e3 lower_bound \u9700\u8981\u8003\u8651\u4ee5\u4e0b\u65b9\u9762 \u76ee\u6807\u72b6\u6001: \u2002 left=right \uff0c\u4e14 [start,left) \u5185\u5143\u7d20 < value \uff0c [right,end) \u5185\u5143\u7d20 > value \uff0c\u8fd9\u6837 array[left] \u5373\u4e3a\u6240\u6c42 \u533a\u95f4\u8df3\u8f6c\u4fdd\u6301\u76ee\u6807\u72b6\u6001: \u2002 \u8df3\u8f6c\u9700\u8981\u4fdd\u6301\u76ee\u6807\u72b6\u6001\u7684\u4e0d\u53d8\u5f0f\uff0c\u8003\u8651 mid \u6307\u9488\u5728 array=[1,2,3,3,3,4,5] \u4e0a\u6ed1\u52a8 ( value=3 ) \u5f53 array[mid] < value \u65f6\uff0c\u53ef\u4ee5\u5411\u53f3\u8df3\u8f6c\uff0c\u4fdd\u6301 array[start...first) < value else\uff0c\u53ef\u4ee5\u5411\u5de6\u8df3\u8f6c\uff0c\u4fdd\u6301 array[last...end) >= value \u533a\u95f4\u5212\u5206\u8fb9\u754c: \u2002 \u8003\u8651\u533a\u95f4\u957f\u4e3a 2 \u6216 3\uff0c\u9700\u8981\u4fdd\u8bc1\u5212\u5206\u7684\u4e24\u4e2a\u533a\u95f4\u786e\u5b9e\u66f4\u5c0f\u4e86\uff0c\u56e0\u6b64\u4e3a [first,mid) + mid + [mid+1,last) \u5143\u7d20\u4e0d\u5b58\u5728\u7684\u60c5\u51b5: \u2002 \u5982\u679c array \u7684\u5143\u7d20\u90fd\u5c0f\u4e8e value \uff0c\u4f1a\u4e0d\u65ad\u5411\u53f3\u8df3\u8f6c\uff0c\u76f4\u5230 first=last=end upper_bound \u9700\u8981\u72b6\u6001 left <= value & right > value \uff0c\u53ea\u9700\u6539\u6761\u4ef6\u4e3a array[mid] <= value 3. \u4e8c\u5206\u603b\u7ed3 \ud83e\uddd0 \u57fa\u672c\u7684\u4e8c\u5206\u8003\u8651\u4e3a\u4e0a\u8ff0\u56db\u6b65: \u76ee\u6807\u72b6\u6001\u3001\u8df3\u8f6c\u53ef\u4ee5\u4fdd\u6301\u76ee\u6807\u72b6\u6001\u3001\u533a\u95f4\u8df3\u8f6c\u7684\u8fb9\u754c\u3001\u5143\u7d20\u4e0d\u5b58\u5728\u7684\u60c5\u51b5 upper_bound \u4f7f\u7528\u5de6\u95ed\u53f3\u5f00\u7684\u597d\u5904\u662f\u65b9\u4fbf\u8868\u793a\u7a7a\u533a\u95f4\uff0c\u5f88\u591a\u65f6\u5019\u4e24\u95ed\u4e5f\u4f1a\u66f4\u65b9\u4fbf upper_bound \u662f\u4fdd\u6301\u533a\u95f4\u4e24\u7aef\u7684\u6027\u8d28\uff0c\u666e\u901a\u7684\u601d\u8def\u662f\u4fdd\u6301\u533a\u95f4\u7684\u6027\u8d28","title":"Binary Search"},{"location":"_algorithm/_binary_search/binary_search/#1","text":"\u4e0a\u754c\u7684\u60c5\u51b5\u5747\u53ef\u4ee5\u901a\u8fc7\u4e0b\u754c\u7684\u7d22\u5f15\u51cf\u4e00\u5f97\u5230\u3002","title":"1. \u4e8c\u5206\u67e5\u627e\u7684\u79cd\u7c7b"},{"location":"_algorithm/_binary_search/binary_search/#2","text":"def lower_bound ( array , left , right , value ): while left < right : mid = left + ( right - left ) // 2 if array [ mid ] < value : left = mid + 1 # [mid + 1, right) else right = mid # [left, mid) return left","title":"2. \u4e0b\u754c\u4e8c\u5206\u67e5\u627e"},{"location":"_algorithm/_binary_search/binary_search/#_1","text":"\u76f4\u63a5 mid = (left + right) // 2 \u53ef\u80fd\u5bfc\u81f4\u6ea2\u51fa","title":"\u6ea2\u51fa\u95ee\u9898"},{"location":"_algorithm/_binary_search/binary_search/#_2","text":"\u5b8c\u6574\u7406\u89e3 lower_bound \u9700\u8981\u8003\u8651\u4ee5\u4e0b\u65b9\u9762 \u76ee\u6807\u72b6\u6001: \u2002 left=right \uff0c\u4e14 [start,left) \u5185\u5143\u7d20 < value \uff0c [right,end) \u5185\u5143\u7d20 > value \uff0c\u8fd9\u6837 array[left] \u5373\u4e3a\u6240\u6c42 \u533a\u95f4\u8df3\u8f6c\u4fdd\u6301\u76ee\u6807\u72b6\u6001: \u2002 \u8df3\u8f6c\u9700\u8981\u4fdd\u6301\u76ee\u6807\u72b6\u6001\u7684\u4e0d\u53d8\u5f0f\uff0c\u8003\u8651 mid \u6307\u9488\u5728 array=[1,2,3,3,3,4,5] \u4e0a\u6ed1\u52a8 ( value=3 ) \u5f53 array[mid] < value \u65f6\uff0c\u53ef\u4ee5\u5411\u53f3\u8df3\u8f6c\uff0c\u4fdd\u6301 array[start...first) < value else\uff0c\u53ef\u4ee5\u5411\u5de6\u8df3\u8f6c\uff0c\u4fdd\u6301 array[last...end) >= value \u533a\u95f4\u5212\u5206\u8fb9\u754c: \u2002 \u8003\u8651\u533a\u95f4\u957f\u4e3a 2 \u6216 3\uff0c\u9700\u8981\u4fdd\u8bc1\u5212\u5206\u7684\u4e24\u4e2a\u533a\u95f4\u786e\u5b9e\u66f4\u5c0f\u4e86\uff0c\u56e0\u6b64\u4e3a [first,mid) + mid + [mid+1,last) \u5143\u7d20\u4e0d\u5b58\u5728\u7684\u60c5\u51b5: \u2002 \u5982\u679c array \u7684\u5143\u7d20\u90fd\u5c0f\u4e8e value \uff0c\u4f1a\u4e0d\u65ad\u5411\u53f3\u8df3\u8f6c\uff0c\u76f4\u5230 first=last=end upper_bound \u9700\u8981\u72b6\u6001 left <= value & right > value \uff0c\u53ea\u9700\u6539\u6761\u4ef6\u4e3a array[mid] <= value","title":"\u601d\u8def"},{"location":"_algorithm/_binary_search/binary_search/#3","text":"\u57fa\u672c\u7684\u4e8c\u5206\u8003\u8651\u4e3a\u4e0a\u8ff0\u56db\u6b65: \u76ee\u6807\u72b6\u6001\u3001\u8df3\u8f6c\u53ef\u4ee5\u4fdd\u6301\u76ee\u6807\u72b6\u6001\u3001\u533a\u95f4\u8df3\u8f6c\u7684\u8fb9\u754c\u3001\u5143\u7d20\u4e0d\u5b58\u5728\u7684\u60c5\u51b5 upper_bound \u4f7f\u7528\u5de6\u95ed\u53f3\u5f00\u7684\u597d\u5904\u662f\u65b9\u4fbf\u8868\u793a\u7a7a\u533a\u95f4\uff0c\u5f88\u591a\u65f6\u5019\u4e24\u95ed\u4e5f\u4f1a\u66f4\u65b9\u4fbf upper_bound \u662f\u4fdd\u6301\u533a\u95f4\u4e24\u7aef\u7684\u6027\u8d28\uff0c\u666e\u901a\u7684\u601d\u8def\u662f\u4fdd\u6301\u533a\u95f4\u7684\u6027\u8d28","title":"3. \u4e8c\u5206\u603b\u7ed3"},{"location":"_algorithm/_ds/heap/","text":"1. \u5806 \ud83e\uddd0 \u4e8c\u53c9\u5806\u662f\u7528\u6570\u7ec4\u8868\u793a\u7684\u5b8c\u5168\u4e8c\u53c9\u6811 1 \u3002\u4ee5\u6700\u5c0f\u5806\u4e3a\u4f8b\uff0c\u6ee1\u8db3\u5b9a\u4e49: \u9664\u6839\u4ee5\u5916\u6240\u6709\u7ed3\u70b9 $\\sf i$ \u6ee1\u8db3 $\\sf i.value \\leq parent(i).value$ \u5b8c\u5168\u4e8c\u53c9\u6811\u8bbf\u95ee\u7236\u5b50\u7ed3\u70b9: (i from 1): left(i) = 2*i , right(i) = 2*i+1 , father(i) = i/2 , fp = N / 2 (i from 0): left(i) = 2*i+1 , right(i) = 2*i+2 , father(i) = (i-1)/2 , fp = N / 2 - 1 (1). \u5411\u4e0b\u4fdd\u6301\u5806\u7684\u6027\u8d28 \ud83e\uddd0 \u5047\u8bbe\u5de6\u53f3\u5b50\u6811 left(i) \u548c right(i) \u5747\u6ee1\u8db3\u6700\u5c0f\u5806\u7684\u6027\u8d28\uff0c\u800c i \u548c\u5b83\u4eec\u7684\u5173\u7cfb\u4e0d\u786e\u5b9a\uff0c\u901a\u8fc7 MinHeapify(i, heap) \u5411\u4e0b\u7ef4\u62a4\u6700\u5c0f\u5806\u7684\u6027\u8d28: \u7a7a\u51fa i \u7684\u4f4d\u7f6e\uff0c\u5982\u679c left(i) \u548c right(i) \u7684\u6700\u5c0f\u503c\u6bd4 i.value \u5c0f\uff0c\u5219\u5411\u4e0b\u9012\u5f52 public void MinHeapify ( int i ) { if ( i > this . size ) return ; int father = i , child = 2 * i + 1 ; int value = this . nodes [ father ] ; while ( child < this . size ) { if ( child + 1 < this . size && this . nodes [ child + 1 ] < this . nodes [ child ] ) child ++ ; if ( value < this . nodes [ child ] ) break ; this . nodes [ father ] = this . nodes [ child ] ; father = child ; child = 2 * child + 1 ; } this . nodes [ father ] = value ; } (2). \u5411\u4e0a\u4fdd\u6301\u5806\u7684\u6027\u8d28 \ud83e\uddd0 \u5982\u679c\u51cf\u5c0f i.value \uff0c\u5411\u4e0b\u7684\u6027\u8d28\u53ef\u4ee5\u4fdd\u6301\uff0c\u4f46\u5411\u4e0a\u4e0d\u4e00\u5b9a\uff0c\u5219\u5411\u4e0a\u9012\u5f52\u4fdd\u6301\u6700\u5c0f\u5806\u6027\u8d28 public void DecreaseKey ( int i , int key ) { if ( key >= this . nodes [ i ] ) return ; while ( i != 0 && this . nodes [ ( i - 1 ) / 2 ] > key ) { this . nodes [ i ] = this . nodes [ ( i - 1 ) / 2 ] ; i = ( i - 1 ) / 2 ; } this . nodes [ i ] = key ; } (3). \u5efa\u5806 \ud83e\uddd0 \u4ece\u7b2c\u4e00\u4e2a\u975e\u53f6\u8282\u70b9 fp(i) \u5f00\u59cb\uff0c\u5411\u4e0b\u8c03\u6574\u5806 public void BuildMinHeap () { for ( int i = this . size / 2 - 1 ; i >= 0 ; -- i ) MinHeapify ( i ); } \u9ad8\u4e3a $k$ \u7684\u5c42\u6709 $2^{h-k}$ \u4e2a\u7ed3\u70b9\uff0c\u9ad8\u4e3a $h$ \u7684\u6ee1\u4e8c\u53c9\u6811\u6709 $2^{h-1}$ \u4e2a\u7ed3\u70b9\uff0c\u6709 $$ \\sum_{k=0}^h k \\cdot 2^{h-k} = 2^h \\sum_{k=0}^h \\frac{k}{2^k} = 2^h (2- \\frac{h + 2}{2^h}) \\leq 2n $$ \u6545\u5efa\u5806\u590d\u6742\u5ea6\u4e3a $O(n)$ 2. \u4f18\u5148\u961f\u5217 \ud83e\uddd0 \u4f18\u5148\u961f\u5217\u5e95\u5c42\u8c03\u7528\u5806\u7684\u5b9e\u73b0\uff0c\u9700\u8981\u63d0\u4f9b\u7684\u63a5\u53e3: ExtractMin(Q) : \u5f39\u51fa\u5806\u9876\u5143\u7d20\uff0c\u628a\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u7f6e\u4e8e\u5806\u9876\uff0c\u7136\u540e\u5411\u4e0b\u8c03\u6574\u5806 Insert(key, Q) : \u7f6e\u4e8e\u5806\u5e95\uff0c\u7136\u540e\u5411\u4e0a\u8c03\u6574 \u5982\u679c\u9700\u8981\u540c\u65f6\u5f39\u51fa\u548c\u63d2\u5165\u4e24\u79cd\u64cd\u4f5c\uff0c\u53ef\u4ee5\u5f39\u51fa\u540e\u63d2\u5728\u5806\u9876\uff0c\u53ef\u4ee5\u8282\u7ea6\u4e00\u4e2a $\\log$ \u7684\u65f6\u95f4 \u5b8c\u5168\u4e8c\u53c9\u6811\uff1a\u9664\u6700\u540e\u4e00\u5c42\u5916\u7684\u5176\u4f59\u5c42\u90fd\u662f\u6ee1\u7684\uff0c\u5e76\u4e14\u6700\u540e\u4e00\u5c42\u8981\u4e48\u662f\u6ee1\u7684\uff0c\u8981\u4e48\u5728\u53f3\u8fb9\u7f3a\u5c11\u8fde\u7eed\u82e5\u5e72\u8282\u70b9 \u21a9","title":"heap"},{"location":"_algorithm/_ds/heap/#1","text":"\u4e8c\u53c9\u5806\u662f\u7528\u6570\u7ec4\u8868\u793a\u7684\u5b8c\u5168\u4e8c\u53c9\u6811 1 \u3002\u4ee5\u6700\u5c0f\u5806\u4e3a\u4f8b\uff0c\u6ee1\u8db3\u5b9a\u4e49: \u9664\u6839\u4ee5\u5916\u6240\u6709\u7ed3\u70b9 $\\sf i$ \u6ee1\u8db3 $\\sf i.value \\leq parent(i).value$ \u5b8c\u5168\u4e8c\u53c9\u6811\u8bbf\u95ee\u7236\u5b50\u7ed3\u70b9: (i from 1): left(i) = 2*i , right(i) = 2*i+1 , father(i) = i/2 , fp = N / 2 (i from 0): left(i) = 2*i+1 , right(i) = 2*i+2 , father(i) = (i-1)/2 , fp = N / 2 - 1","title":"1. \u5806"},{"location":"_algorithm/_ds/heap/#1_1","text":"\u5047\u8bbe\u5de6\u53f3\u5b50\u6811 left(i) \u548c right(i) \u5747\u6ee1\u8db3\u6700\u5c0f\u5806\u7684\u6027\u8d28\uff0c\u800c i \u548c\u5b83\u4eec\u7684\u5173\u7cfb\u4e0d\u786e\u5b9a\uff0c\u901a\u8fc7 MinHeapify(i, heap) \u5411\u4e0b\u7ef4\u62a4\u6700\u5c0f\u5806\u7684\u6027\u8d28: \u7a7a\u51fa i \u7684\u4f4d\u7f6e\uff0c\u5982\u679c left(i) \u548c right(i) \u7684\u6700\u5c0f\u503c\u6bd4 i.value \u5c0f\uff0c\u5219\u5411\u4e0b\u9012\u5f52 public void MinHeapify ( int i ) { if ( i > this . size ) return ; int father = i , child = 2 * i + 1 ; int value = this . nodes [ father ] ; while ( child < this . size ) { if ( child + 1 < this . size && this . nodes [ child + 1 ] < this . nodes [ child ] ) child ++ ; if ( value < this . nodes [ child ] ) break ; this . nodes [ father ] = this . nodes [ child ] ; father = child ; child = 2 * child + 1 ; } this . nodes [ father ] = value ; }","title":"(1). \u5411\u4e0b\u4fdd\u6301\u5806\u7684\u6027\u8d28"},{"location":"_algorithm/_ds/heap/#2","text":"\u5982\u679c\u51cf\u5c0f i.value \uff0c\u5411\u4e0b\u7684\u6027\u8d28\u53ef\u4ee5\u4fdd\u6301\uff0c\u4f46\u5411\u4e0a\u4e0d\u4e00\u5b9a\uff0c\u5219\u5411\u4e0a\u9012\u5f52\u4fdd\u6301\u6700\u5c0f\u5806\u6027\u8d28 public void DecreaseKey ( int i , int key ) { if ( key >= this . nodes [ i ] ) return ; while ( i != 0 && this . nodes [ ( i - 1 ) / 2 ] > key ) { this . nodes [ i ] = this . nodes [ ( i - 1 ) / 2 ] ; i = ( i - 1 ) / 2 ; } this . nodes [ i ] = key ; }","title":"(2). \u5411\u4e0a\u4fdd\u6301\u5806\u7684\u6027\u8d28"},{"location":"_algorithm/_ds/heap/#3","text":"\u4ece\u7b2c\u4e00\u4e2a\u975e\u53f6\u8282\u70b9 fp(i) \u5f00\u59cb\uff0c\u5411\u4e0b\u8c03\u6574\u5806 public void BuildMinHeap () { for ( int i = this . size / 2 - 1 ; i >= 0 ; -- i ) MinHeapify ( i ); } \u9ad8\u4e3a $k$ \u7684\u5c42\u6709 $2^{h-k}$ \u4e2a\u7ed3\u70b9\uff0c\u9ad8\u4e3a $h$ \u7684\u6ee1\u4e8c\u53c9\u6811\u6709 $2^{h-1}$ \u4e2a\u7ed3\u70b9\uff0c\u6709 $$ \\sum_{k=0}^h k \\cdot 2^{h-k} = 2^h \\sum_{k=0}^h \\frac{k}{2^k} = 2^h (2- \\frac{h + 2}{2^h}) \\leq 2n $$ \u6545\u5efa\u5806\u590d\u6742\u5ea6\u4e3a $O(n)$","title":"(3). \u5efa\u5806"},{"location":"_algorithm/_ds/heap/#2_1","text":"\u4f18\u5148\u961f\u5217\u5e95\u5c42\u8c03\u7528\u5806\u7684\u5b9e\u73b0\uff0c\u9700\u8981\u63d0\u4f9b\u7684\u63a5\u53e3: ExtractMin(Q) : \u5f39\u51fa\u5806\u9876\u5143\u7d20\uff0c\u628a\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u7f6e\u4e8e\u5806\u9876\uff0c\u7136\u540e\u5411\u4e0b\u8c03\u6574\u5806 Insert(key, Q) : \u7f6e\u4e8e\u5806\u5e95\uff0c\u7136\u540e\u5411\u4e0a\u8c03\u6574 \u5982\u679c\u9700\u8981\u540c\u65f6\u5f39\u51fa\u548c\u63d2\u5165\u4e24\u79cd\u64cd\u4f5c\uff0c\u53ef\u4ee5\u5f39\u51fa\u540e\u63d2\u5728\u5806\u9876\uff0c\u53ef\u4ee5\u8282\u7ea6\u4e00\u4e2a $\\log$ \u7684\u65f6\u95f4 \u5b8c\u5168\u4e8c\u53c9\u6811\uff1a\u9664\u6700\u540e\u4e00\u5c42\u5916\u7684\u5176\u4f59\u5c42\u90fd\u662f\u6ee1\u7684\uff0c\u5e76\u4e14\u6700\u540e\u4e00\u5c42\u8981\u4e48\u662f\u6ee1\u7684\uff0c\u8981\u4e48\u5728\u53f3\u8fb9\u7f3a\u5c11\u8fde\u7eed\u82e5\u5e72\u8282\u70b9 \u21a9","title":"2. \u4f18\u5148\u961f\u5217"},{"location":"_algorithm/_ds/ufset/","text":"1. \u5e76\u67e5\u96c6\u6982\u8ff0 \ud83e\uddd0 \u5e76\u67e5\u96c6\u6709\u4e09\u79cd\u64cd\u4f5c\uff1a Make-Set(x) : \u5efa\u7acb\u552f\u4e00\u6210\u5458\u4e3a $\\sf x$ \u7684\u65b0\u96c6\u5408 Union(x, y) : \u5408\u5e76\u96c6\u5408 $\\sf S_x$ \u548c $\\sf S_y$ Find(x) : \u8fd4\u56de\u96c6\u5408 $\\sf S_x$ \u7684\u4ee3\u8868 \u8861\u91cf\u5e76\u67e5\u96c6\u7684\u590d\u6742\u6027\u9700\u8981\u8003\u8651\u4e09\u79cd\u64cd\u4f5c\u7684\u603b\u4f53\u6392\u5217 $I$\uff0c\u56e0\u6b64\uff0c\u5b9a\u4e49 Make-Set \u603b\u6570\u4e3a $m$\uff0c\u4e14\u8ba4\u4e3a $I$ \u7684\u524d $m$ \u4e2a\u64cd\u4f5c\u4e00\u5b9a\u662f Make-Set . $I$ \u5305\u542b\u7684\u64cd\u4f5c\u603b\u6570\u4e3a $n$ 2. \u94fe\u8868\u5b9e\u73b0 \ud83e\uddd0 Make-Set \u548c Find \u590d\u6742\u5ea6\u5747\u4e3a $O(1)$\uff0c\u4f46 Union \u9700\u8981\u66f4\u65b0\u6307\u9488\uff0c\u6700\u574f\u60c5\u51b5\u4e0b $m$ \u4e2a Union \u9700\u8981 $\\Theta(m^2)$. \u800c\u5982\u679c\u4f7f\u7528\u542f\u53d1\u5f0f\u7b56\u7565\uff0c\u8ba9\u77ed\u94fe\u8868\u5411\u957f\u94fe\u8868\u5408\u5e76\uff0c\u8003\u8651\u5230 \u6267\u884c\u5b8c $m$ \u4e2a Make-Set \u540e\uff0c\u5bf9\u4efb\u610f\u4e00\u4e2a\u94fe\u8868 x, x \u7b2c 1 \u6b21\u88ab\u5408\u5e76\u65f6\u4f1a\u4ea7\u751f\u957f\u81f3\u5c11\u4e3a 2 \u7684\u94fe\u8868\uff0c\u4ee5\u6b64\u7c7b\u63a8\uff0cx \u7b2c $\\lceil \\lg k \\rceil$ \u6b21\u5408\u5e76\u65f6\u4f1a\u4ea7\u751f\u957f\u81f3\u5c11\u4e3a $k$ \u7684\u94fe\u8868 \u56e0\u6b64\u6bcf\u4e2a\u94fe\u8868\u81f3\u591a\u88ab\u5408\u5e76 $\\lg n$ \u6b21\uff0c\u56e0\u6b64\u542f\u53d1\u5f0f\u7b56\u7565\u7684\u590d\u6742\u5ea6\u4e3a $O(n + m\\lg m)$ 3. \u6709\u6839\u6811\u5b9e\u73b0 \ud83e\uddd0 \u6709\u6839\u6811\u7684\u666e\u901a\u7ed3\u70b9\u6307\u5411\u7236\u7ed3\u70b9\uff0c\u6839\u7ed3\u70b9\u6307\u5411\u81ea\u8eab\uff0c\u53ef\u4ee5\u7528\u6709\u6839\u6811\u68ee\u6797\u8868\u793a\u5e76\u67e5\u96c6\uff0c\u4e09\u79cd\u64cd\u4f5c\u5206\u522b\u5bf9\u5e94\uff1a Make-Set(x) : \u8ba9 x \u6307\u5411\u81ea\u8eab Find(x) : \u6cbf x \u4e0a\u6eaf\u5230\u6839 Union(x) : \u8ba9\u4e00\u68f5\u6811\u7684\u6839\u6307\u5411\u53e6\u4e00\u68f5\u7684\u6839 void makeset () { for ( int i = 0 ; i < MAXN ; ++ i ) nodes [ i ] = i ; } void find ( int x ) { return x == nodes [ x ] ? x : find ( nodes [ x ]); } void union ( int x , int y ) { nodes [ find ( x )] = find ( y ); } \u4ec5\u5982\u6b64\u6709\u6839\u6811\u53ef\u80fd\u4f1a\u5f62\u6210\u76f4\u94fe\uff0c\u5176\u6700\u574f\u590d\u6742\u6027\u4e5f\u4e3a $O(n^2)$\uff0c\u4f46\u901a\u8fc7\u4e0d\u540c\u7684\u542f\u53d1\u7b56\u7565\uff0c\u53ef\u4f7f $n$ \u4e2a\u64cd\u4f5c\u7684\u590d\u6742\u5ea6\u8fd1\u4e4e\u7ebf\u6027: $O(n\\cdot \\alpha(m))$\uff0c$\\alpha$ \u662f\u4e00\u4e2a\u589e\u957f\u5f88\u6162\u7684\u51fd\u6570\uff0c\u901a\u5e38\u6709 $\\alpha(m)\\leq 4$ \u6309\u79e9\u5408\u5e76 \ud83e\uddd0 \u6bcf\u68f5\u6811\u7684\u6839\u7ef4\u62a4\u4e00\u4e2a\u79e9\uff0c\u8868\u793a\u9ad8\u5ea6\u7684\u4e00\u4e2a\u4e0a\u754c Make-Set \u540e\uff0c\u6bcf\u4e2a\u7ed3\u70b9 (\u6811) \u7684\u79e9\u4e3a 0 \u76f8\u540c\u79e9\u7684\u6811\u5408\u5e76\uff0c\u4efb\u9009\u4e00\u4e2a\u4f5c\u4e3a\u65b0\u6839\uff0c\u4e14\u65b0\u6839\u7684\u79e9\u52a0\u4e00 \u4e0d\u540c\u79e9\u7684\u6811\u5408\u5e76\uff0c\u5927\u79e9\u6839\u6210\u4e3a\u65b0\u6839\uff0c\u4e14\u79e9\u4e0d\u53d8 void Union ( int x , int y ) { int rx = find ( x ), ry = find ( y ); if ( rank [ rx ] > rand [ ry ]) nodes [ ry ] = nodes [ rx ]; else nodes [ rx ] = nodes [ ry ]; if ( rank [ rx ] == rank [ ry ] && rx != ry ) ++ rank [ ry ]; } \u8def\u5f84\u538b\u7f29 \ud83e\uddd0 \u5728 Find-Set \u7684\u8fc7\u7a0b\u4e2d\uff0c(\u56de\u6eaf\u65f6) \u4f7f\u67e5\u627e\u8def\u5f84\u4e0a\u6bcf\u4e2a\u7ed3\u70b9\u6307\u5411\u6839\uff0c\u4e14\u4e0d\u6539\u53d8\u4efb\u4f55\u7ed3\u70b9\u7684\u79e9 int find ( int x ) { return x == nodes [ x ] ? x : ( nodes [ x ] = find ( nodes [ x ])); }","title":"union-find set"},{"location":"_algorithm/_ds/ufset/#1","text":"\u5e76\u67e5\u96c6\u6709\u4e09\u79cd\u64cd\u4f5c\uff1a Make-Set(x) : \u5efa\u7acb\u552f\u4e00\u6210\u5458\u4e3a $\\sf x$ \u7684\u65b0\u96c6\u5408 Union(x, y) : \u5408\u5e76\u96c6\u5408 $\\sf S_x$ \u548c $\\sf S_y$ Find(x) : \u8fd4\u56de\u96c6\u5408 $\\sf S_x$ \u7684\u4ee3\u8868 \u8861\u91cf\u5e76\u67e5\u96c6\u7684\u590d\u6742\u6027\u9700\u8981\u8003\u8651\u4e09\u79cd\u64cd\u4f5c\u7684\u603b\u4f53\u6392\u5217 $I$\uff0c\u56e0\u6b64\uff0c\u5b9a\u4e49 Make-Set \u603b\u6570\u4e3a $m$\uff0c\u4e14\u8ba4\u4e3a $I$ \u7684\u524d $m$ \u4e2a\u64cd\u4f5c\u4e00\u5b9a\u662f Make-Set . $I$ \u5305\u542b\u7684\u64cd\u4f5c\u603b\u6570\u4e3a $n$","title":"1. \u5e76\u67e5\u96c6\u6982\u8ff0"},{"location":"_algorithm/_ds/ufset/#2","text":"Make-Set \u548c Find \u590d\u6742\u5ea6\u5747\u4e3a $O(1)$\uff0c\u4f46 Union \u9700\u8981\u66f4\u65b0\u6307\u9488\uff0c\u6700\u574f\u60c5\u51b5\u4e0b $m$ \u4e2a Union \u9700\u8981 $\\Theta(m^2)$. \u800c\u5982\u679c\u4f7f\u7528\u542f\u53d1\u5f0f\u7b56\u7565\uff0c\u8ba9\u77ed\u94fe\u8868\u5411\u957f\u94fe\u8868\u5408\u5e76\uff0c\u8003\u8651\u5230 \u6267\u884c\u5b8c $m$ \u4e2a Make-Set \u540e\uff0c\u5bf9\u4efb\u610f\u4e00\u4e2a\u94fe\u8868 x, x \u7b2c 1 \u6b21\u88ab\u5408\u5e76\u65f6\u4f1a\u4ea7\u751f\u957f\u81f3\u5c11\u4e3a 2 \u7684\u94fe\u8868\uff0c\u4ee5\u6b64\u7c7b\u63a8\uff0cx \u7b2c $\\lceil \\lg k \\rceil$ \u6b21\u5408\u5e76\u65f6\u4f1a\u4ea7\u751f\u957f\u81f3\u5c11\u4e3a $k$ \u7684\u94fe\u8868 \u56e0\u6b64\u6bcf\u4e2a\u94fe\u8868\u81f3\u591a\u88ab\u5408\u5e76 $\\lg n$ \u6b21\uff0c\u56e0\u6b64\u542f\u53d1\u5f0f\u7b56\u7565\u7684\u590d\u6742\u5ea6\u4e3a $O(n + m\\lg m)$","title":"2. \u94fe\u8868\u5b9e\u73b0"},{"location":"_algorithm/_ds/ufset/#3","text":"\u6709\u6839\u6811\u7684\u666e\u901a\u7ed3\u70b9\u6307\u5411\u7236\u7ed3\u70b9\uff0c\u6839\u7ed3\u70b9\u6307\u5411\u81ea\u8eab\uff0c\u53ef\u4ee5\u7528\u6709\u6839\u6811\u68ee\u6797\u8868\u793a\u5e76\u67e5\u96c6\uff0c\u4e09\u79cd\u64cd\u4f5c\u5206\u522b\u5bf9\u5e94\uff1a Make-Set(x) : \u8ba9 x \u6307\u5411\u81ea\u8eab Find(x) : \u6cbf x \u4e0a\u6eaf\u5230\u6839 Union(x) : \u8ba9\u4e00\u68f5\u6811\u7684\u6839\u6307\u5411\u53e6\u4e00\u68f5\u7684\u6839 void makeset () { for ( int i = 0 ; i < MAXN ; ++ i ) nodes [ i ] = i ; } void find ( int x ) { return x == nodes [ x ] ? x : find ( nodes [ x ]); } void union ( int x , int y ) { nodes [ find ( x )] = find ( y ); } \u4ec5\u5982\u6b64\u6709\u6839\u6811\u53ef\u80fd\u4f1a\u5f62\u6210\u76f4\u94fe\uff0c\u5176\u6700\u574f\u590d\u6742\u6027\u4e5f\u4e3a $O(n^2)$\uff0c\u4f46\u901a\u8fc7\u4e0d\u540c\u7684\u542f\u53d1\u7b56\u7565\uff0c\u53ef\u4f7f $n$ \u4e2a\u64cd\u4f5c\u7684\u590d\u6742\u5ea6\u8fd1\u4e4e\u7ebf\u6027: $O(n\\cdot \\alpha(m))$\uff0c$\\alpha$ \u662f\u4e00\u4e2a\u589e\u957f\u5f88\u6162\u7684\u51fd\u6570\uff0c\u901a\u5e38\u6709 $\\alpha(m)\\leq 4$","title":"3. \u6709\u6839\u6811\u5b9e\u73b0"},{"location":"_algorithm/_ds/ufset/#_1","text":"\u6bcf\u68f5\u6811\u7684\u6839\u7ef4\u62a4\u4e00\u4e2a\u79e9\uff0c\u8868\u793a\u9ad8\u5ea6\u7684\u4e00\u4e2a\u4e0a\u754c Make-Set \u540e\uff0c\u6bcf\u4e2a\u7ed3\u70b9 (\u6811) \u7684\u79e9\u4e3a 0 \u76f8\u540c\u79e9\u7684\u6811\u5408\u5e76\uff0c\u4efb\u9009\u4e00\u4e2a\u4f5c\u4e3a\u65b0\u6839\uff0c\u4e14\u65b0\u6839\u7684\u79e9\u52a0\u4e00 \u4e0d\u540c\u79e9\u7684\u6811\u5408\u5e76\uff0c\u5927\u79e9\u6839\u6210\u4e3a\u65b0\u6839\uff0c\u4e14\u79e9\u4e0d\u53d8 void Union ( int x , int y ) { int rx = find ( x ), ry = find ( y ); if ( rank [ rx ] > rand [ ry ]) nodes [ ry ] = nodes [ rx ]; else nodes [ rx ] = nodes [ ry ]; if ( rank [ rx ] == rank [ ry ] && rx != ry ) ++ rank [ ry ]; }","title":"\u6309\u79e9\u5408\u5e76"},{"location":"_algorithm/_ds/ufset/#_2","text":"\u5728 Find-Set \u7684\u8fc7\u7a0b\u4e2d\uff0c(\u56de\u6eaf\u65f6) \u4f7f\u67e5\u627e\u8def\u5f84\u4e0a\u6bcf\u4e2a\u7ed3\u70b9\u6307\u5411\u6839\uff0c\u4e14\u4e0d\u6539\u53d8\u4efb\u4f55\u7ed3\u70b9\u7684\u79e9 int find ( int x ) { return x == nodes [ x ] ? x : ( nodes [ x ] = find ( nodes [ x ])); }","title":"\u8def\u5f84\u538b\u7f29"},{"location":"_algorithm/_graph/basis/","text":"1. \u5e7f\u5ea6\u4f18\u5148\u641c\u7d22 \ud83e\uddd0 \u767d\u8272\u8868\u793a\u672a\u63a2\u7d22\uff0c\u7070\u8272\u8868\u793a\u521a\u88ab\u63a2\u7d22\u5e76\u5165\u961f\uff0c\u9ed1\u8272\u8868\u793a\u88ab\u63a2\u7d22\u4e14\u5b50\u7ed3\u70b9\u4e5f\u5168\u88ab\u63a2\u7d22 for each u \u2208 G . V - { s } u . color = WHITE u . d = \u221e u . \u03c0 = Null s . color = GRAY , s . d = 0 , s . \u03c0 = Null EnQueue ( s , Q ) while Q is not empty : u = DeQueue ( Q ) for each v \u2208 G . Adj [ u ] : if v . color == WHITE : v . color = GRAY v . d = u . d + 1 v . \u03c0 = u EnQueue ( v , Q ) u . color = BLACK \u65f6\u95f4\u590d\u6742\u6027\u4e3a $O(V+E)$\uff0c\u5982\u679c\u6bcf\u6761\u8fb9\u5747\u4e3a 1 \u4e2a\u5355\u4f4d\uff0cBFS \u8fd8\u53ef\u4ee5\u8ba1\u7b97\u6700\u77ed\u8def\uff0c\u76f4\u89c2\u6765\u770b\uff1a \u5148\u5165\u961f\u7684\u7ed3\u70b9\u7684 d \u503c\u5927\u4e8e\u540e\u5165\u961f\u7684 \u5165\u961f\u65f6\u7684 d \u4e00\u5b9a\u662f\u6700\u77ed\u8def\u957f 2. \u6df1\u5ea6\u4f18\u5148\u641c\u7d22 \ud83e\uddd0 \u767d\u8272\u8868\u793a\u672a\u63a2\u7d22\uff0c\u7070\u8272\u8868\u793a\u521a\u88ab\u63a2\u7d22\uff0c\u9ed1\u8272\u8868\u793a\u88ab\u63a2\u7d22\u4e14\u540e\u4ee3\u7ed3\u70b9\u4e5f\u5168\u88ab\u63a2\u7d22 DFS - Visit ( G , u ) : time = time + 1 u . d = time u . color = GRAY for each v \u2208 G . Adj [ u ] : if v . color = WHITE : v . \u03c0 = u DFS - Visit ( G , v ) else if v . color = GRAY : // find a backward edge else : ... u . color = BLACK time = time + 1 u . f = time DFS ( G ) : for each u \u2208 G . V : u . color = WHITE u . \u03c0 = Null time = 0 for each u \u2208 G . V : if u . color = WHITE : DFS - Visit ( G , u ) DFS \u4e3b\u8981\u6709\u4ee5\u4e0b\u6027\u8d28\uff1a \u62ec\u53f7\u5316\u7ed3\u6784\uff1a\u53ef\u4ee5\u901a\u8fc7\u9012\u5f52\u8bb0\u5f55\u7ed3\u70b9\u521a\u88ab\u53d1\u73b0\u4ee5\u53ca\u7ed3\u675f\u7684\u65f6\u95f4 \u8fb9\u7684\u5206\u7c7b\uff1a\u53ef\u4ee5\u901a\u8fc7\u7b2c\u4e00\u6b21\u641c\u7d22\u5230 $(u,v)$ \u65f6 $v$ \u7684\u989c\u8272\u4e3a $G=(V,E)$ \u7684\u8fb9\u5206\u6d3e\u4e00\u4e2a\u7c7b\u522b \u6811\u8fb9\uff1a\u6df1\u5ea6\u4f18\u5148\u68ee\u6797\u4e2d\u7684\u8fb9 (\u767d\u8272) \u540e\u5411\u8fb9\uff1a\u5c06 $u$ \u8fde\u5230\u7956\u5148\u7ed3\u70b9 $v$ \u7684\u8fb9 ($v$ \u662f\u7070\u8272\uff0c\u8bf4\u660e\u8fd8\u5728 $v$ \u7684\u65f6\u95f4\u7247\u6bb5\u5185\uff0ci.e. \u5728\u6df1\u5ea6\u4f18\u5148\u6811\u4e2d $u$ \u662f $v$ \u540e\u4ee3\u4e14\u6307\u5411 $v$) \u524d\u5411\u8fb9: \u5c06 $u$ \u8fde\u5230\u540e\u4ee3\u7ed3\u70b9 $v$ \u7684\u8fb9 (\u9ed1\u8272) \u6a2a\u5411\u8fb9\uff1a\u5176\u4ed6\u8fb9 (\u9ed1\u8272) 3. \u62d3\u6251\u6392\u5e8f \ud83e\uddd0 (1). Kahn \u7b97\u6cd5 \ud83e\uddd0 \u5265\u76ae\u7b97\u6cd5\uff0c\u53cd\u5411 BFS L = Empty list that will contain the sorted elements S = Set of all nodes with no incoming edges while S in non - empty : n = remove a node n from S Insert ( n , L ) for each m in G . adj [ n ] : remove ( n , m ) from G if m has no other incoming edges : Insert ( m , S ) if G has edges : return ERROR else : return L \u5176\u6838\u5fc3\u5728\u4e8e\u7ef4\u62a4\u4e00\u4e2a 0 \u5165\u5ea6\u70b9\u96c6\uff0c\u590d\u6742\u5ea6 $O(V+E)$ (2). DFS \ud83e\uddd0 \u7531 DFS \u6811\u7684\u62ec\u53f7\u5316\u7ed3\u6784 (\u6807\u6ce8\u65f6\u95f4\u7684\u6df1\u5ea6\u4f18\u5148\u68ee\u6797)\uff0c\u76f4\u89c2\u4e0a\u53ef\u4ee5\u9006\u5e8f\u6784\u5efa\u62d3\u6251\u5e8f\u96c6 \u9996\u5148\uff0c\u5047\u8bbe\u6df1\u5ea6\u4f18\u5148\u6811\u4e2d\u4e00\u4e2a\u7ed3\u70b9\u5373\u5c06\u53d8\u9ed1\uff0c\u5176\u540e\u4ee3\u5df2\u7ecf\u9006\u5e8f\u52a0\u5165\u62d3\u6251\u96c6\uff0c\u4ece\u5b83\u5f15\u51fa\u7684\u8fb9\u5df2\u7ecf\u5206\u597d\u7c7b\uff0c\u4e0d\u8ba8\u8bba\u5df2\u5728\u6811\u4e2d\u7684\u6811\u8fb9 \u7531\u5b83\u5f15\u51fa\u7684\u8fb9\u4e0d\u53ef\u80fd\u662f\u540e\u5411\u8fb9: \u6709\u5411\u56fe $G=(V,E)$ \u65e0\u73af $\\Longleftrightarrow$ $G$ \u6ca1\u6709 DFS \u7684\u540e\u5411\u8fb9 $\\Leftarrow$ \u7684\u7b80\u5355\u7406\u89e3\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u6709\u5411\u6811\u53ea\u8981\u4e0d\u63d2\u5165\u540e\u5411\u8fb9\u5c31\u8fd8\u65e0\u73af \u90a3\u4e48\u53ea\u53ef\u80fd\u662f\u6307\u5411\u9ed1\u7ed3\u70b9\u7684 \u524d\u5411\u8fb9\u6216\u6a2a\u5411\u8fb9\uff0c\u7531\u4e8e\u9ed1\u7ed3\u70b9\u5df2\u52a0\u5165\u62d3\u6251\u96c6\uff0c\u8be5\u7ed3\u70b9\u4e5f\u53ef\u4ee5 Graph G [ MAXN ]; int color [ MAXN ]; Vertices topo ; bool dfs ( int u ) { color [ u ] = -1 ; for ( int v : G [ u ]) { if ( color [ v ] < 0 ) return false ; else if ( color [ v ] == 0 ) if ( ! dfs ( v )) return false ; } color [ u ] = 1 ; topo . push ( u ); return true ; } bool toposort () { for ( int u = 0 ; u < n ; u ++ ) if ( color [ u ] == 0 ) if ( ! dfs ( u )) return false ; reverse ( topo ); return true ; }","title":"1. basis"},{"location":"_algorithm/_graph/basis/#1","text":"\u767d\u8272\u8868\u793a\u672a\u63a2\u7d22\uff0c\u7070\u8272\u8868\u793a\u521a\u88ab\u63a2\u7d22\u5e76\u5165\u961f\uff0c\u9ed1\u8272\u8868\u793a\u88ab\u63a2\u7d22\u4e14\u5b50\u7ed3\u70b9\u4e5f\u5168\u88ab\u63a2\u7d22 for each u \u2208 G . V - { s } u . color = WHITE u . d = \u221e u . \u03c0 = Null s . color = GRAY , s . d = 0 , s . \u03c0 = Null EnQueue ( s , Q ) while Q is not empty : u = DeQueue ( Q ) for each v \u2208 G . Adj [ u ] : if v . color == WHITE : v . color = GRAY v . d = u . d + 1 v . \u03c0 = u EnQueue ( v , Q ) u . color = BLACK \u65f6\u95f4\u590d\u6742\u6027\u4e3a $O(V+E)$\uff0c\u5982\u679c\u6bcf\u6761\u8fb9\u5747\u4e3a 1 \u4e2a\u5355\u4f4d\uff0cBFS \u8fd8\u53ef\u4ee5\u8ba1\u7b97\u6700\u77ed\u8def\uff0c\u76f4\u89c2\u6765\u770b\uff1a \u5148\u5165\u961f\u7684\u7ed3\u70b9\u7684 d \u503c\u5927\u4e8e\u540e\u5165\u961f\u7684 \u5165\u961f\u65f6\u7684 d \u4e00\u5b9a\u662f\u6700\u77ed\u8def\u957f","title":"1. \u5e7f\u5ea6\u4f18\u5148\u641c\u7d22"},{"location":"_algorithm/_graph/basis/#2","text":"\u767d\u8272\u8868\u793a\u672a\u63a2\u7d22\uff0c\u7070\u8272\u8868\u793a\u521a\u88ab\u63a2\u7d22\uff0c\u9ed1\u8272\u8868\u793a\u88ab\u63a2\u7d22\u4e14\u540e\u4ee3\u7ed3\u70b9\u4e5f\u5168\u88ab\u63a2\u7d22 DFS - Visit ( G , u ) : time = time + 1 u . d = time u . color = GRAY for each v \u2208 G . Adj [ u ] : if v . color = WHITE : v . \u03c0 = u DFS - Visit ( G , v ) else if v . color = GRAY : // find a backward edge else : ... u . color = BLACK time = time + 1 u . f = time DFS ( G ) : for each u \u2208 G . V : u . color = WHITE u . \u03c0 = Null time = 0 for each u \u2208 G . V : if u . color = WHITE : DFS - Visit ( G , u ) DFS \u4e3b\u8981\u6709\u4ee5\u4e0b\u6027\u8d28\uff1a \u62ec\u53f7\u5316\u7ed3\u6784\uff1a\u53ef\u4ee5\u901a\u8fc7\u9012\u5f52\u8bb0\u5f55\u7ed3\u70b9\u521a\u88ab\u53d1\u73b0\u4ee5\u53ca\u7ed3\u675f\u7684\u65f6\u95f4 \u8fb9\u7684\u5206\u7c7b\uff1a\u53ef\u4ee5\u901a\u8fc7\u7b2c\u4e00\u6b21\u641c\u7d22\u5230 $(u,v)$ \u65f6 $v$ \u7684\u989c\u8272\u4e3a $G=(V,E)$ \u7684\u8fb9\u5206\u6d3e\u4e00\u4e2a\u7c7b\u522b \u6811\u8fb9\uff1a\u6df1\u5ea6\u4f18\u5148\u68ee\u6797\u4e2d\u7684\u8fb9 (\u767d\u8272) \u540e\u5411\u8fb9\uff1a\u5c06 $u$ \u8fde\u5230\u7956\u5148\u7ed3\u70b9 $v$ \u7684\u8fb9 ($v$ \u662f\u7070\u8272\uff0c\u8bf4\u660e\u8fd8\u5728 $v$ \u7684\u65f6\u95f4\u7247\u6bb5\u5185\uff0ci.e. \u5728\u6df1\u5ea6\u4f18\u5148\u6811\u4e2d $u$ \u662f $v$ \u540e\u4ee3\u4e14\u6307\u5411 $v$) \u524d\u5411\u8fb9: \u5c06 $u$ \u8fde\u5230\u540e\u4ee3\u7ed3\u70b9 $v$ \u7684\u8fb9 (\u9ed1\u8272) \u6a2a\u5411\u8fb9\uff1a\u5176\u4ed6\u8fb9 (\u9ed1\u8272)","title":"2. \u6df1\u5ea6\u4f18\u5148\u641c\u7d22"},{"location":"_algorithm/_graph/basis/#3","text":"","title":"3. \u62d3\u6251\u6392\u5e8f"},{"location":"_algorithm/_graph/basis/#1-kahn","text":"\u5265\u76ae\u7b97\u6cd5\uff0c\u53cd\u5411 BFS L = Empty list that will contain the sorted elements S = Set of all nodes with no incoming edges while S in non - empty : n = remove a node n from S Insert ( n , L ) for each m in G . adj [ n ] : remove ( n , m ) from G if m has no other incoming edges : Insert ( m , S ) if G has edges : return ERROR else : return L \u5176\u6838\u5fc3\u5728\u4e8e\u7ef4\u62a4\u4e00\u4e2a 0 \u5165\u5ea6\u70b9\u96c6\uff0c\u590d\u6742\u5ea6 $O(V+E)$","title":"(1). Kahn \u7b97\u6cd5"},{"location":"_algorithm/_graph/basis/#2-dfs","text":"\u7531 DFS \u6811\u7684\u62ec\u53f7\u5316\u7ed3\u6784 (\u6807\u6ce8\u65f6\u95f4\u7684\u6df1\u5ea6\u4f18\u5148\u68ee\u6797)\uff0c\u76f4\u89c2\u4e0a\u53ef\u4ee5\u9006\u5e8f\u6784\u5efa\u62d3\u6251\u5e8f\u96c6 \u9996\u5148\uff0c\u5047\u8bbe\u6df1\u5ea6\u4f18\u5148\u6811\u4e2d\u4e00\u4e2a\u7ed3\u70b9\u5373\u5c06\u53d8\u9ed1\uff0c\u5176\u540e\u4ee3\u5df2\u7ecf\u9006\u5e8f\u52a0\u5165\u62d3\u6251\u96c6\uff0c\u4ece\u5b83\u5f15\u51fa\u7684\u8fb9\u5df2\u7ecf\u5206\u597d\u7c7b\uff0c\u4e0d\u8ba8\u8bba\u5df2\u5728\u6811\u4e2d\u7684\u6811\u8fb9 \u7531\u5b83\u5f15\u51fa\u7684\u8fb9\u4e0d\u53ef\u80fd\u662f\u540e\u5411\u8fb9: \u6709\u5411\u56fe $G=(V,E)$ \u65e0\u73af $\\Longleftrightarrow$ $G$ \u6ca1\u6709 DFS \u7684\u540e\u5411\u8fb9 $\\Leftarrow$ \u7684\u7b80\u5355\u7406\u89e3\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u6709\u5411\u6811\u53ea\u8981\u4e0d\u63d2\u5165\u540e\u5411\u8fb9\u5c31\u8fd8\u65e0\u73af \u90a3\u4e48\u53ea\u53ef\u80fd\u662f\u6307\u5411\u9ed1\u7ed3\u70b9\u7684 \u524d\u5411\u8fb9\u6216\u6a2a\u5411\u8fb9\uff0c\u7531\u4e8e\u9ed1\u7ed3\u70b9\u5df2\u52a0\u5165\u62d3\u6251\u96c6\uff0c\u8be5\u7ed3\u70b9\u4e5f\u53ef\u4ee5 Graph G [ MAXN ]; int color [ MAXN ]; Vertices topo ; bool dfs ( int u ) { color [ u ] = -1 ; for ( int v : G [ u ]) { if ( color [ v ] < 0 ) return false ; else if ( color [ v ] == 0 ) if ( ! dfs ( v )) return false ; } color [ u ] = 1 ; topo . push ( u ); return true ; } bool toposort () { for ( int u = 0 ; u < n ; u ++ ) if ( color [ u ] == 0 ) if ( ! dfs ( u )) return false ; reverse ( topo ); return true ; }","title":"(2). DFS"},{"location":"_algorithm/_graph/mst/","text":"1. \u6700\u5c0f\u751f\u6210\u6811\u7684\u5f62\u6210 \ud83e\uddd0 (1). \u7b97\u6cd5\u6846\u67b6 \ud83e\uddd0 Kruskal \u548c Prim \u7b97\u6cd5\u90fd\u4f7f\u7528\u8d2a\u5fc3\u7684\u6846\u67b6\u6c42\u89e3 MST\uff0c\u533a\u522b\u5728\u4e8e\u8d2a\u5fc3\u7684\u7b56\u7565\u4e0d\u540c 1 2 3 4 5 6 Generic - MST ( G , w ) : A = \u2205 while A does not form a spanning tree : find an edge that is safe for A A = A \u222a {( u , v )} return A (2). \u4e00\u4e9b\u5b9a\u4e49 \ud83e\uddd0 \u5b89\u5168\u8fb9: \u2002 \u4e0d\u7834\u574f Generic-MST \u7684\u8d2a\u5fc3\u5faa\u73af\u4e0d\u53d8\u5f0f\u6027\u8d28\u7684\u8fb9 (u,v) \u5207\u5272 (cut): \u2002 $(S,\\ V-S)$ \u662f $V$ \u7684\u4e00\u4e2a\u5212\u5206 \u6a2a\u8de8 (cross): \u2002 \u5982\u679c $(u,v)\\in E$ \u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u4f4d\u4e8e $S$ \u548c $V-S$ \u4e2d\uff0c\u5219\u79f0 $(u,v)$ \u6a2a\u8de8\u5207\u5272 $(S,\\ V-S)$ \u5982\u679c\u8fb9\u96c6 $A$ \u4e0d\u5b58\u5728\u6a2a\u8de8 $(S,\\ V-S)$ \u7684\u8fb9\uff0c\u79f0 \u8be5\u5207\u5272 \u5c0a\u91cd $A$ \u6a2a\u8de8\u4e00\u4e2a\u5207\u5272\u7684\u6240\u6709\u8fb9\u4e2d\uff0c\u6743\u91cd\u6700\u5c0f\u7684\u8fb9\u79f0\u4e3a light edge (3). \u5b89\u5168\u8fb9\u7684\u9009\u53d6 \ud83e\uddd0 \u65e0\u5411\u56fe $G=(V,E)$\uff0c$A\\subset E$ \u4e14 $A$ \u662f $G$ \u7684\u4e00\u9897 MST \u7684\u5b50\u96c6\u3002\u8bbe $(S, V-S)$ \u662f $G$ \u4e2d\u5c0a\u91cd $A$ \u7684\u4efb\u4e00\u5207\u5272\uff0c$(u,v)$ \u662f\u6a2a\u8de8 $(S, V-S)$ \u7684\u4e00\u6761 light edge\uff0c\u5219 $(u, v)$ \u5bf9\u4e8e $A$ \u662f\u5b89\u5168\u7684 \u8bbe $T$ \u662f\u4e00\u9897 MST \u4e14 $(u,v)\\notin T$\u3002\u5219\u5728 $T$ \u7684\u4ece $u$ \u5230 $v$ \u7684\u8def\u5f84\u4e0a\u4e00\u5b9a\u5b58\u5728\u4e00\u6761\u8fb9 $(x,y)$ cross $(S,V-S)$\uff0c\u4ee4 $T'=T-\\lbrace (x,y) \\rbrace \\cup \\lbrace (u,v) \\rbrace$\uff0c\u5219 $w(T')\\leq w(T)$\uff0c\u7531\u4e8e $T$ \u662f MST\uff0c\u56e0\u6b64 $T'$ \u4e5f\u662f\u3002 \u2003 \u7531\u4e8e $A\\subseteq T$ \u4e14 $(x,y)\\notin A$\uff0c\u6240\u4ee5 $A\\subseteq T'$\uff1b\u7531\u4e8e $A\\cup (u,v)\\subseteq T'$\uff0c\u56e0\u6b64 $(u,v)$ \u5bf9\u4e8e $A$ \u662f\u5b89\u5168\u7684 \u7531\u6b64\uff0c\u6784\u5efa MST \u5373\u662f\u8fed\u4ee3\u300c\u9009\u53d6\u5207\u5206 - \u8ba1\u7b97 light edge\u300d\u7684\u8fc7\u7a0b\uff0c\u8981\u4e0e\u8981\u4ece cross edges \u4e2d\u8ba1\u7b97\u51fa light edge\uff0c \u5207\u5206 \u53ea\u8981 \u4fdd\u8bc1\u4e0d\u88ab\u5df2\u9009\u53d6\u7684 MST \u8fb9\u6a2a\u8de8 \u5373\u53ef. 2. Kruskal \u7b97\u6cd5 \ud83e\uddd0 Kruskal \u7b97\u6cd5\u7684\u96c6\u5408 A \u662f\u4e00\u4e2a\u68ee\u6797\uff0c\u521d\u59cb\u6709 $|V|$ \u4e2a\u68ee\u6797\u3002\u6bcf\u6b21\u627e\u5230\u8fde\u63a5\u4e24\u4e2a\u68ee\u6797\u4e14\u6700\u77ed\u7684\u8fb9 $(u,v)$\uff0c\u8bbe\u88ab\u8fde\u63a5\u7684\u4e24\u4e2a\u68ee\u6797\u4e3a $C_1$ \u548c $C_2$\uff0c\u90a3\u4e48 $(u,v)$ \u4e00\u5b9a\u662f $(C_1,V-C_1)$ \u7684 light edge 1 2 3 4 5 6 7 8 9 10 Kruskal ( G , w ) : A = \u2205 for each vertex v \u2208 G . V : Make - Set ( v ) sort the edges of G . E into nondecreasing order by weight for each edge ( u , v ) \u2208 G . E ( taken in nondecreasing order ) : if Find - Set ( u ) \u2260 Find - Set ( v ) : A = A \u222a {( u , v )} Union ( u , v ) return A \u590d\u6742\u5ea6 $O(E\\lg E + (V+E)\\alpha(V))$\uff0c\u53ef\u4ee5\u8868\u793a\u4e3a $O(E\\lg E)$ \u6216 $O(E\\lg V)$ 3. Prim \u7b97\u6cd5 \ud83e\uddd0 Prim \u7b97\u6cd5\u7684\u96c6\u5408 A \u662f\u4e00\u9897\u6811\uff0c\u521d\u59cb\u53ea\u6709\u4e00\u4e2a\u6839\u7ed3\u70b9\u3002\u6700\u5c0f\u5806\u7ef4\u62a4 $(A, V-A)$ \u7684\u6a2a\u5207\u8fb9\uff0c\u6bcf\u4e00\u8f6e\u9009\u53d6\u5176\u4e2d\u7684 light edge\uff0c\u7136\u540e\u66f4\u65b0\u6743\u91cd\uff0c\u7b97\u6cd5\u7ed3\u6784\u548c Dijkstra \u7c7b\u4f3c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 Prim ( G , w , r ): for each u \u2208 G . V : u . key = \u221e u . \u03c0 = Null r . key = 0 Q = G . V while Q \u2260 \u2205 : u = Extract - Min ( Q ) for each v \u2208 G . Adj [ u ]: if v \u2208 Q and w ( u , v ) < v . key : v . key = w ( u , v ) v . \u03c0 = u return {( v , v . \u03c0 ) | v \u2208 V - { r }} \u590d\u6742\u5ea6\u4e3a $O(V\\lg V + E\\lg V)$","title":"2. minium spanning trees"},{"location":"_algorithm/_graph/mst/#1","text":"","title":"1. \u6700\u5c0f\u751f\u6210\u6811\u7684\u5f62\u6210"},{"location":"_algorithm/_graph/mst/#1_1","text":"Kruskal \u548c Prim \u7b97\u6cd5\u90fd\u4f7f\u7528\u8d2a\u5fc3\u7684\u6846\u67b6\u6c42\u89e3 MST\uff0c\u533a\u522b\u5728\u4e8e\u8d2a\u5fc3\u7684\u7b56\u7565\u4e0d\u540c 1 2 3 4 5 6 Generic - MST ( G , w ) : A = \u2205 while A does not form a spanning tree : find an edge that is safe for A A = A \u222a {( u , v )} return A","title":"(1). \u7b97\u6cd5\u6846\u67b6"},{"location":"_algorithm/_graph/mst/#2","text":"\u5b89\u5168\u8fb9: \u2002 \u4e0d\u7834\u574f Generic-MST \u7684\u8d2a\u5fc3\u5faa\u73af\u4e0d\u53d8\u5f0f\u6027\u8d28\u7684\u8fb9 (u,v) \u5207\u5272 (cut): \u2002 $(S,\\ V-S)$ \u662f $V$ \u7684\u4e00\u4e2a\u5212\u5206 \u6a2a\u8de8 (cross): \u2002 \u5982\u679c $(u,v)\\in E$ \u7684\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u4f4d\u4e8e $S$ \u548c $V-S$ \u4e2d\uff0c\u5219\u79f0 $(u,v)$ \u6a2a\u8de8\u5207\u5272 $(S,\\ V-S)$ \u5982\u679c\u8fb9\u96c6 $A$ \u4e0d\u5b58\u5728\u6a2a\u8de8 $(S,\\ V-S)$ \u7684\u8fb9\uff0c\u79f0 \u8be5\u5207\u5272 \u5c0a\u91cd $A$ \u6a2a\u8de8\u4e00\u4e2a\u5207\u5272\u7684\u6240\u6709\u8fb9\u4e2d\uff0c\u6743\u91cd\u6700\u5c0f\u7684\u8fb9\u79f0\u4e3a light edge","title":"(2). \u4e00\u4e9b\u5b9a\u4e49"},{"location":"_algorithm/_graph/mst/#3","text":"\u65e0\u5411\u56fe $G=(V,E)$\uff0c$A\\subset E$ \u4e14 $A$ \u662f $G$ \u7684\u4e00\u9897 MST \u7684\u5b50\u96c6\u3002\u8bbe $(S, V-S)$ \u662f $G$ \u4e2d\u5c0a\u91cd $A$ \u7684\u4efb\u4e00\u5207\u5272\uff0c$(u,v)$ \u662f\u6a2a\u8de8 $(S, V-S)$ \u7684\u4e00\u6761 light edge\uff0c\u5219 $(u, v)$ \u5bf9\u4e8e $A$ \u662f\u5b89\u5168\u7684 \u8bbe $T$ \u662f\u4e00\u9897 MST \u4e14 $(u,v)\\notin T$\u3002\u5219\u5728 $T$ \u7684\u4ece $u$ \u5230 $v$ \u7684\u8def\u5f84\u4e0a\u4e00\u5b9a\u5b58\u5728\u4e00\u6761\u8fb9 $(x,y)$ cross $(S,V-S)$\uff0c\u4ee4 $T'=T-\\lbrace (x,y) \\rbrace \\cup \\lbrace (u,v) \\rbrace$\uff0c\u5219 $w(T')\\leq w(T)$\uff0c\u7531\u4e8e $T$ \u662f MST\uff0c\u56e0\u6b64 $T'$ \u4e5f\u662f\u3002 \u2003 \u7531\u4e8e $A\\subseteq T$ \u4e14 $(x,y)\\notin A$\uff0c\u6240\u4ee5 $A\\subseteq T'$\uff1b\u7531\u4e8e $A\\cup (u,v)\\subseteq T'$\uff0c\u56e0\u6b64 $(u,v)$ \u5bf9\u4e8e $A$ \u662f\u5b89\u5168\u7684 \u7531\u6b64\uff0c\u6784\u5efa MST \u5373\u662f\u8fed\u4ee3\u300c\u9009\u53d6\u5207\u5206 - \u8ba1\u7b97 light edge\u300d\u7684\u8fc7\u7a0b\uff0c\u8981\u4e0e\u8981\u4ece cross edges \u4e2d\u8ba1\u7b97\u51fa light edge\uff0c \u5207\u5206 \u53ea\u8981 \u4fdd\u8bc1\u4e0d\u88ab\u5df2\u9009\u53d6\u7684 MST \u8fb9\u6a2a\u8de8 \u5373\u53ef.","title":"(3). \u5b89\u5168\u8fb9\u7684\u9009\u53d6"},{"location":"_algorithm/_graph/mst/#2-kruskal","text":"Kruskal \u7b97\u6cd5\u7684\u96c6\u5408 A \u662f\u4e00\u4e2a\u68ee\u6797\uff0c\u521d\u59cb\u6709 $|V|$ \u4e2a\u68ee\u6797\u3002\u6bcf\u6b21\u627e\u5230\u8fde\u63a5\u4e24\u4e2a\u68ee\u6797\u4e14\u6700\u77ed\u7684\u8fb9 $(u,v)$\uff0c\u8bbe\u88ab\u8fde\u63a5\u7684\u4e24\u4e2a\u68ee\u6797\u4e3a $C_1$ \u548c $C_2$\uff0c\u90a3\u4e48 $(u,v)$ \u4e00\u5b9a\u662f $(C_1,V-C_1)$ \u7684 light edge 1 2 3 4 5 6 7 8 9 10 Kruskal ( G , w ) : A = \u2205 for each vertex v \u2208 G . V : Make - Set ( v ) sort the edges of G . E into nondecreasing order by weight for each edge ( u , v ) \u2208 G . E ( taken in nondecreasing order ) : if Find - Set ( u ) \u2260 Find - Set ( v ) : A = A \u222a {( u , v )} Union ( u , v ) return A \u590d\u6742\u5ea6 $O(E\\lg E + (V+E)\\alpha(V))$\uff0c\u53ef\u4ee5\u8868\u793a\u4e3a $O(E\\lg E)$ \u6216 $O(E\\lg V)$","title":"2. Kruskal \u7b97\u6cd5"},{"location":"_algorithm/_graph/mst/#3-prim","text":"Prim \u7b97\u6cd5\u7684\u96c6\u5408 A \u662f\u4e00\u9897\u6811\uff0c\u521d\u59cb\u53ea\u6709\u4e00\u4e2a\u6839\u7ed3\u70b9\u3002\u6700\u5c0f\u5806\u7ef4\u62a4 $(A, V-A)$ \u7684\u6a2a\u5207\u8fb9\uff0c\u6bcf\u4e00\u8f6e\u9009\u53d6\u5176\u4e2d\u7684 light edge\uff0c\u7136\u540e\u66f4\u65b0\u6743\u91cd\uff0c\u7b97\u6cd5\u7ed3\u6784\u548c Dijkstra \u7c7b\u4f3c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 Prim ( G , w , r ): for each u \u2208 G . V : u . key = \u221e u . \u03c0 = Null r . key = 0 Q = G . V while Q \u2260 \u2205 : u = Extract - Min ( Q ) for each v \u2208 G . Adj [ u ]: if v \u2208 Q and w ( u , v ) < v . key : v . key = w ( u , v ) v . \u03c0 = u return {( v , v . \u03c0 ) | v \u2208 V - { r }} \u590d\u6742\u5ea6\u4e3a $O(V\\lg V + E\\lg V)$","title":"3. Prim \u7b97\u6cd5"},{"location":"_algorithm/_graph/ss_allpairs/","text":"1. \u6982\u8ff0 \ud83e\uddd0 \u53ef\u4ee5\u901a\u8fc7\u8fd0\u884c $|V|$ \u6b21\u5355\u6e90\u6700\u77ed\u8def\u7b97\u6cd5: Dijkstra: \u2002 \u590d\u6742\u5ea6\u4e3a $O(V^3 + \\mathit{VE}) = O(V^3)$ \u6216 $O(\\mathit{VE\\ \\lg V})$\uff0c\u9002\u7528\u4e8e\u7a00\u758f\u56fe (\u65e0\u8d1f\u6743\u8fb9) Bellman-Ford: \u2002 \u590d\u6742\u5ea6\u4e3a $O(V^2 E)$\uff0c\u5bf9\u7a20\u5bc6\u56fe\u590d\u6742\u5ea6\u53ef\u8fbe $O(V^4)$\uff0c\u5f80\u5f80\u4e0d\u53ef\u63a5\u53d7 \u800c\u5bf9\u4e8e\u6240\u6709\u7ed3\u70b9\u5bf9\u7684\u6700\u77ed\u8def\u7b97\u6cd5: Floyd-Warshall: \u2002 \u65f6\u95f4 $O(n^3)$\uff0c\u7a7a\u95f4 $O(n^2)$\uff0c\u4f9d\u8d56\u4e8e\u90bb\u63a5\u77e9\u9635 2. Floyd-Warshall \u7b97\u6cd5 \ud83e\uddd0 (1). \u539f\u7406 \ud83e\uddd0 \u8bbe $G=(\\lbrace 1,2,...,n \\rbrace, E)$, \u8be5\u7b97\u6cd5\u4f9d\u8d56\u4e8e\u90bb\u63a5\u77e9\u9635\u8868\u793a $$ w_{ij} = \\begin{cases} 0 &\\text{if } i=j \\\\ \\text{weight of edge }i \\to j & \\text{if } i\\ne j \\text{ and } (i,j) \\in E\\\\ \\infty & \\text{if } i \\ne j \\text{ and } (i,j) \\notin E \\end{cases} $$ \u4ee4 $d^k(i,j)$ \u8868\u793a $i$ \u5230 $j$ \u7684\u6700\u77ed\u8def\uff0c\u8be5\u6700\u77ed\u8def\u7684\u6240\u6709\u4e2d\u95f4\u7ed3\u70b9\u5728 $\\lbrace 1,2,...,k\\rbrace$ \u5185\uff0c\u5219\u6709 $$ d^k(i,j) = \\begin{cases} w_{ij} & \\text{if } k=0 \\\\ \\min\\lbrace\\ d^{k-1}(i,j),\\ d^{k-1}(i,k) + d^{k-1}(k,j)\\ \\rbrace & \\text{else} \\end{cases} $$ \u7531\u6b64\uff0c\u8be5\u7b97\u6cd5\u6ca1\u6709\u7279\u522b\u7684\u9650\u5236\uff0c\u6ca1\u6709\u8d1f\u73af\u5373\u53ef 1 2 3 4 5 6 7 Floyd - Warshall ( w ) : d = w for k from 0 to n -1 : for i from 0 to n -1 : for j from 0 to n -1 : if d [ i ][ j ] > d [ i ][ k ] + d [ k ][ j ] : d [ i ][ j ] = d [ i ][ k ] + d [ k ][ j ] \u5728 Floyd-Warshall \u7b97\u6cd5\u7684\u7b2c 7 \u884c\uff0c\u53ef\u80fd\u5df2\u7ecf\u6709 $\\mathsf{d[i][k]}=d^{k}(i,k)$ \u6216 $\\mathsf{d[k][j]}=d^{k}(k,j)$\uff0c\u4f46\u7531\u4e8e\u8fd9\u4e24\u6761\u8def\u5f84\u4ee5\u7ed3\u70b9 $k$ \u5f00\u5934\u6216\u7ed3\u5c3e\uff0c$k$ \u4e00\u5b9a\u4e0d\u5728\u6700\u77ed\u8def\u7684\u4e2d\u95f4\u7ed3\u70b9\u96c6\u5408\u4e2d (\u6700\u77ed\u8def\u65e0\u73af)\uff0c\u56e0\u6b64\u6709 $d^{k-1}(i,k)=d^{k}(i,k)$ \u548c $d^{k-1}(k,j)=d^{k}(k,j)$\uff0c\u7b97\u6cd5\u7684\u6b63\u786e\u6027\u4f9d\u7136\u6210\u7acb (2). \u6709\u5411\u56fe\u7684\u4f20\u9012\u95ed\u5305 \ud83e\uddd0 \u5b9a\u4e49 $G$ \u7684\u4f20\u9012\u95ed\u5305\u4e3a $G^{*} = (V, E^{*})$\uff0c\u5176\u4e2d $E^{*}=\\lbrace (i,j):\\ \\text{if G contains an edge from }i\\text{ to }j\\rbrace$\uff0c\u5219\u53ef\u4ee5\u5957\u7528 Floyd-Warshall \u7684\u6a21\u677f $$ t_{ij}^0 = \\begin{cases} 0 & \\text{if } i \\ne j \\text{ and } (i,j) \\notin E \\\\ 1 & \\text{if } i = j \\text{ or } (i,j) \\in E \\end{cases} $$ $$ t_{ij}^k = t_{ij}^{k-1} \\lor (t_{ik}^{k-1} \\land t_{kj}^{k-1}) $$","title":"4. all-pairs shortest paths"},{"location":"_algorithm/_graph/ss_allpairs/#1","text":"\u53ef\u4ee5\u901a\u8fc7\u8fd0\u884c $|V|$ \u6b21\u5355\u6e90\u6700\u77ed\u8def\u7b97\u6cd5: Dijkstra: \u2002 \u590d\u6742\u5ea6\u4e3a $O(V^3 + \\mathit{VE}) = O(V^3)$ \u6216 $O(\\mathit{VE\\ \\lg V})$\uff0c\u9002\u7528\u4e8e\u7a00\u758f\u56fe (\u65e0\u8d1f\u6743\u8fb9) Bellman-Ford: \u2002 \u590d\u6742\u5ea6\u4e3a $O(V^2 E)$\uff0c\u5bf9\u7a20\u5bc6\u56fe\u590d\u6742\u5ea6\u53ef\u8fbe $O(V^4)$\uff0c\u5f80\u5f80\u4e0d\u53ef\u63a5\u53d7 \u800c\u5bf9\u4e8e\u6240\u6709\u7ed3\u70b9\u5bf9\u7684\u6700\u77ed\u8def\u7b97\u6cd5: Floyd-Warshall: \u2002 \u65f6\u95f4 $O(n^3)$\uff0c\u7a7a\u95f4 $O(n^2)$\uff0c\u4f9d\u8d56\u4e8e\u90bb\u63a5\u77e9\u9635","title":"1. \u6982\u8ff0"},{"location":"_algorithm/_graph/ss_allpairs/#2-floyd-warshall","text":"","title":"2. Floyd-Warshall \u7b97\u6cd5"},{"location":"_algorithm/_graph/ss_allpairs/#1_1","text":"\u8bbe $G=(\\lbrace 1,2,...,n \\rbrace, E)$, \u8be5\u7b97\u6cd5\u4f9d\u8d56\u4e8e\u90bb\u63a5\u77e9\u9635\u8868\u793a $$ w_{ij} = \\begin{cases} 0 &\\text{if } i=j \\\\ \\text{weight of edge }i \\to j & \\text{if } i\\ne j \\text{ and } (i,j) \\in E\\\\ \\infty & \\text{if } i \\ne j \\text{ and } (i,j) \\notin E \\end{cases} $$ \u4ee4 $d^k(i,j)$ \u8868\u793a $i$ \u5230 $j$ \u7684\u6700\u77ed\u8def\uff0c\u8be5\u6700\u77ed\u8def\u7684\u6240\u6709\u4e2d\u95f4\u7ed3\u70b9\u5728 $\\lbrace 1,2,...,k\\rbrace$ \u5185\uff0c\u5219\u6709 $$ d^k(i,j) = \\begin{cases} w_{ij} & \\text{if } k=0 \\\\ \\min\\lbrace\\ d^{k-1}(i,j),\\ d^{k-1}(i,k) + d^{k-1}(k,j)\\ \\rbrace & \\text{else} \\end{cases} $$ \u7531\u6b64\uff0c\u8be5\u7b97\u6cd5\u6ca1\u6709\u7279\u522b\u7684\u9650\u5236\uff0c\u6ca1\u6709\u8d1f\u73af\u5373\u53ef 1 2 3 4 5 6 7 Floyd - Warshall ( w ) : d = w for k from 0 to n -1 : for i from 0 to n -1 : for j from 0 to n -1 : if d [ i ][ j ] > d [ i ][ k ] + d [ k ][ j ] : d [ i ][ j ] = d [ i ][ k ] + d [ k ][ j ] \u5728 Floyd-Warshall \u7b97\u6cd5\u7684\u7b2c 7 \u884c\uff0c\u53ef\u80fd\u5df2\u7ecf\u6709 $\\mathsf{d[i][k]}=d^{k}(i,k)$ \u6216 $\\mathsf{d[k][j]}=d^{k}(k,j)$\uff0c\u4f46\u7531\u4e8e\u8fd9\u4e24\u6761\u8def\u5f84\u4ee5\u7ed3\u70b9 $k$ \u5f00\u5934\u6216\u7ed3\u5c3e\uff0c$k$ \u4e00\u5b9a\u4e0d\u5728\u6700\u77ed\u8def\u7684\u4e2d\u95f4\u7ed3\u70b9\u96c6\u5408\u4e2d (\u6700\u77ed\u8def\u65e0\u73af)\uff0c\u56e0\u6b64\u6709 $d^{k-1}(i,k)=d^{k}(i,k)$ \u548c $d^{k-1}(k,j)=d^{k}(k,j)$\uff0c\u7b97\u6cd5\u7684\u6b63\u786e\u6027\u4f9d\u7136\u6210\u7acb","title":"(1). \u539f\u7406"},{"location":"_algorithm/_graph/ss_allpairs/#2","text":"\u5b9a\u4e49 $G$ \u7684\u4f20\u9012\u95ed\u5305\u4e3a $G^{*} = (V, E^{*})$\uff0c\u5176\u4e2d $E^{*}=\\lbrace (i,j):\\ \\text{if G contains an edge from }i\\text{ to }j\\rbrace$\uff0c\u5219\u53ef\u4ee5\u5957\u7528 Floyd-Warshall \u7684\u6a21\u677f $$ t_{ij}^0 = \\begin{cases} 0 & \\text{if } i \\ne j \\text{ and } (i,j) \\notin E \\\\ 1 & \\text{if } i = j \\text{ or } (i,j) \\in E \\end{cases} $$ $$ t_{ij}^k = t_{ij}^{k-1} \\lor (t_{ik}^{k-1} \\land t_{kj}^{k-1}) $$","title":"(2). \u6709\u5411\u56fe\u7684\u4f20\u9012\u95ed\u5305"},{"location":"_algorithm/_graph/ss_shortest/","text":"1. \u6700\u77ed\u8def\u6027\u8d28 \ud83e\uddd0 \u7ed9\u5b9a\u56fe $G=(V,E)$\uff0c$\\delta(u,v)$ \u8868\u793a\u6700\u77ed\u8def\u957f (\u4e0d\u5b58\u5728\u5219\u4e3a $\\infty$)\uff0c$w(p)$ \u8868\u793a\u8def\u5f84\u6743\u91cd\u548c\u3002\u5bf9\u4efb\u610f\u7ed3\u70b9 $d$: $v.d$ \u8868\u793a $s$ \u5230 $v$ \u7684\u6700\u77ed\u8def\u4f30\u8ba1\uff0c $v.\\pi$ \u8868\u793a $v$ \u7684\u524d\u9a71\uff0c\u8be5\u503c\u8bf1\u5bfc\u4e00\u4e2a\u524d\u9a71\u5b50\u56fe $G_\\pi$\uff0c\u8be5\u56fe\u662f $s$ \u7684\u6700\u77ed\u8def\u5f84\u6811 1 2 3 4 Init - Single - Source ( G , s ) v . d = \u221e v . \u03c0 = Null s . d = 0 (1). \u6700\u4f18\u5b50\u7ed3\u6784 \ud83e\uddd0 (\u6700\u4f18\u5b50\u7ed3\u6784) \u8bbe $p=\\langle v_0, v_1,...,v_k \\rangle$ \u662f\u4ece $v_0$ \u5230 $v_k$ \u7684\u4e00\u6761\u6700\u77ed\u8def\uff0c$p_{ij}=\\langle v_i,v_{i+1},...,v_j\\rangle$ \u662f $p$ \u7684\u4e00\u6761\u5b50\u8def\u5f84\uff0c\u90a3\u4e48 $p_{ij}$ \u662f\u4ece $v_i$ \u5230 $v_j$ \u7684\u4e00\u6761\u6700\u77ed\u8def (2). \u677e\u5f1b\u64cd\u4f5c\u53ca\u5176\u6027\u8d28 \ud83e\uddd0 \u677e\u5f1b\u7684\u64cd\u4f5c\u5bf9\u8c61\u4e3a\u8fb9 $(u,v)$ \u548c\u76ee\u6807\u70b9 $v$ 1 2 3 4 Relax ( u , v , w ) if v . d > u . d + w ( u , v ) v . d = u . d + w ( u , v ) v . \u03c0 = u (\u6536\u655b\u6027\u8d28) \u82e5 $s\\leadsto u \\to v$ \u662f $G$ \u4e2d\u7684\u4e00\u6761\u6700\u77ed\u8def\uff0c\u4e14\u677e\u5f1b $(u,v)$ \u524d\u6709 $u.d=\\delta(s,u)$\uff0c\u5219\u4e4b\u540e\u7684\u6240\u6709\u65f6\u95f4\u6709 $v.d=\\delta(s,v)$ (\u8def\u5f84\u677e\u5f1b\u6027\u8d28) \u8bbe $s=v_0$, $p=\\langle v_0, v_1,...,v_k \\rangle$ \u662f $G$ \u7684\u4e00\u6761\u6700\u77ed\u8def\uff0c$p$ \u4e2d\u7684\u8fb9\u677e\u5f1b\u7684\u76f8\u5bf9\u6b21\u5e8f\u4e3a $(v_0,v_1)$,$(v_1,v_2)$,$...$,$(v_{k-1},v_k)$\uff0c\u5219 $v_k.d=\\delta(s,v_k)$ (\u4e0a\u754c\u6027\u8d28) \u2002 $\\forall v \\in V,\\ v.d\\geq \\delta(s,v)$. \u4e00\u65e6 $v.d$ \u7684\u53d6\u503c\u8fbe\u5230 $\\delta(s,v)$\uff0c\u5176\u503c\u65e0\u6cd5\u901a\u8fc7\u677e\u5f1b\u6539\u53d8 (\u4e09\u89d2\u4e0d\u7b49\u5f0f) \u2002 $\\forall (u,v) \\in E,\\ \\delta(s,v) \\leq \\delta(s,u) + w(u,v)$ 2. Bellman-Ford \u7b97\u6cd5 \ud83e\uddd0 1 2 3 4 5 6 7 8 9 Bellman - Ford ( G , s , w ) Init - Single - Source ( G , s ) for i = 1 to | G . V | -1 : for each edge ( u , v ) \u2208 G . E Relax ( u , v , w ) for each edge ( u , v ) \u2208 G . E if v . d > u . d + w ( u , v ) return False return True \u601d\u8def: 3-5 \u884c\u5bf9\u8fb9\u7684\u96c6\u5408\u6267\u884c $|V|-1$ \u6b21\u677e\u5f1b\uff0c\u4fdd\u8bc1\u6bcf\u6761\u6700\u77ed\u8def\u90fd\u53ef\u4ee5\u88ab\u677e\u5f1b\u51fa\u6765\uff1b \u5982\u679c\u5b58\u5728\u8d1f\u73af\u8def\uff0c\u76f4\u89c2\u4e0a\u6765\u770b\uff0c\u8d1f\u73af\u4e0a\u80af\u5b9a\u5b58\u5728\u67d0\u6761\u8fb9\u4ecd\u7136\u53ef\u4ee5\u88ab\u677e\u5f1b \u5047\u8bbe $G$ \u5305\u542b\u53ef\u7531 $s$ \u5230\u8fbe\u7684\u8d1f\u73af\uff0c\u5219 6-8 \u884c\u4e00\u5b9a\u53ef\u4ee5\u68c0\u6d4b\u5230 \u5047\u8bbe\u8be5\u8d1f\u73af\u4e3a $c=\\langle v_0, v_1, ... ,v_k \\rangle$\uff0c\u5176\u4e2d $v_0=v_k$\uff0c\u90a3\u4e48 $\\displaystyle \\sum _ {i=1}^k w(v_{i-1}, v_i) < 0$ \u73b0\u5047\u8bbe\u73af\u4e0a\u6bcf\u6761\u8fb9\u90fd\u4e0d\u80fd\u518d\u677e\u5f1b\u4e86\uff0c\u5373 $v_i.d \\leq v_{i-1}.d + w(v_{i-1}, v_i)$\uff0c\u76f8\u52a0\u53ef\u5f97: $$ \\sum _ {i=1}^k v_i.d \\leq \\sum _ {i=1}^k (v_{i-1}.d + w(v_{i-1}, v_i)) = \\sum _ {i=1}^k v_{i}.d + \\sum _ {i=1}^k w(v_{i-1}, v_i) $$ \u4e0e\u5047\u8bbe\u77db\u76fe\u3002 \u590d\u6742\u5ea6 $O(VE)$ 3. Dijkstra \u7b97\u6cd5 \ud83e\uddd0 1 2 3 4 5 6 7 8 9 Dijkstra ( G , s , w ) Init - Single - Source ( G , s ) C = \u2205 // close set O = G . V // open set while O != \u2205 u = Extract - Min ( O ) C = C \u222a { u } for each vertex v \u2208 G . Adj [ u ] Relax ( u , v , w ) Dijkstra \u7b97\u6cd5\u603b\u662f\u5728 $\\mathit{Open - Close}$ \u4e2d\u505a\u51fa\u8d2a\u5fc3\u9009\u62e9\uff0c\u9009\u53d6\u6700\u8fd1\u7684\u70b9\u52a0\u5165 $O$ \u4e2d\u3002 (Dijkstra \u6b63\u786e\u6027) \u5f53\u7ed3\u70b9 $u$ \u5373\u5c06\u88ab\u52a0\u5165 $C$ \u65f6\uff0c\u6709 $u.d = \\delta(s,u)$ \u5047\u8bbe $u$ \u662f\u7b2c\u4e00\u4e2a\u4f7f\u5f97\u8be5\u7ed3\u8bba\u4e0d\u6210\u7acb\u7684\u7ed3\u70b9 ($u\\ne s$ \u4e14 $C\\ne\\emptyset$)\uff0c\u5047\u8bbe $w(p)=\\delta(s,u)$\uff0c\u5047\u8bbe $y$ \u662f $s$ \u5230 $u$ \u7684\u8def\u4e0a\u7b2c\u4e00\u4e2a\u5728\u96c6\u5408 $V-C$ \u4e2d\u7684\u7ed3\u70b9\uff0c$x$ \u662f $y$ \u7684\u524d\u9a71\uff0c\u8fd9\u6837\u5c31\u5c06 $p$ \u5206\u89e3\u4e3a $s \\overset{p_1}{\\leadsto} x \\to y \\overset{p_2}{\\leadsto} u$ ($p_1$ \u6216 $p_2$ \u53ef\u80fd\u4e0d\u5305\u542b\u4efb\u4f55\u8fb9) \u7531\u4e8e $x$ \u5df2\u5728 $C$ \u4e2d\uff0c\u5fc5\u6709 $y.d = \\delta(s,y)$\uff0c\u53c8\u56e0\u4e3a\u6240\u6709\u8fb9\u975e\u8d1f\uff0c\u6709 $y.d = \\delta(s,y) \\leq \\delta(s,u) \\leq u.d$; \u7531\u4e8e $u$ \u5373\u5c06\u88ab\u52a0\u5165 $C$\uff0c\u6709 $u.d \\leq y.d$\uff0c\u6709 $y.d = \\delta(s,u) = u.d$ \u6210\u7acb\uff0c\u4e0e\u5047\u8bbe\u77db\u76fe \u8fd9\u4e5f\u8bf4\u660e\u5982\u679c\u6709\u8d1f\u6743\u8fb9\u5b58\u5728\uff0c\u53ef\u80fd\u5bfc\u81f4 $y.d=\\delta(s,y) > u.d > \\delta(s,u)$\uff0c\u4f8b\u5982 \u8be5\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\u4e3b\u8981\u6765\u81ea\u4e8e Extract-Min \u548c \u66f4\u65b0 $O$ \u4e2d\u7684\u6743\u503c\u4e24\u90e8\u5206 \u6734\u7d20\u5b9e\u73b0: $O(V\\cdot V + E) = O(V^2)$ \u6700\u5c0f\u5806\u5b9e\u73b0: $O(V\\cdot \\lg V + E\\cdot\\lg V)$\u3002\u5982\u679c $G$ \u662f\u7a00\u758f\u56fe\uff0c\u8be5\u65b9\u6848\u76f8\u5bf9 $O(V^2)$ \u4f1a\u6709\u6539\u5584","title":"3. single-source shortest paths"},{"location":"_algorithm/_graph/ss_shortest/#1","text":"\u7ed9\u5b9a\u56fe $G=(V,E)$\uff0c$\\delta(u,v)$ \u8868\u793a\u6700\u77ed\u8def\u957f (\u4e0d\u5b58\u5728\u5219\u4e3a $\\infty$)\uff0c$w(p)$ \u8868\u793a\u8def\u5f84\u6743\u91cd\u548c\u3002\u5bf9\u4efb\u610f\u7ed3\u70b9 $d$: $v.d$ \u8868\u793a $s$ \u5230 $v$ \u7684\u6700\u77ed\u8def\u4f30\u8ba1\uff0c $v.\\pi$ \u8868\u793a $v$ \u7684\u524d\u9a71\uff0c\u8be5\u503c\u8bf1\u5bfc\u4e00\u4e2a\u524d\u9a71\u5b50\u56fe $G_\\pi$\uff0c\u8be5\u56fe\u662f $s$ \u7684\u6700\u77ed\u8def\u5f84\u6811 1 2 3 4 Init - Single - Source ( G , s ) v . d = \u221e v . \u03c0 = Null s . d = 0","title":"1. \u6700\u77ed\u8def\u6027\u8d28"},{"location":"_algorithm/_graph/ss_shortest/#1_1","text":"(\u6700\u4f18\u5b50\u7ed3\u6784) \u8bbe $p=\\langle v_0, v_1,...,v_k \\rangle$ \u662f\u4ece $v_0$ \u5230 $v_k$ \u7684\u4e00\u6761\u6700\u77ed\u8def\uff0c$p_{ij}=\\langle v_i,v_{i+1},...,v_j\\rangle$ \u662f $p$ \u7684\u4e00\u6761\u5b50\u8def\u5f84\uff0c\u90a3\u4e48 $p_{ij}$ \u662f\u4ece $v_i$ \u5230 $v_j$ \u7684\u4e00\u6761\u6700\u77ed\u8def","title":"(1). \u6700\u4f18\u5b50\u7ed3\u6784"},{"location":"_algorithm/_graph/ss_shortest/#2","text":"\u677e\u5f1b\u7684\u64cd\u4f5c\u5bf9\u8c61\u4e3a\u8fb9 $(u,v)$ \u548c\u76ee\u6807\u70b9 $v$ 1 2 3 4 Relax ( u , v , w ) if v . d > u . d + w ( u , v ) v . d = u . d + w ( u , v ) v . \u03c0 = u (\u6536\u655b\u6027\u8d28) \u82e5 $s\\leadsto u \\to v$ \u662f $G$ \u4e2d\u7684\u4e00\u6761\u6700\u77ed\u8def\uff0c\u4e14\u677e\u5f1b $(u,v)$ \u524d\u6709 $u.d=\\delta(s,u)$\uff0c\u5219\u4e4b\u540e\u7684\u6240\u6709\u65f6\u95f4\u6709 $v.d=\\delta(s,v)$ (\u8def\u5f84\u677e\u5f1b\u6027\u8d28) \u8bbe $s=v_0$, $p=\\langle v_0, v_1,...,v_k \\rangle$ \u662f $G$ \u7684\u4e00\u6761\u6700\u77ed\u8def\uff0c$p$ \u4e2d\u7684\u8fb9\u677e\u5f1b\u7684\u76f8\u5bf9\u6b21\u5e8f\u4e3a $(v_0,v_1)$,$(v_1,v_2)$,$...$,$(v_{k-1},v_k)$\uff0c\u5219 $v_k.d=\\delta(s,v_k)$ (\u4e0a\u754c\u6027\u8d28) \u2002 $\\forall v \\in V,\\ v.d\\geq \\delta(s,v)$. \u4e00\u65e6 $v.d$ \u7684\u53d6\u503c\u8fbe\u5230 $\\delta(s,v)$\uff0c\u5176\u503c\u65e0\u6cd5\u901a\u8fc7\u677e\u5f1b\u6539\u53d8 (\u4e09\u89d2\u4e0d\u7b49\u5f0f) \u2002 $\\forall (u,v) \\in E,\\ \\delta(s,v) \\leq \\delta(s,u) + w(u,v)$","title":"(2). \u677e\u5f1b\u64cd\u4f5c\u53ca\u5176\u6027\u8d28"},{"location":"_algorithm/_graph/ss_shortest/#2-bellman-ford","text":"1 2 3 4 5 6 7 8 9 Bellman - Ford ( G , s , w ) Init - Single - Source ( G , s ) for i = 1 to | G . V | -1 : for each edge ( u , v ) \u2208 G . E Relax ( u , v , w ) for each edge ( u , v ) \u2208 G . E if v . d > u . d + w ( u , v ) return False return True \u601d\u8def: 3-5 \u884c\u5bf9\u8fb9\u7684\u96c6\u5408\u6267\u884c $|V|-1$ \u6b21\u677e\u5f1b\uff0c\u4fdd\u8bc1\u6bcf\u6761\u6700\u77ed\u8def\u90fd\u53ef\u4ee5\u88ab\u677e\u5f1b\u51fa\u6765\uff1b \u5982\u679c\u5b58\u5728\u8d1f\u73af\u8def\uff0c\u76f4\u89c2\u4e0a\u6765\u770b\uff0c\u8d1f\u73af\u4e0a\u80af\u5b9a\u5b58\u5728\u67d0\u6761\u8fb9\u4ecd\u7136\u53ef\u4ee5\u88ab\u677e\u5f1b \u5047\u8bbe $G$ \u5305\u542b\u53ef\u7531 $s$ \u5230\u8fbe\u7684\u8d1f\u73af\uff0c\u5219 6-8 \u884c\u4e00\u5b9a\u53ef\u4ee5\u68c0\u6d4b\u5230 \u5047\u8bbe\u8be5\u8d1f\u73af\u4e3a $c=\\langle v_0, v_1, ... ,v_k \\rangle$\uff0c\u5176\u4e2d $v_0=v_k$\uff0c\u90a3\u4e48 $\\displaystyle \\sum _ {i=1}^k w(v_{i-1}, v_i) < 0$ \u73b0\u5047\u8bbe\u73af\u4e0a\u6bcf\u6761\u8fb9\u90fd\u4e0d\u80fd\u518d\u677e\u5f1b\u4e86\uff0c\u5373 $v_i.d \\leq v_{i-1}.d + w(v_{i-1}, v_i)$\uff0c\u76f8\u52a0\u53ef\u5f97: $$ \\sum _ {i=1}^k v_i.d \\leq \\sum _ {i=1}^k (v_{i-1}.d + w(v_{i-1}, v_i)) = \\sum _ {i=1}^k v_{i}.d + \\sum _ {i=1}^k w(v_{i-1}, v_i) $$ \u4e0e\u5047\u8bbe\u77db\u76fe\u3002 \u590d\u6742\u5ea6 $O(VE)$","title":"2. Bellman-Ford \u7b97\u6cd5"},{"location":"_algorithm/_graph/ss_shortest/#3-dijkstra","text":"1 2 3 4 5 6 7 8 9 Dijkstra ( G , s , w ) Init - Single - Source ( G , s ) C = \u2205 // close set O = G . V // open set while O != \u2205 u = Extract - Min ( O ) C = C \u222a { u } for each vertex v \u2208 G . Adj [ u ] Relax ( u , v , w ) Dijkstra \u7b97\u6cd5\u603b\u662f\u5728 $\\mathit{Open - Close}$ \u4e2d\u505a\u51fa\u8d2a\u5fc3\u9009\u62e9\uff0c\u9009\u53d6\u6700\u8fd1\u7684\u70b9\u52a0\u5165 $O$ \u4e2d\u3002 (Dijkstra \u6b63\u786e\u6027) \u5f53\u7ed3\u70b9 $u$ \u5373\u5c06\u88ab\u52a0\u5165 $C$ \u65f6\uff0c\u6709 $u.d = \\delta(s,u)$ \u5047\u8bbe $u$ \u662f\u7b2c\u4e00\u4e2a\u4f7f\u5f97\u8be5\u7ed3\u8bba\u4e0d\u6210\u7acb\u7684\u7ed3\u70b9 ($u\\ne s$ \u4e14 $C\\ne\\emptyset$)\uff0c\u5047\u8bbe $w(p)=\\delta(s,u)$\uff0c\u5047\u8bbe $y$ \u662f $s$ \u5230 $u$ \u7684\u8def\u4e0a\u7b2c\u4e00\u4e2a\u5728\u96c6\u5408 $V-C$ \u4e2d\u7684\u7ed3\u70b9\uff0c$x$ \u662f $y$ \u7684\u524d\u9a71\uff0c\u8fd9\u6837\u5c31\u5c06 $p$ \u5206\u89e3\u4e3a $s \\overset{p_1}{\\leadsto} x \\to y \\overset{p_2}{\\leadsto} u$ ($p_1$ \u6216 $p_2$ \u53ef\u80fd\u4e0d\u5305\u542b\u4efb\u4f55\u8fb9) \u7531\u4e8e $x$ \u5df2\u5728 $C$ \u4e2d\uff0c\u5fc5\u6709 $y.d = \\delta(s,y)$\uff0c\u53c8\u56e0\u4e3a\u6240\u6709\u8fb9\u975e\u8d1f\uff0c\u6709 $y.d = \\delta(s,y) \\leq \\delta(s,u) \\leq u.d$; \u7531\u4e8e $u$ \u5373\u5c06\u88ab\u52a0\u5165 $C$\uff0c\u6709 $u.d \\leq y.d$\uff0c\u6709 $y.d = \\delta(s,u) = u.d$ \u6210\u7acb\uff0c\u4e0e\u5047\u8bbe\u77db\u76fe \u8fd9\u4e5f\u8bf4\u660e\u5982\u679c\u6709\u8d1f\u6743\u8fb9\u5b58\u5728\uff0c\u53ef\u80fd\u5bfc\u81f4 $y.d=\\delta(s,y) > u.d > \\delta(s,u)$\uff0c\u4f8b\u5982 \u8be5\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\u4e3b\u8981\u6765\u81ea\u4e8e Extract-Min \u548c \u66f4\u65b0 $O$ \u4e2d\u7684\u6743\u503c\u4e24\u90e8\u5206 \u6734\u7d20\u5b9e\u73b0: $O(V\\cdot V + E) = O(V^2)$ \u6700\u5c0f\u5806\u5b9e\u73b0: $O(V\\cdot \\lg V + E\\cdot\\lg V)$\u3002\u5982\u679c $G$ \u662f\u7a00\u758f\u56fe\uff0c\u8be5\u65b9\u6848\u76f8\u5bf9 $O(V^2)$ \u4f1a\u6709\u6539\u5584","title":"3. Dijkstra \u7b97\u6cd5"},{"location":"_algorithm/_sort/mergesort/","text":"1. \u5f52\u5e76 \ud83e\uddd0 \u5f52\u5e76\u6392\u5e8f\u5e94\u7528\u5206\u6cbb\u7684\u601d\u60f3\uff0c\u57fa\u672c\u64cd\u4f5c\u4e3a\u5408\u5e76\u4e24\u4e2a\u6709\u5e8f\u6570\u7ec4\u4f7f\u6574\u4f53\u6709\u5e8f public void Merge ( int arr [] , int l , int r , int rightEnd ) { int [] tmpArr = new int [ rightEnd - l ] ; int leftEnd = r , i = 0 ; while ( l < leftEnd && r < rightEnd ) { if ( arr [ l ] < arr [ r ] ) tmpArr [ i ++] = arr [ l ++] ; else tmpArr [ i ++] = arr [ r ++] ; } while ( l < leftEnd ) tmpArr [ i ++] = arr [ l ++] ; while ( r < rightEnd ) tmpArr [ i ++] = arr [ r ++] ; for ( int k = tmpArr . length - 1 ; k >= 0 ; -- k ) arr [ rightEnd - k - 1 ] = tmpArr [ tmpArr . length - 1 - k ] ; // Never } 2. \u9012\u5f52\u7248\u672c \ud83e\uddd0 \u4e8c\u5206\uff0c\u5de6\u53f3\u6392\u597d\u5e8f\u540e\u518d\u5f52\u5e76 public void MergeSort ( int arr [] , int l , int r ) { if ( l >= r - 1 ) return ; int mid = ( l + r ) / 2 ; MergeSort ( arr , l , mid ); MergeSort ( arr , mid , r ); Merge ( arr , l , mid , r ); } 3. \u975e\u9012\u5f52\u7248\u672c \ud83e\uddd0 \u4ece length=1 \u5f00\u59cb\uff0c\u628a\u6570\u7ec4\u89c6\u4e3a\u8fde\u7eed\u7684\u5f52\u5e76\u6bb5\uff0c\u6bcf\u4e00\u8f6e (Pass) \u4e24\u4e24\u5f52\u5e76 public void MergeSort ( int arr [] ) { int length = 1 ; while ( length < arr . length ) { MergePass ( arr , length ); length *= 2 ; } } public void MergePass ( int arr [] , int length ) { int i ; for ( i = 0 ; i <= arr . length - 2 * length ; i += 2 * length ) Merge ( arr , i , i + length , i + length * 2 ); if ( i + length <= arr . length - 1 ) Merge ( arr , i , i + length , arr . length ); }","title":"merge sort"},{"location":"_algorithm/_sort/mergesort/#1","text":"\u5f52\u5e76\u6392\u5e8f\u5e94\u7528\u5206\u6cbb\u7684\u601d\u60f3\uff0c\u57fa\u672c\u64cd\u4f5c\u4e3a\u5408\u5e76\u4e24\u4e2a\u6709\u5e8f\u6570\u7ec4\u4f7f\u6574\u4f53\u6709\u5e8f public void Merge ( int arr [] , int l , int r , int rightEnd ) { int [] tmpArr = new int [ rightEnd - l ] ; int leftEnd = r , i = 0 ; while ( l < leftEnd && r < rightEnd ) { if ( arr [ l ] < arr [ r ] ) tmpArr [ i ++] = arr [ l ++] ; else tmpArr [ i ++] = arr [ r ++] ; } while ( l < leftEnd ) tmpArr [ i ++] = arr [ l ++] ; while ( r < rightEnd ) tmpArr [ i ++] = arr [ r ++] ; for ( int k = tmpArr . length - 1 ; k >= 0 ; -- k ) arr [ rightEnd - k - 1 ] = tmpArr [ tmpArr . length - 1 - k ] ; // Never }","title":"1. \u5f52\u5e76"},{"location":"_algorithm/_sort/mergesort/#2","text":"\u4e8c\u5206\uff0c\u5de6\u53f3\u6392\u597d\u5e8f\u540e\u518d\u5f52\u5e76 public void MergeSort ( int arr [] , int l , int r ) { if ( l >= r - 1 ) return ; int mid = ( l + r ) / 2 ; MergeSort ( arr , l , mid ); MergeSort ( arr , mid , r ); Merge ( arr , l , mid , r ); }","title":"2. \u9012\u5f52\u7248\u672c"},{"location":"_algorithm/_sort/mergesort/#3","text":"\u4ece length=1 \u5f00\u59cb\uff0c\u628a\u6570\u7ec4\u89c6\u4e3a\u8fde\u7eed\u7684\u5f52\u5e76\u6bb5\uff0c\u6bcf\u4e00\u8f6e (Pass) \u4e24\u4e24\u5f52\u5e76 public void MergeSort ( int arr [] ) { int length = 1 ; while ( length < arr . length ) { MergePass ( arr , length ); length *= 2 ; } } public void MergePass ( int arr [] , int length ) { int i ; for ( i = 0 ; i <= arr . length - 2 * length ; i += 2 * length ) Merge ( arr , i , i + length , i + length * 2 ); if ( i + length <= arr . length - 1 ) Merge ( arr , i , i + length , arr . length ); }","title":"3. \u975e\u9012\u5f52\u7248\u672c"},{"location":"_algorithm/_string/trie/","text":"1. Trie \ud83e\uddd0 \u2003\u2003 \u524d\u7f00\u6811: \u8fb9\u4ee3\u8868\u5b57\u6bcd \u652f\u6301 insert \u3001 search \u3001 startsWith Trie class Trie { private : struct TrieNode { vector < unique_ptr < TrieNode >> children ; bool isEnd ; TrieNode () : children ( 26 ), isEnd ( false ) { } }; unique_ptr < TrieNode > root ; TrieNode * _searchPrefix ( string word ) { TrieNode * node = root . get (); for ( char c : word ) { int idx = c - 'a' ; if ( node -> children [ idx ] == nullptr ) { return nullptr ; } node = node -> children [ idx ]. get (); } return node ; } public : Trie () : root ( new TrieNode ()) { } void insert ( string word ) { TrieNode * node = root . get (); for ( char c : word ) { int idx = c - 'a' ; if ( node -> children [ idx ] == nullptr ) { node -> children [ idx ]. reset ( new TrieNode ()); } node = node -> children [ idx ]. get (); } node -> isEnd = true ; } bool search ( string word ) { TrieNode * node = _searchPrefix ( word ); return node && node -> isEnd ; } bool startsWith ( string prefix ) { return _searchPrefix ( prefix ); } };","title":"1. trie"},{"location":"_algorithm/_string/trie/#1-trie","text":"\u524d\u7f00\u6811: \u8fb9\u4ee3\u8868\u5b57\u6bcd \u652f\u6301 insert \u3001 search \u3001 startsWith Trie class Trie { private : struct TrieNode { vector < unique_ptr < TrieNode >> children ; bool isEnd ; TrieNode () : children ( 26 ), isEnd ( false ) { } }; unique_ptr < TrieNode > root ; TrieNode * _searchPrefix ( string word ) { TrieNode * node = root . get (); for ( char c : word ) { int idx = c - 'a' ; if ( node -> children [ idx ] == nullptr ) { return nullptr ; } node = node -> children [ idx ]. get (); } return node ; } public : Trie () : root ( new TrieNode ()) { } void insert ( string word ) { TrieNode * node = root . get (); for ( char c : word ) { int idx = c - 'a' ; if ( node -> children [ idx ] == nullptr ) { node -> children [ idx ]. reset ( new TrieNode ()); } node = node -> children [ idx ]. get (); } node -> isEnd = true ; } bool search ( string word ) { TrieNode * node = _searchPrefix ( word ); return node && node -> isEnd ; } bool startsWith ( string prefix ) { return _searchPrefix ( prefix ); } };","title":"1. Trie"},{"location":"_problems/","text":"128, 200, 130\uff0c 23, 207, 210, 671 out: 1323\uff0c38 (\u8003 api), 36","title":"Preface"},{"location":"_problems/_binary_tree/binary_tree/","text":"\u4e8c\u53c9\u6811\u904d\u5386 \ud83e\uddd0 \u5148\u5e8f\u8def\u5f84\u548c: 112. \u8def\u5f84\u603b\u548c (\u7ef4\u62a4\u8def\u5f84\u548c\u6216\u76f4\u63a5\u9012\u5f52) 113. \u8def\u5f84\u603b\u548c2 (\u5728\u8def\u5f84\u603b\u548c\u57fa\u7840\u4e0a\u7ef4\u62a4\u8def\u5f84) 437. \u8def\u5f84\u603b\u548c3 (\u53ea\u8981\u662f\u5411\u4e0b\u7684\u8def\u5f84\u5c31\u53ef\u4ee5\uff0c\u5f15\u5165\u524d\u7f00\u548c + hashmap) \u540e\u5e8f\u904d\u5386: 979. \u5728\u4e8c\u53c9\u6811\u4e2d\u5206\u914d\u786c\u5e01 (\u540e\u5e8f\u904d\u5386\uff0c\u80cc\u540e\u6697\u542b\u81ea\u5e95\u5411\u4e0a\u7684\u8d2a\u5fc3\u9009\u62e9) \u6784\u9020\u4e8c\u53c9\u6811: 105. \u4ece\u524d\u5e8f\u4e0e\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217\u6784\u9020\u4e8c\u53c9\u6811 (\u9012\u5f52\u6784\u9020 / \u6839\u636e\u975e\u9012\u5f52\u904d\u5386\u6784\u9020) 106. \u4ece\u4e2d\u5e8f\u4e0e\u540e\u5e8f\u904d\u5386\u5e8f\u5217\u6784\u9020\u4e8c\u53c9\u6811 () \u5c42\u5e8f\u904d\u5386: 101. \u5bf9\u79f0\u4e8c\u53c9\u6811 (\u540c\u65f6\u904d\u5386) 102. \u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386 (easy) 103. \u4e8c\u53c9\u6811\u7684\u952f\u9f7f\u5f62\u5c42\u5e8f\u904d\u5386 (deque + queue) 199. \u4e8c\u53c9\u6811\u7684\u53f3\u89c6\u56fe ?? 987. \u4e8c\u53c9\u6811\u7684\u5782\u5e8f\u904d\u5386","title":"Binary Tree"},{"location":"_problems/_binary_tree/binary_tree/#_1","text":"\u5148\u5e8f\u8def\u5f84\u548c: 112. \u8def\u5f84\u603b\u548c (\u7ef4\u62a4\u8def\u5f84\u548c\u6216\u76f4\u63a5\u9012\u5f52) 113. \u8def\u5f84\u603b\u548c2 (\u5728\u8def\u5f84\u603b\u548c\u57fa\u7840\u4e0a\u7ef4\u62a4\u8def\u5f84) 437. \u8def\u5f84\u603b\u548c3 (\u53ea\u8981\u662f\u5411\u4e0b\u7684\u8def\u5f84\u5c31\u53ef\u4ee5\uff0c\u5f15\u5165\u524d\u7f00\u548c + hashmap) \u540e\u5e8f\u904d\u5386: 979. \u5728\u4e8c\u53c9\u6811\u4e2d\u5206\u914d\u786c\u5e01 (\u540e\u5e8f\u904d\u5386\uff0c\u80cc\u540e\u6697\u542b\u81ea\u5e95\u5411\u4e0a\u7684\u8d2a\u5fc3\u9009\u62e9) \u6784\u9020\u4e8c\u53c9\u6811: 105. \u4ece\u524d\u5e8f\u4e0e\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217\u6784\u9020\u4e8c\u53c9\u6811 (\u9012\u5f52\u6784\u9020 / \u6839\u636e\u975e\u9012\u5f52\u904d\u5386\u6784\u9020) 106. \u4ece\u4e2d\u5e8f\u4e0e\u540e\u5e8f\u904d\u5386\u5e8f\u5217\u6784\u9020\u4e8c\u53c9\u6811 () \u5c42\u5e8f\u904d\u5386: 101. \u5bf9\u79f0\u4e8c\u53c9\u6811 (\u540c\u65f6\u904d\u5386) 102. \u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386 (easy) 103. \u4e8c\u53c9\u6811\u7684\u952f\u9f7f\u5f62\u5c42\u5e8f\u904d\u5386 (deque + queue) 199. \u4e8c\u53c9\u6811\u7684\u53f3\u89c6\u56fe ?? 987. \u4e8c\u53c9\u6811\u7684\u5782\u5e8f\u904d\u5386","title":"\u4e8c\u53c9\u6811\u904d\u5386"},{"location":"_problems/_dp/interval/","text":"\u533a\u95f4 \ud83e\uddd0 312. \u6233\u6c14\u7403 (\u6b63\u96be\u5219\u53cd) 664. \u5947\u602a\u7684\u6253\u5370\u673a (\u53d6\u5de7\u6784\u9020\u89e3\uff0c\u7b3c\u7edf\u5b50\u95ee\u9898) 887. \u9e21\u86cb\u6389\u843d (DP + \u4e8c\u5206) \u6811\u578b \ud83e\uddd0 543. \u4e8c\u53c9\u6811\u7684\u76f4\u5f84 (\u5178\u578b\u6811\u578b dp) 124. \u4e8c\u53c9\u6811\u7684\u6700\u5927\u8def\u5f84\u548c (\u76f4\u5f84\u7684\u53d8\u79cd) 979. \u5728\u4e8c\u53c9\u6811\u4e2d\u5206\u914d\u786c\u5e01 (\u6811\u578b\u8d2a\u5fc3) 337. \u6253\u5bb6\u52ab\u820d3","title":"interval"},{"location":"_problems/_dp/interval/#_1","text":"312. \u6233\u6c14\u7403 (\u6b63\u96be\u5219\u53cd) 664. \u5947\u602a\u7684\u6253\u5370\u673a (\u53d6\u5de7\u6784\u9020\u89e3\uff0c\u7b3c\u7edf\u5b50\u95ee\u9898) 887. \u9e21\u86cb\u6389\u843d (DP + \u4e8c\u5206)","title":"\u533a\u95f4"},{"location":"_problems/_dp/interval/#_2","text":"543. \u4e8c\u53c9\u6811\u7684\u76f4\u5f84 (\u5178\u578b\u6811\u578b dp) 124. \u4e8c\u53c9\u6811\u7684\u6700\u5927\u8def\u5f84\u548c (\u76f4\u5f84\u7684\u53d8\u79cd) 979. \u5728\u4e8c\u53c9\u6811\u4e2d\u5206\u914d\u786c\u5e01 (\u6811\u578b\u8d2a\u5fc3) 337. \u6253\u5bb6\u52ab\u820d3","title":"\u6811\u578b"},{"location":"_problems/_dp/linear/","text":"\u5355\u4e32 \ud83e\uddd0 \u7ecf\u5178\u5355\u4e32 300. LIS (\u7ecf\u5178\u5355\u4e32) 53. \u6700\u5927\u5b50\u5e8f\u548c (\u7ecf\u5178\u5355\u4e32) 152. \u4e58\u79ef\u6700\u5927\u5b50\u6570\u7ec4 (\u6700\u5927\u5b50\u5e8f\u548c\u53d8\u4f53) 91. \u89e3\u7801\u65b9\u6cd5 \u7b49\u5dee\u7cfb\u5217 413. \u7b49\u5dee\u6570\u5217\u5212\u5206 (\u4e00\u6b21\u904d\u5386\uff0c\u627e\u5230\u7b49\u5dee\u5b50\u5e8f\u5217\u6570\u76ee\uff0c\u975e dp\uff0c\u7528\u505a\u5bf9\u6bd4) 446. \u7b49\u5dee\u6570\u5217\u5212\u5206 ii (\u6c42\u7b49\u5dee\u5b50\u5e8f\u5217\u6570\u76ee\uff0c\u7ed3\u5408\u516c\u5dee\u7684\u4e00\u7ef4 dp) 1027. \u6700\u957f\u7b49\u5dee\u6570\u5217 (\u548c 446. \u7b49\u5dee\u6570\u5217\u5212\u5206 \u7c7b\u4f3c) \u80a1\u7968\u7cfb\u5217 121. \u4e70\u5356\u80a1\u7968\u7684\u6700\u4f73\u65f6\u673a 122. \u4e70\u5356\u80a1\u7968\u7684\u6700\u4f73\u65f6\u673a II 123. \u4e70\u5356\u80a1\u7968\u7684\u6700\u4f73\u65f6\u673a III 188. \u4e70\u5356\u80a1\u7968\u7684\u6700\u4f73\u65f6\u673a IV 309. \u6700\u4f73\u4e70\u5356\u80a1\u7968\u65f6\u673a\u542b\u51b7\u51bb\u671f 714. \u4e70\u5356\u80a1\u7968\u7684\u6700\u4f73\u65f6\u673a\u542b\u624b\u7eed\u8d39 \u6253\u5bb6\u52ab\u820d\u7cfb\u5217 198. \u6253\u5bb6\u52ab\u820d 213. \u6253\u5bb6\u52ab\u820d 2 \u53cc\u4e32 \ud83e\uddd0 \u5b57\u7b26\u4e32\u5339\u914d 10. \u6b63\u5219\u8868\u8fbe\u5f0f\u5339\u914d 44. \u901a\u914d\u7b26\u5339\u914d 72. \u7f16\u8f91\u8ddd\u79bb \u5176\u4ed6 \ud83e\uddd0 120. \u4e09\u89d2\u5f62\u6700\u5c0f\u8def\u5f84\u548c (\u7ecf\u5178\u95ee\u9898) 139. \u5355\u8bcd\u62c6\u5206 (dp + trie) 140. \u5355\u8bcd\u62c6\u5206 ii (dp + trie) \uff1f\uff1f\uff1f \ud83e\uddd0 576. \u51fa\u754c\u7684\u8def\u5f84\u6570 (\u5751\u591a) \u8d2a\u5fc3 \ud83e\uddd0 621. \u4efb\u52a1\u8c03\u5ea6 55. \u8df3\u8dc3\u6e38\u620f 45. \u8df3\u8dc3\u6e38\u620f ii 670. \u6700\u5927\u4ea4\u6362 (\u8d2a\u5fc3 + \u7a7a\u95f4\u6362\u65f6\u95f4) \u4e0d\u77e5\u9053\u662f\u5565 \ud83e\uddd0 600. \u4e0d\u542b\u8fde\u7eed 1 \u7684\u975e\u8d1f\u6574\u6570 96. \u4e0d\u540c\u7684\u4e8c\u53c9\u641c\u7d22\u6811 (DP/Catalan \u6570)","title":"linear"},{"location":"_problems/_dp/linear/#_1","text":"\u7ecf\u5178\u5355\u4e32 300. LIS (\u7ecf\u5178\u5355\u4e32) 53. \u6700\u5927\u5b50\u5e8f\u548c (\u7ecf\u5178\u5355\u4e32) 152. \u4e58\u79ef\u6700\u5927\u5b50\u6570\u7ec4 (\u6700\u5927\u5b50\u5e8f\u548c\u53d8\u4f53) 91. \u89e3\u7801\u65b9\u6cd5 \u7b49\u5dee\u7cfb\u5217 413. \u7b49\u5dee\u6570\u5217\u5212\u5206 (\u4e00\u6b21\u904d\u5386\uff0c\u627e\u5230\u7b49\u5dee\u5b50\u5e8f\u5217\u6570\u76ee\uff0c\u975e dp\uff0c\u7528\u505a\u5bf9\u6bd4) 446. \u7b49\u5dee\u6570\u5217\u5212\u5206 ii (\u6c42\u7b49\u5dee\u5b50\u5e8f\u5217\u6570\u76ee\uff0c\u7ed3\u5408\u516c\u5dee\u7684\u4e00\u7ef4 dp) 1027. \u6700\u957f\u7b49\u5dee\u6570\u5217 (\u548c 446. \u7b49\u5dee\u6570\u5217\u5212\u5206 \u7c7b\u4f3c) \u80a1\u7968\u7cfb\u5217 121. \u4e70\u5356\u80a1\u7968\u7684\u6700\u4f73\u65f6\u673a 122. \u4e70\u5356\u80a1\u7968\u7684\u6700\u4f73\u65f6\u673a II 123. \u4e70\u5356\u80a1\u7968\u7684\u6700\u4f73\u65f6\u673a III 188. \u4e70\u5356\u80a1\u7968\u7684\u6700\u4f73\u65f6\u673a IV 309. \u6700\u4f73\u4e70\u5356\u80a1\u7968\u65f6\u673a\u542b\u51b7\u51bb\u671f 714. \u4e70\u5356\u80a1\u7968\u7684\u6700\u4f73\u65f6\u673a\u542b\u624b\u7eed\u8d39 \u6253\u5bb6\u52ab\u820d\u7cfb\u5217 198. \u6253\u5bb6\u52ab\u820d 213. \u6253\u5bb6\u52ab\u820d 2","title":"\u5355\u4e32"},{"location":"_problems/_dp/linear/#_2","text":"\u5b57\u7b26\u4e32\u5339\u914d 10. \u6b63\u5219\u8868\u8fbe\u5f0f\u5339\u914d 44. \u901a\u914d\u7b26\u5339\u914d 72. \u7f16\u8f91\u8ddd\u79bb","title":"\u53cc\u4e32"},{"location":"_problems/_dp/linear/#_3","text":"120. \u4e09\u89d2\u5f62\u6700\u5c0f\u8def\u5f84\u548c (\u7ecf\u5178\u95ee\u9898) 139. \u5355\u8bcd\u62c6\u5206 (dp + trie) 140. \u5355\u8bcd\u62c6\u5206 ii (dp + trie)","title":"\u5176\u4ed6"},{"location":"_problems/_dp/linear/#_4","text":"576. \u51fa\u754c\u7684\u8def\u5f84\u6570 (\u5751\u591a)","title":"\uff1f\uff1f\uff1f"},{"location":"_problems/_dp/linear/#_5","text":"621. \u4efb\u52a1\u8c03\u5ea6 55. \u8df3\u8dc3\u6e38\u620f 45. \u8df3\u8dc3\u6e38\u620f ii 670. \u6700\u5927\u4ea4\u6362 (\u8d2a\u5fc3 + \u7a7a\u95f4\u6362\u65f6\u95f4)","title":"\u8d2a\u5fc3"},{"location":"_problems/_dp/linear/#_6","text":"600. \u4e0d\u542b\u8fde\u7eed 1 \u7684\u975e\u8d1f\u6574\u6570 96. \u4e0d\u540c\u7684\u4e8c\u53c9\u641c\u7d22\u6811 (DP/Catalan \u6570)","title":"\u4e0d\u77e5\u9053\u662f\u5565"},{"location":"_problems/_dp/pack/","text":"1. 01 \u80cc\u5305 \ud83e\uddd0 (1). \u57fa\u672c\u601d\u8def \ud83e\uddd0 \u7ed9\u5b9a $n$ \u79cd\u7269\u54c1\u548c\u4e00\u4e2a\u80cc\u5305\uff0c\u7269\u54c1 $n_i$ \u7684\u91cd\u91cf\u4e3a $w_i$\uff0c\u4ef7\u503c\u4e3a $v_i$\uff0c\u80cc\u5305\u5bb9\u91cf\u4e3a $C$\uff0c\u5982\u4f55\u9009\u62e9\u80cc\u5305\u4e2d\u7684\u7269\u54c1\uff0c\u4f7f\u603b\u4ef7\u503c\u6700\u5927\u3002\u8be5\u95ee\u9898\u53ef\u5f62\u5f0f\u5316\u4e3a: $$ \\mathrm{Input:}\\ W,\\ V, \\ C,\\ i, \\enspace \\mathrm{Output:}\\ \\lbrace x_0, ..., x_{n-1}\\rbrace \\\\ s.t. \\max\\sum_0^{n-1} v_i x_i,\\ \\sum_0^{n-1} w_i x_i < C,\\ x_i \\in \\lbrace 0,1 \\rbrace $$ \u8be5\u95ee\u9898\u7684\u7ed3\u6784\u7279\u5f81\u7531 $i,C$ \u63cf\u8ff0\uff0c$dp(i,C)$ \u8868\u793a\u53ef\u9009\u7269\u54c1\u662f $x_0$ \u5230 $x_i$ \u65f6\u7684\u4ef7\u503c\uff0c\u5219 $\\lbrace x_0, ..., x_{i-1} \\rbrace$ \u4e00\u5b9a\u662f $dp(i-1, C-x_{i}w_{i})$ \u7684\u6700\u4f18\u89e3\uff0c\u95ee\u9898\u53ea\u5728\u4e8e\u7b2c $i$ \u4ef6\u7269\u54c1\u653e\u4e0e\u4e0d\u653e\uff0c\u56e0\u6b64 0-1 \u80cc\u5305\u7684\u8f6c\u79fb\u65b9\u7a0b\u4e3a $$ dp(i, C) = \\max \\lbrace \\ dp(i-1, C),\\enspace dp(i-1, C-w_i)+v_i \\ \\rbrace $$ \u521d\u59cb\u5316: \u2002 $dp[0][0...w_0] = 0,\\enspace dp[0][w_0 ... C]=v_0$ (2). \u7a7a\u95f4\u4f18\u5316 \ud83e\uddd0 \u7531\u4e8e $dp(i, C)$ \u53ea\u6d89\u53ca $dp(i-1, C)$ \u548c $dp(i-1, C-w)$ \u4e24\u4e2a\u72b6\u6001\uff0c\u7a7a\u95f4\u4e0a\u53ea\u9700\u8981\u9006\u5411\u904d\u5386\u4e00\u4e2a\u4e00\u7ef4\u6570\u7ec4 2. \u5b8c\u5168\u80cc\u5305 \ud83e\uddd0 \u548c 01 \u80cc\u5305\u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\uff0c\u6bcf\u79cd\u7269\u54c1\u6709\u65e0\u9650\u4e2a\uff0c\u5373 $x_i \\in \\lbrace {0, 1, ..., \\lfloor C/w_i \\rfloor } \\rbrace$ (1). \u57fa\u672c\u601d\u8def \ud83e\uddd0 \u6309\u7167\u6700\u57fa\u672c\u7684\u60f3\u6cd5\uff0c\u6bcf\u4e00\u6b65\u8003\u8651 $x_i$ \u7684\u6240\u6709\u53d6\u503c\u60c5\u51b5\uff0c\u53ef\u5f97: $$ dp(i, C) = \\max \\lbrace \\ dp(i-1, C-kw_i) + kv_i \\ | \\ 0 \\leq kw_i \\leq C \\ \\rbrace $$ \u6c42\u89e3\u6bcf\u4e2a\u72b6\u6001\u7684\u590d\u6742\u5ea6\u4e0d\u518d\u662f\u5e38\u6570\uff0c\u603b\u590d\u6742\u5ea6\u96be\u4ee5\u63a5\u53d7 (2). \u8fdb\u9636\u601d\u8def \ud83e\uddd0 \u5982\u679c\u5728\u72b6\u6001\u9012\u63a8\u65f6\u8003\u8651\u300c\u6dfb\u52a0\u4e00\u4e2a \u6216 \u4e0d\u6dfb\u52a0\u7269\u54c1 $n_i$\u300d\uff0c\u800c\u4e0d\u662f\u300c\u7269\u54c1 $n_i$ \u6dfb\u52a0\u51e0\u4e2a\u300d\uff0c\u53ef\u5f97 $$ dp(i, C) = \\max \\ \\lbrace \\ dp(i-1, C),\\ dp(i, C-w_i)+v_i \\ \\rbrace $$ \u548c 01 \u80cc\u5305\u7684\u72b6\u6001\u65b9\u7a0b\u4e0d\u540c\u5904\u5728\u4e8e\u5411 $dp(i, C-w_i)$ \u9012\u63a8\uff0c\u8868\u793a $n_i$ \u6dfb\u52a0\u4e00\u4e2a\u3002\u9700\u8981\u6ce8\u610f\uff1a $dp[0][0...C]$ \u521d\u59cb\u5316\u540e\u4f9d\u7136\u9700\u8981\u72b6\u6001\u9012\u63a8 \u4f7f\u7528\u4e00\u7ef4\u6570\u7ec4\u7a7a\u95f4\u4f18\u5316\u65f6\u53ea\u80fd\u6b63\u5411\u904d\u5386 (3). \u8f6c\u6362\u4e3a 0-1 \u80cc\u5305 \ud83e\uddd0 \u601d\u8def\u4e3a\u628a\u4e00\u4e2a\u7269\u54c1\u62c6\u5206\u6210\u591a\u4e2a\uff0c\u6bcf\u4e2a\u7269\u54c1\u5728 $\\lbrace 0,1 \\rbrace$ \u4e2d\u53d6\u503c\u3002\u5982\u679c\u628a\u7b2c $i$ \u79cd\u7269\u54c1\u8f6c\u5316\u4e3a $\\lfloor C/w_i \\rfloor$ \u4e2a\u4ef7\u503c\u4e0d\u53d8\u7684\u7269\u54c1\uff0c\u590d\u6742\u5ea6\u76f8\u8f83\u57fa\u672c\u601d\u8def\u5e76\u6ca1\u6709\u6539\u53d8\u3002\u66f4\u9ad8\u6548\u7684\u62c6\u5206\u65b9\u5f0f\u4e3a: $$ n_i(w_i, v_i) \\Longrightarrow \\lbrace\\ n_{ik}(w_i2^k, v_i2^k) \\ |\\ k\\in N \\mathrm{\\ and\\ } w_i2^k < C \\ \\rbrace $$ \u8fd9\u91cc\u7528\u5230\u4e86\u4e8c\u8fdb\u5236\u7684\u601d\u60f3: \u4e0d\u7ba1\u4e00\u4e2a\u7269\u54c1\u53d6\u51e0\u4ef6\uff0c\u4e00\u5b9a\u53ef\u4ee5\u8868\u793a\u4e3a $2^k$ \u7684\u548c\u3002\u8fd9\u6837\u5c31\u628a\u4e00\u79cd\u7269\u54c1\u62c6\u5206\u4e3a $O(\\log (\\lfloor C/w_i \\rfloor ))$ \u4e2a\u7269\u54c1 \u9644: \u95ee\u6cd5\u7684\u53d8\u5316 \ud83e\uddd0 (1). \u6070\u597d\u88c5\u6ee1 \ud83e\uddd0 \u7531\u72b6\u6001\u65b9\u7a0b\u53ef\u77e5\uff0c\u88c5\u6ee1\u4e0e\u5426\u7684\u533a\u522b\u53ea\u5728\u4e8e\u521d\u59cb\u5316: \u5982\u679c\u6ca1\u6709\u6070\u597d\u88c5\u6ee1\u7684\u9650\u5236\uff0c\u53ea\u9700\u5c06 $dp[0][0...w_0]$ \u5168\u521d\u59cb\u5316\u4e3a 0 \u5373\u53ef \u5982\u679c\u9650\u5236\u6070\u597d\u88c5\u6ee1\uff0c$dp[0][0]$ \u521d\u59cb\u5316\u4e3a 0\uff0c\u8868\u793a\u5bb9\u91cf\u4e3a 0 \u4e14\u4ef7\u503c\u4e3a 0\uff0c\u5728\u6070\u597d\u88c5\u6ee1\u7684\u9650\u5236\u4e0b\u662f\u4e00\u4e2a\u5408\u6cd5\u89e3\uff1b$dp[0][w_0]$ \u521d\u59cb\u5316\u4e3a $v_0$\uff1b\u5176\u4f59\u72b6\u6001\u5168\u90e8\u521d\u59cb\u5316\u4e3a $-\\infty$\uff0c\u8868\u793a\u672a\u5b9a\u4e49 (2). \u6c42\u65b9\u6848\u603b\u6570 \ud83e\uddd0 \u7531\u4e8e\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5df2\u7ecf\u8003\u5bdf\u4e86\u6240\u6709\u53ef\u80fd\u7684\u65b9\u6848\uff0c\u53ea\u9700\u7b80\u5355\u4fee\u6539\u4e00\u4e0b\u5373\u53ef $$ dp(i, C) = \\mathrm{sum} \\lbrace \\ dp(i-1, C),\\enspace dp(i-1, C-w_i)\\ \\rbrace $$ \u5176\u4e2d $dp(0, 0)=1$\u3002\u5982\u679c\u9700\u8981\u6c42\u6700\u4f18\u65b9\u6848\u603b\u6570\uff0c\u5219\u9700\u8981\u65b0\u5f00\u4e00\u4e2a\u72b6\u6001\u65b9\u7a0b\u7684\u6570\u7ec4\u3002 (3). \u4e8c\u7ef4\u80cc\u5305 \ud83e\uddd0 \u4e8c\u7ef4\u80cc\u5305\u662f\u6307\u6bcf\u4e2a\u80cc\u5305\u6709\u4e24\u4e2a\u9650\u5236\u6761\u4ef6 (\u4f8b\u5982\u91cd\u91cf\u548c\u4f53\u79ef)\uff0c\u9009\u62e9\u7269\u54c1\u5fc5\u987b\u8981\u6ee1\u8db3\u4e24\u4e2a\u6761\u4ef6\uff0c\u53ea\u9700\u8981\u5728\u72b6\u6001\u6570\u7ec4\u4e0a\u52a0\u4e00\u7ef4\u5373\u53ef\u3002 \u76f8\u5173\u95ee\u9898 \ud83e\uddd0 416. Partition Equal Subset Sum (01 \u80cc\u5305) 474. Ones and Zeroes (\u4e8c\u7ef4 01 \u80cc\u5305) 494. target sum (\u7c7b\u4f3c 01 \u80cc\u5305) 322. Coin Change (\u5b8c\u5168\u80cc\u5305 + \u6070\u597d\u88c5\u6ee1 + \u6700\u5c0f\u4ef7\u503c) 518. Coin Change 2 (\u5b8c\u5168\u80cc\u5305 + \u6c42\u65b9\u6848\u6570 + \u6070\u597d\u88c5\u6ee1)","title":"pack"},{"location":"_problems/_dp/pack/#1-01","text":"","title":"1. 01 \u80cc\u5305"},{"location":"_problems/_dp/pack/#1","text":"\u7ed9\u5b9a $n$ \u79cd\u7269\u54c1\u548c\u4e00\u4e2a\u80cc\u5305\uff0c\u7269\u54c1 $n_i$ \u7684\u91cd\u91cf\u4e3a $w_i$\uff0c\u4ef7\u503c\u4e3a $v_i$\uff0c\u80cc\u5305\u5bb9\u91cf\u4e3a $C$\uff0c\u5982\u4f55\u9009\u62e9\u80cc\u5305\u4e2d\u7684\u7269\u54c1\uff0c\u4f7f\u603b\u4ef7\u503c\u6700\u5927\u3002\u8be5\u95ee\u9898\u53ef\u5f62\u5f0f\u5316\u4e3a: $$ \\mathrm{Input:}\\ W,\\ V, \\ C,\\ i, \\enspace \\mathrm{Output:}\\ \\lbrace x_0, ..., x_{n-1}\\rbrace \\\\ s.t. \\max\\sum_0^{n-1} v_i x_i,\\ \\sum_0^{n-1} w_i x_i < C,\\ x_i \\in \\lbrace 0,1 \\rbrace $$ \u8be5\u95ee\u9898\u7684\u7ed3\u6784\u7279\u5f81\u7531 $i,C$ \u63cf\u8ff0\uff0c$dp(i,C)$ \u8868\u793a\u53ef\u9009\u7269\u54c1\u662f $x_0$ \u5230 $x_i$ \u65f6\u7684\u4ef7\u503c\uff0c\u5219 $\\lbrace x_0, ..., x_{i-1} \\rbrace$ \u4e00\u5b9a\u662f $dp(i-1, C-x_{i}w_{i})$ \u7684\u6700\u4f18\u89e3\uff0c\u95ee\u9898\u53ea\u5728\u4e8e\u7b2c $i$ \u4ef6\u7269\u54c1\u653e\u4e0e\u4e0d\u653e\uff0c\u56e0\u6b64 0-1 \u80cc\u5305\u7684\u8f6c\u79fb\u65b9\u7a0b\u4e3a $$ dp(i, C) = \\max \\lbrace \\ dp(i-1, C),\\enspace dp(i-1, C-w_i)+v_i \\ \\rbrace $$ \u521d\u59cb\u5316: \u2002 $dp[0][0...w_0] = 0,\\enspace dp[0][w_0 ... C]=v_0$","title":"(1). \u57fa\u672c\u601d\u8def"},{"location":"_problems/_dp/pack/#2","text":"\u7531\u4e8e $dp(i, C)$ \u53ea\u6d89\u53ca $dp(i-1, C)$ \u548c $dp(i-1, C-w)$ \u4e24\u4e2a\u72b6\u6001\uff0c\u7a7a\u95f4\u4e0a\u53ea\u9700\u8981\u9006\u5411\u904d\u5386\u4e00\u4e2a\u4e00\u7ef4\u6570\u7ec4","title":"(2). \u7a7a\u95f4\u4f18\u5316"},{"location":"_problems/_dp/pack/#2_1","text":"\u548c 01 \u80cc\u5305\u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\uff0c\u6bcf\u79cd\u7269\u54c1\u6709\u65e0\u9650\u4e2a\uff0c\u5373 $x_i \\in \\lbrace {0, 1, ..., \\lfloor C/w_i \\rfloor } \\rbrace$","title":"2. \u5b8c\u5168\u80cc\u5305"},{"location":"_problems/_dp/pack/#1_1","text":"\u6309\u7167\u6700\u57fa\u672c\u7684\u60f3\u6cd5\uff0c\u6bcf\u4e00\u6b65\u8003\u8651 $x_i$ \u7684\u6240\u6709\u53d6\u503c\u60c5\u51b5\uff0c\u53ef\u5f97: $$ dp(i, C) = \\max \\lbrace \\ dp(i-1, C-kw_i) + kv_i \\ | \\ 0 \\leq kw_i \\leq C \\ \\rbrace $$ \u6c42\u89e3\u6bcf\u4e2a\u72b6\u6001\u7684\u590d\u6742\u5ea6\u4e0d\u518d\u662f\u5e38\u6570\uff0c\u603b\u590d\u6742\u5ea6\u96be\u4ee5\u63a5\u53d7","title":"(1). \u57fa\u672c\u601d\u8def"},{"location":"_problems/_dp/pack/#2_2","text":"\u5982\u679c\u5728\u72b6\u6001\u9012\u63a8\u65f6\u8003\u8651\u300c\u6dfb\u52a0\u4e00\u4e2a \u6216 \u4e0d\u6dfb\u52a0\u7269\u54c1 $n_i$\u300d\uff0c\u800c\u4e0d\u662f\u300c\u7269\u54c1 $n_i$ \u6dfb\u52a0\u51e0\u4e2a\u300d\uff0c\u53ef\u5f97 $$ dp(i, C) = \\max \\ \\lbrace \\ dp(i-1, C),\\ dp(i, C-w_i)+v_i \\ \\rbrace $$ \u548c 01 \u80cc\u5305\u7684\u72b6\u6001\u65b9\u7a0b\u4e0d\u540c\u5904\u5728\u4e8e\u5411 $dp(i, C-w_i)$ \u9012\u63a8\uff0c\u8868\u793a $n_i$ \u6dfb\u52a0\u4e00\u4e2a\u3002\u9700\u8981\u6ce8\u610f\uff1a $dp[0][0...C]$ \u521d\u59cb\u5316\u540e\u4f9d\u7136\u9700\u8981\u72b6\u6001\u9012\u63a8 \u4f7f\u7528\u4e00\u7ef4\u6570\u7ec4\u7a7a\u95f4\u4f18\u5316\u65f6\u53ea\u80fd\u6b63\u5411\u904d\u5386","title":"(2). \u8fdb\u9636\u601d\u8def"},{"location":"_problems/_dp/pack/#3-0-1","text":"\u601d\u8def\u4e3a\u628a\u4e00\u4e2a\u7269\u54c1\u62c6\u5206\u6210\u591a\u4e2a\uff0c\u6bcf\u4e2a\u7269\u54c1\u5728 $\\lbrace 0,1 \\rbrace$ \u4e2d\u53d6\u503c\u3002\u5982\u679c\u628a\u7b2c $i$ \u79cd\u7269\u54c1\u8f6c\u5316\u4e3a $\\lfloor C/w_i \\rfloor$ \u4e2a\u4ef7\u503c\u4e0d\u53d8\u7684\u7269\u54c1\uff0c\u590d\u6742\u5ea6\u76f8\u8f83\u57fa\u672c\u601d\u8def\u5e76\u6ca1\u6709\u6539\u53d8\u3002\u66f4\u9ad8\u6548\u7684\u62c6\u5206\u65b9\u5f0f\u4e3a: $$ n_i(w_i, v_i) \\Longrightarrow \\lbrace\\ n_{ik}(w_i2^k, v_i2^k) \\ |\\ k\\in N \\mathrm{\\ and\\ } w_i2^k < C \\ \\rbrace $$ \u8fd9\u91cc\u7528\u5230\u4e86\u4e8c\u8fdb\u5236\u7684\u601d\u60f3: \u4e0d\u7ba1\u4e00\u4e2a\u7269\u54c1\u53d6\u51e0\u4ef6\uff0c\u4e00\u5b9a\u53ef\u4ee5\u8868\u793a\u4e3a $2^k$ \u7684\u548c\u3002\u8fd9\u6837\u5c31\u628a\u4e00\u79cd\u7269\u54c1\u62c6\u5206\u4e3a $O(\\log (\\lfloor C/w_i \\rfloor ))$ \u4e2a\u7269\u54c1","title":"(3). \u8f6c\u6362\u4e3a 0-1 \u80cc\u5305"},{"location":"_problems/_dp/pack/#_1","text":"","title":"\u9644: \u95ee\u6cd5\u7684\u53d8\u5316"},{"location":"_problems/_dp/pack/#1_2","text":"\u7531\u72b6\u6001\u65b9\u7a0b\u53ef\u77e5\uff0c\u88c5\u6ee1\u4e0e\u5426\u7684\u533a\u522b\u53ea\u5728\u4e8e\u521d\u59cb\u5316: \u5982\u679c\u6ca1\u6709\u6070\u597d\u88c5\u6ee1\u7684\u9650\u5236\uff0c\u53ea\u9700\u5c06 $dp[0][0...w_0]$ \u5168\u521d\u59cb\u5316\u4e3a 0 \u5373\u53ef \u5982\u679c\u9650\u5236\u6070\u597d\u88c5\u6ee1\uff0c$dp[0][0]$ \u521d\u59cb\u5316\u4e3a 0\uff0c\u8868\u793a\u5bb9\u91cf\u4e3a 0 \u4e14\u4ef7\u503c\u4e3a 0\uff0c\u5728\u6070\u597d\u88c5\u6ee1\u7684\u9650\u5236\u4e0b\u662f\u4e00\u4e2a\u5408\u6cd5\u89e3\uff1b$dp[0][w_0]$ \u521d\u59cb\u5316\u4e3a $v_0$\uff1b\u5176\u4f59\u72b6\u6001\u5168\u90e8\u521d\u59cb\u5316\u4e3a $-\\infty$\uff0c\u8868\u793a\u672a\u5b9a\u4e49","title":"(1). \u6070\u597d\u88c5\u6ee1"},{"location":"_problems/_dp/pack/#2_3","text":"\u7531\u4e8e\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5df2\u7ecf\u8003\u5bdf\u4e86\u6240\u6709\u53ef\u80fd\u7684\u65b9\u6848\uff0c\u53ea\u9700\u7b80\u5355\u4fee\u6539\u4e00\u4e0b\u5373\u53ef $$ dp(i, C) = \\mathrm{sum} \\lbrace \\ dp(i-1, C),\\enspace dp(i-1, C-w_i)\\ \\rbrace $$ \u5176\u4e2d $dp(0, 0)=1$\u3002\u5982\u679c\u9700\u8981\u6c42\u6700\u4f18\u65b9\u6848\u603b\u6570\uff0c\u5219\u9700\u8981\u65b0\u5f00\u4e00\u4e2a\u72b6\u6001\u65b9\u7a0b\u7684\u6570\u7ec4\u3002","title":"(2). \u6c42\u65b9\u6848\u603b\u6570"},{"location":"_problems/_dp/pack/#3","text":"\u4e8c\u7ef4\u80cc\u5305\u662f\u6307\u6bcf\u4e2a\u80cc\u5305\u6709\u4e24\u4e2a\u9650\u5236\u6761\u4ef6 (\u4f8b\u5982\u91cd\u91cf\u548c\u4f53\u79ef)\uff0c\u9009\u62e9\u7269\u54c1\u5fc5\u987b\u8981\u6ee1\u8db3\u4e24\u4e2a\u6761\u4ef6\uff0c\u53ea\u9700\u8981\u5728\u72b6\u6001\u6570\u7ec4\u4e0a\u52a0\u4e00\u7ef4\u5373\u53ef\u3002","title":"(3). \u4e8c\u7ef4\u80cc\u5305"},{"location":"_problems/_dp/pack/#_2","text":"416. Partition Equal Subset Sum (01 \u80cc\u5305) 474. Ones and Zeroes (\u4e8c\u7ef4 01 \u80cc\u5305) 494. target sum (\u7c7b\u4f3c 01 \u80cc\u5305) 322. Coin Change (\u5b8c\u5168\u80cc\u5305 + \u6070\u597d\u88c5\u6ee1 + \u6700\u5c0f\u4ef7\u503c) 518. Coin Change 2 (\u5b8c\u5168\u80cc\u5305 + \u6c42\u65b9\u6848\u6570 + \u6070\u597d\u88c5\u6ee1)","title":"\u76f8\u5173\u95ee\u9898"},{"location":"_problems/_hashmap/hashmap/","text":"hashmap \u6362\u65f6\u95f4: 1. \u4e24\u6570\u4e4b\u548c (\u7ecf\u5178 hashmap \u6362\u65f6\u95f4) 167. \u4e24\u6570\u4e4b\u548c 2 (\u6392\u5e8f\u6570\u7ec4\u53cc\u6307\u9488) 15. \u4e09\u6570\u4e4b\u548c (\u5347\u7ea7\u7248\u4e24\u6570\u4e4b\u548c) 16. \u6700\u63a5\u8fd1\u7684\u4e09\u6570\u4e4b\u548c (\u7ea6\u7b49\u4e8e\u4e09\u6570\u4e4b\u548c) 560. \u548c\u4e3a k \u7684\u5b50\u6570\u7ec4 (\u5f15\u5165\u524d\u7f00\u548c\uff0c\u7136\u540e hashmap \u6362\u65f6\u95f4) 447. \u56de\u65cb\u9556\u7684\u6570\u91cf \u53cc\u6307\u9488 27. \u79fb\u9664\u5143\u7d20 (\u7ecf\u5178\u53cc\u6307\u9488) 633. \u5e73\u65b9\u6570\u4e4b\u548c (\u7ecf\u5178\u53cc\u6307\u9488) 42. \u63a5\u96e8\u6c34 (\u5355\u8c03\u6808/dp+\u53cc\u6307\u9488) 84. \u67f1\u72b6\u56fe\u4e2d\u7684\u6700\u5927\u77e9\u5f62 (\u679a\u4e3e -> \u5178\u578b\u5355\u8c03\u6808) 85. \u6700\u5927\u77e9\u5f62 (\u679a\u4e3e -> \u5355\u8c03\u6808) 503. \u4e0b\u4e00\u4e2a\u66f4\u5927\u5143\u7d20 II (\u5355\u8c03\u6808) 239. \u6ed1\u52a8\u7a97\u53e3\u6700\u5927\u503c (\u5355\u8c03\u6808) \u6ed1\u52a8\u7a97\u53e3 209. \u957f\u5ea6\u6700\u5c0f\u7684\u5b50\u6570\u7ec4 (\u524d\u7f00\u548c+\u4e8c\u5206 / \u6ed1\u52a8\u7a97\u53e3) 1894. \u627e\u5230\u9700\u8981\u8865\u5145\u7c89\u7b14\u7684\u5b66\u751f\u7f16\u53f7 (\u524d\u7f00\u548c + \u4e8c\u5206) 155. \u6700\u5c0f\u6808 (\u8bb0\u5f55\u6808\u72b6\u6001) 852. \u5c71\u8109\u6570\u7ec4\u7684\u5cf0\u9876\u7d22\u5f15 (\u5178\u578b\u4e8c\u5206) 162. \u5bfb\u627e\u5cf0\u503c (\u4e8c\u5206) 34. \u5728\u6392\u5e8f\u6570\u7ec4\u4e2d\u67e5\u627e\u5143\u7d20\u7684\u7b2c\u4e00\u4e2a\u548c\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e (\u4e8c\u5206) 410. \u5206\u5272\u6570\u7ec4\u7684\u6700\u5927\u503c (dp / \u4e8c\u5206) 875. \u7231\u5403\u9999\u8549\u7684\u73c2\u73c2 \u94fe\u8868 876. \u94fe\u8868\u7684\u4e2d\u95f4\u7ed3\u70b9 (\u5feb\u6162\u6307\u9488) 143. \u91cd\u6392\u94fe\u8868 (\u4e2d\u70b9 + \u9006\u5e8f + \u5408\u5e76) 138. \u590d\u5236\u5e26\u968f\u673a\u6307\u9488\u7684\u94fe\u8868 86. \u5206\u9694\u94fe\u8868 (\u7b80\u5355\u6a21\u62df) \u666e\u901a\u6808: 394. \u5b57\u7b26\u4e32\u89e3\u7801 (\u6808\u6a21\u62df\u9012\u5f52)","title":"HashMap"},{"location":"_problems/_leetcode/1/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \u548c\u4e00\u4e2a\u6574\u6570\u76ee\u6807\u503c target \uff0c\u8bf7\u4f60\u5728\u8be5\u6570\u7ec4\u4e2d\u627e\u51fa \u548c\u4e3a\u76ee\u6807\u503c target \u7684\u90a3\u4e24\u4e2a\u6574\u6570\uff0c\u5e76\u8fd4\u56de\u5b83\u4eec\u7684\u6570\u7ec4\u4e0b\u6807 \u53ef\u4ee5\u5047\u8bbe\u6bcf\u79cd\u8f93\u5165\u53ea\u4f1a\u5bf9\u5e94\u4e00\u4e2a\u7b54\u6848\uff0c\u4f46\u8981\u6ce8\u610f\u6570\u7ec4\u4e2d\u540c\u4e00\u4e2a\u5143\u7d20\u5728\u7b54\u6848\u91cc\u4e0d\u80fd\u91cd\u590d\u51fa\u73b0\u3002 Example: \u8f93\u5165\uff1anums = [3,3], target = 6 \u8f93\u51fa\uff1a[0,1] Note: 2 <= nums.length <= 10^4 -10^9 <= nums[i], target <= 10^9 \u53ea\u4f1a\u5b58\u5728\u4e00\u4e2a\u6709\u6548\u7b54\u6848 (Easy) \u5178\u578b\u7684 hashmap \u6362\u65f6\u95f4 solution class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { unordered_map < int , int > numMap ; for ( int i = 0 ; i < nums . size (); ++ i ) { auto it = numMap . find ( target - nums [ i ]); if ( it != numMap . end ()) return { it -> second , i }; numMap [ nums [ i ]] = i ; } return {}; } };","title":"1. two sum"},{"location":"_problems/_leetcode/101/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u53c9\u6811\uff0c\u68c0\u67e5\u5b83\u662f\u5426\u662f\u955c\u50cf\u5bf9\u79f0\u7684 Example1: 1 / \\ 2 2 / \\ / \\ 3 4 4 3 true Example2: 1 / \\ 2 2 \\ \\ 3 3 false Note: 1 <= number of nodes <= 1000 -100 <= node.val <= 100 (Easy) \u9012\u5f52 \ud83e\uddd0 \u4e24\u68f5\u6811\u5bf9\u79f0: \u6839\u7ed3\u70b9\u76f8\u7b49 && \u5de6\u53f3\u5b50\u6811\u5bf9\u79f0 solution class Solution { public : bool isSymmetric ( TreeNode * root ) { return areSymmetric ( root -> left , root -> right ); } bool areSymmetric ( TreeNode * r1 , TreeNode * r2 ) { if ( r1 == nullptr || r2 == nullptr ) return r1 == r2 ; return r1 -> val == r2 -> val && areSymmetric ( r1 -> left , r2 -> right ) && areSymmetric ( r1 -> right , r2 -> left ); } }; \u8fed\u4ee3 \ud83e\uddd0 \u540c\u65f6\u904d\u5386\u4e24\u68f5\u6811\uff0c\u663e\u7136\u5c42\u5e8f\u904d\u5386\u66f4\u597d\u5199\u3002 solution \u540c\u65f6\u5c42\u5e8f class Solution { public : bool isSymmetric ( TreeNode * root ) { return areSymmetric ( root -> left , root -> right ); } bool areSymmetric ( TreeNode * u , TreeNode * v ) { queue < TreeNode *> queue ; queue . push ( u ); queue . push ( v ); while ( ! queue . empty ()) { TreeNode * nodeLeft = queue . front (); queue . pop (); TreeNode * nodeRight = queue . front (); queue . pop (); if ( ! nodeLeft && ! nodeRight ) continue ; if (( ! nodeLeft || ! nodeRight ) || ( nodeLeft -> val != nodeRight -> val )) return false ; queue . push ( nodeLeft -> left ); queue . push ( nodeRight -> right ); queue . push ( nodeLeft -> right ); queue . push ( nodeRight -> left ); } return true ; } }; \u540c\u65f6\u524d\u4e2d\u5e8f class Solution { public : bool isSymmetric ( TreeNode * root ) { return areSymmetric ( root -> left , root -> right ); } bool areSymmetric ( TreeNode * nodeOrg , TreeNode * nodeSym ) { if ( ! isEqual ( nodeOrg , nodeSym )) return false ; stack < TreeNode *> stackOrg ; stack < TreeNode *> stackSym ; while ( ! stackOrg . empty () || nodeOrg != nullptr ) { while ( nodeOrg || nodeSym ) { if ( ! isEqual ( nodeOrg , nodeSym )) return false ; stackOrg . push ( nodeOrg ); stackSym . push ( nodeSym ); nodeOrg = nodeOrg -> left ; nodeSym = nodeSym -> right ; } while ( ! stackOrg . empty () && nodeOrg == nullptr && nodeSym == nullptr ) { nodeOrg = stackOrg . top () -> right ; nodeSym = stackSym . top () -> left ; if ( ! isEqual ( nodeOrg , nodeSym )) return false ; stackOrg . pop (); stackSym . pop (); } } return true ; } bool isEqual ( TreeNode * node1 , TreeNode * node2 ) { if ( ! node1 || ! node2 ) return node1 == node2 ; return node1 -> val == node2 -> val ; } };","title":"101. symmetric tree"},{"location":"_problems/_leetcode/101/#_1","text":"\u4e24\u68f5\u6811\u5bf9\u79f0: \u6839\u7ed3\u70b9\u76f8\u7b49 && \u5de6\u53f3\u5b50\u6811\u5bf9\u79f0 solution class Solution { public : bool isSymmetric ( TreeNode * root ) { return areSymmetric ( root -> left , root -> right ); } bool areSymmetric ( TreeNode * r1 , TreeNode * r2 ) { if ( r1 == nullptr || r2 == nullptr ) return r1 == r2 ; return r1 -> val == r2 -> val && areSymmetric ( r1 -> left , r2 -> right ) && areSymmetric ( r1 -> right , r2 -> left ); } };","title":"\u9012\u5f52"},{"location":"_problems/_leetcode/101/#_2","text":"\u540c\u65f6\u904d\u5386\u4e24\u68f5\u6811\uff0c\u663e\u7136\u5c42\u5e8f\u904d\u5386\u66f4\u597d\u5199\u3002 solution \u540c\u65f6\u5c42\u5e8f class Solution { public : bool isSymmetric ( TreeNode * root ) { return areSymmetric ( root -> left , root -> right ); } bool areSymmetric ( TreeNode * u , TreeNode * v ) { queue < TreeNode *> queue ; queue . push ( u ); queue . push ( v ); while ( ! queue . empty ()) { TreeNode * nodeLeft = queue . front (); queue . pop (); TreeNode * nodeRight = queue . front (); queue . pop (); if ( ! nodeLeft && ! nodeRight ) continue ; if (( ! nodeLeft || ! nodeRight ) || ( nodeLeft -> val != nodeRight -> val )) return false ; queue . push ( nodeLeft -> left ); queue . push ( nodeRight -> right ); queue . push ( nodeLeft -> right ); queue . push ( nodeRight -> left ); } return true ; } }; \u540c\u65f6\u524d\u4e2d\u5e8f class Solution { public : bool isSymmetric ( TreeNode * root ) { return areSymmetric ( root -> left , root -> right ); } bool areSymmetric ( TreeNode * nodeOrg , TreeNode * nodeSym ) { if ( ! isEqual ( nodeOrg , nodeSym )) return false ; stack < TreeNode *> stackOrg ; stack < TreeNode *> stackSym ; while ( ! stackOrg . empty () || nodeOrg != nullptr ) { while ( nodeOrg || nodeSym ) { if ( ! isEqual ( nodeOrg , nodeSym )) return false ; stackOrg . push ( nodeOrg ); stackSym . push ( nodeSym ); nodeOrg = nodeOrg -> left ; nodeSym = nodeSym -> right ; } while ( ! stackOrg . empty () && nodeOrg == nullptr && nodeSym == nullptr ) { nodeOrg = stackOrg . top () -> right ; nodeSym = stackSym . top () -> left ; if ( ! isEqual ( nodeOrg , nodeSym )) return false ; stackOrg . pop (); stackSym . pop (); } } return true ; } bool isEqual ( TreeNode * node1 , TreeNode * node2 ) { if ( ! node1 || ! node2 ) return node1 == node2 ; return node1 -> val == node2 -> val ; } };","title":"\u8fed\u4ee3"},{"location":"_problems/_leetcode/102/","text":"\u7ed9\u4f60\u4e00\u4e2a\u4e8c\u53c9\u6811\uff0c\u8bf7\u4f60\u8fd4\u56de\u5176\u6309 \u5c42\u5e8f\u904d\u5386 \u5f97\u5230\u7684\u8282\u70b9\u503c Example1: \u4e8c\u53c9\u6811\uff1a[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 \u8fd4\u56de\u5176\u5c42\u5e8f\u904d\u5386\u7ed3\u679c\uff1a [ [3], [9,20], [15,7] ] Note: 0 <= number of nodes <= 1000 (Medium) BFS \u5206\u5c42\u6027\u8d28\uff0c\u6ce8\u610f N \u95ee\u9898 solution class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> res ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { vector < int > levelRes ; int n = queue . size (); for ( int i = 0 ; i < n ; ++ i ) { TreeNode * node = queue . front (); queue . pop (); levelRes . push_back ( node -> val ); if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } res . push_back ( levelRes ); } return res ; } };","title":"102. binary tree level order traversal"},{"location":"_problems/_leetcode/1027/","text":"\u7ed9\u5b9a\u6574\u6570\u6570\u7ec4 A \uff0c\u8fd4\u56de A \u4e2d\u6700\u957f\u7b49\u5dee\u5b50\u5e8f\u5217\u7684\u957f\u5ea6 Example: \u8f93\u5165\uff1a[20,1,15,3,10,5,8] \u8f93\u51fa\uff1a4 \u89e3\u91ca: \u6700\u957f\u7684\u7b49\u5dee\u5b50\u5e8f\u5217\u662f [20,15,10,5]\u3002 Note: 2 <= num.length <= 2000 0 <= A[i] <= 10000 (Medium) \u4e24\u79cd\u601d\u8def: dp[i][d] \u8868\u793a A[0...i] \u4e2d\u4ee5 A[i] \u7ed3\u5c3e\u516c\u5dee\u4e3a d \u7684\u6700\u957f\u7b49\u5dee\u5b50\u5e8f\u5217\u957f \u65f6\u95f4 $O(n^2)$\uff0c\u7a7a\u95f4 $O(n^2)$ dp[i][j] \u8868\u793a A[0...i] \u4e2d\u4ee5 A[j] \u548c A[i] \u4e3a\u6700\u540e\u4e24\u9879\u7684\u6700\u957f\u7b49\u5dee\u5b50\u5e8f\u5217\u957f \u76f4\u63a5\u505a $O(n^3)$\uff0c\u7528 hashmap \u8bb0\u5f55 2A[j] - A[i] \u7684 index \u53ef\u4f18\u5316\u4e3a $O(n^2)$ \u5b9e\u9645\u4e2d\u540e\u8005\u66f4\u5feb\u7a7a\u95f4\u4e5f\u66f4\u5c0f\uff0c\u53ef\u80fd hashmap \u5e38\u6570\u6bd4\u8f83\u5927 solution: former class Solution { public : int longestArithSeqLength ( vector < int >& nums ) { int max_len = 2 ; vector < unordered_map < int , int >> dp ( nums . size ()); for ( int i = 1 ; i < nums . size (); ++ i ) { for ( int j = i - 1 ; j >= 0 ; -- j ) { int diff = nums [ i ] - nums [ j ]; auto iter = dp [ j ]. find ( diff ); int t = 2 ; if ( iter != dp [ j ]. end ()) { t = iter -> second + 1 ; } dp [ i ][ diff ] = max ( t , dp [ i ][ diff ]); max_len = max ( t , max_len ); } } return max_len ; } };","title":"1027. longest arithmetic subsequence"},{"location":"_problems/_leetcode/103/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u53c9\u6811\uff0c\u8fd4\u56de\u5176\u8282\u70b9\u503c\u7684\u952f\u9f7f\u5f62\u5c42\u5e8f\u904d\u5386\u3002\uff08\u5373\u5148\u4ece\u5de6\u5f80\u53f3\uff0c\u518d\u4ece\u53f3\u5f80\u5de6\u8fdb\u884c\u4e0b\u4e00\u5c42\u904d\u5386\uff0c\u4ee5\u6b64\u7c7b\u63a8\uff0c\u5c42\u4e0e\u5c42\u4e4b\u95f4\u4ea4\u66ff\u8fdb\u884c\uff09\u3002 Example: \u7ed9\u5b9a\u4e8c\u53c9\u6811 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 \u8fd4\u56de\u952f\u9f7f\u5f62\u5c42\u5e8f\u904d\u5386\u5982\u4e0b\uff1a [ [3], [20,9], [15,7] ] Note: 0 <= number of nodes <= 2000 (Medium) \u5c42\u5e8f\u904d\u5386\u7167\u5e38\uff0c\u6bcf\u4e00\u5c42\u7684\u7ed3\u679c\u7528\u4e00\u4e2a deque \u63a5\u7740 solution class Solution { public : vector < vector < int >> zigzagLevelOrder ( TreeNode * root ) { if ( root == nullptr ) return {}; vector < vector < int >> res ; queue < TreeNode *> nodeQueue ; nodeQueue . push ( root ); bool isOrderLeft = true ; while ( ! nodeQueue . empty ()) { deque < int > levelRes ; int n = nodeQueue . size (); for ( int i = 0 ; i < n ; ++ i ) { TreeNode * node = nodeQueue . front (); nodeQueue . pop (); if ( isOrderLeft ) { levelRes . push_back ( node -> val ); } else { levelRes . push_front ( node -> val ); } if ( node -> left ) { nodeQueue . push ( node -> left ); } if ( node -> right ) { nodeQueue . push ( node -> right ); } } res . emplace_back ( vector < int > { levelRes . begin (), levelRes . end ()}); isOrderLeft = ! isOrderLeft ; } return res ; } };","title":"103. binary tree zigzag level order traversal"},{"location":"_problems/_leetcode/105/","text":"\u7ed9\u5b9a\u4e8c\u53c9\u6811\u7684\u524d\u5e8f\u904d\u5386\u548c\u4e2d\u5e8f\u904d\u5386\uff0c\u6784\u9020\u4e8c\u53c9\u6811\u5e76\u8fd4\u56de\u5176\u6839\u7ed3\u70b9 Example: \u4e2d\u5e8f\u904d\u5386 inorder = [9,3,15,20,7] \u540e\u5e8f\u904d\u5386 postorder = [9,15,7,20,3] 3 / \\ 9 20 / \\ 15 7 Note: -3000 < preorder[i], inorder[i] < 3000 \u4e8c\u53c9\u6811\u6bcf\u4e2a\u7ed3\u70b9\u7684\u503c\u552f\u4e00 (Medium) \u9012\u5f52 \ud83e\uddd0 \u89c4\u5f8b \u524d\u5e8f [root, [left subtree], [right subtree]] \u4e2d\u5e8f [[left subtree], root, [right subtree]] \u4f2a\u4ee3\u7801 construct ( pre [ l1 ... r1 ), in [ l2 ... r2 )) { if ( l1 == r1 ) return NULL ; i = find_index ( in , root ); root = Node ( pre [ l1 ]); root -> left = construct ( pre [ l1 + 1 , l1 + i - l2 + 1 ), in [ l2 , i )) root -> right = constuct ( pre [ l1 + i - l2 + 1 , r1 ), in [ i + 1 , r2 )) return root ; } \u65f6\u95f4\u590d\u6742\u5ea6: \u5982\u679c find_index \u4e3a $O(n)$\uff0c\u5219\u6700\u574f $T(n) = T(n-2) + O(n)$\uff0c$T(n)=n^2$\uff0c\u6700\u597d $T(n) = 2T(n/2) + O(n)$\uff0c$T(n)=n\\log n$ \u5982\u679c find_index \u67e5\u8868\uff0c\u6700\u597d\u6700\u574f\u5747 $O(n)$ solution \u2003 1 class Solution { public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { return buildTreeSubProcess ( preorder , inorder , 0 , preorder . size (), 0 , inorder . size ()); } TreeNode * buildTreeSubProcess ( vector < int >& preorder , vector < int >& inorder , int preL , int preR , int inL , int inR ) { if ( preL == preR ) return nullptr ; int root = preorder [ preL ]; int rootIdx = find ( inorder . begin () + inL , inorder . begin () + inR , root ) - inorder . begin (); TreeNode * thisNode = new TreeNode ; thisNode -> val = root ; thisNode -> left = buildTreeSubProcess ( preorder , inorder , preL + 1 , preL + rootIdx - inL + 1 , inL , rootIdx ); thisNode -> right = buildTreeSubProcess ( preorder , inorder , preL + rootIdx - inL + 1 , preR , rootIdx + 1 , inR ); return thisNode ; } }; \u2003 2 class Solution { private : unordered_map < int , int > val2Index ; public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { for ( int i = 0 ; i < inorder . size (); ++ i ) val2Index [ inorder [ i ]] = i ; return buildTreeSubProcess ( preorder , inorder , 0 , preorder . size (), 0 , inorder . size ()); } TreeNode * buildTreeSubProcess ( vector < int >& preorder , vector < int >& inorder , int preL , int preR , int inL , int inR ) { if ( preL == preR ) return nullptr ; int root = preorder [ preL ]; int rootIdx = val2Index [ root ]; TreeNode * thisNode = new TreeNode ; thisNode -> val = root ; thisNode -> left = buildTreeSubProcess ( preorder , inorder , preL + 1 , preL + rootIdx - inL + 1 , inL , rootIdx ); thisNode -> right = buildTreeSubProcess ( preorder , inorder , preL + rootIdx - inL + 1 , preR , rootIdx + 1 , inR ); return thisNode ; } }; \u8fed\u4ee3 \ud83e\uddd0 \u8003\u8651\u524d\u5e8f\u548c\u4e2d\u5e8f\u975e\u9012\u5f52\u904d\u5386\u7684\u6a21\u677f void traversal ( TreeNode * root ) { stack < TreeNode *> stack ; while ( ! stack . empty () || root != nullptr ) { while ( root != nullptr ) { // preorder stack . push ( root ); root = root -> left ; } while ( ! stack . empty () && root != nullptr ) { // inorder root = stack . top (); stack . pop (); root = root -> right ; } } } \u601d\u8def: \u5148\u5411\u5de6\u8d70\uff0c\u8d70\u5230\u5934\u518d\u8003\u8651\u6808\u4e2d\u6700\u8fd1\u7684\u7ed3\u70b9\u7684\u53f3\u5b50\u6811 \u5165\u6808\u4e3a\u5148\u5e8f\u65f6\u673a\uff0c\u51fa\u6808\u4e3a\u4e2d\u5e8f\u65f6\u673a \u51fa\u6808\u65f6\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4 (1). \u6808\u548c root \u90fd\u4e3a\u7a7a\uff0c\u4ee3\u8868\u6808\u4e2d\u6240\u6709\u7ed3\u70b9\u6ca1\u6709\u53f3\u5b50\u6811\uff0c\u904d\u5386\u7ed3\u675f (2). \u6808\u4e3a\u7a7a\uff0c root \u4e0d\u4e3a\u7a7a\uff0c\u8bf4\u660e\u6070\u597d\u6808\u4e2d\u6700\u5185\u4fa7\u7ed3\u70b9\u6709\u53f3\u5b50\u6811 \u7ed9\u5b9a\u5148\u5e8f\u548c\u4e2d\u5e8f\u5e8f\u5217\uff0c\u53ef\u4ee5\u6a21\u62df\u6808\u7684\u72b6\u6001: preorder[0...prePtr) : \u5148\u5e8f\u5b8c\u6210\u904d\u5386\u7684\u90e8\u5206 inorder[0...inPtr) : \u4e2d\u5e8f\u5b8c\u6210\u904d\u5386\u7684\u90e8\u5206 solution class Solution { public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { int prePtr = 1 , inPtr = 0 ; stack < TreeNode *> stack ; TreeNode * root = new TreeNode ( preorder [ 0 ]); stack . push ( root ); while ( prePtr != preorder . size ()) { while ( stack . top () -> val != inorder [ inPtr ]) { // \u5411\u5de6\u4e00\u76f4\u8d70 TreeNode * lNode = new TreeNode ( preorder [ prePtr ]); ++ prePtr ; stack . top () -> left = lNode ; stack . push ( lNode ); } // \u8d70\u5230\u5934\uff0c\u5f53\u524d\u503c preorder[prePtr] \u5e94\u5f53\u662f\u6808\u4e2d\u67d0\u7ed3\u70b9\u7684\u53f3\u5b50\u6811 TreeNode * last = nullptr ; // \u6700\u540e\u4e00\u4e2a\u5f39\u51fa\u7684\u7ed3\u70b9\u7684\u53f3\u5b69\u5b50\uff0c\u662f\u5f53\u524d\u503c while ( ! stack . empty () && stack . top () -> val == inorder [ inPtr ]) { ++ inPtr ; last = stack . top (); stack . pop (); } // \u6808\u4e3a\u7a7a\uff0c\u6709\u4e24\u79cd\u60c5\u51b5: (1) \u5411\u6808\u4e2d\u5185\u4fa7\u7ed3\u70b9\u7684\u53f3\u5b50\u6811\u8f6c\u79fb\uff0cprePtr \u8fd8\u6709\u5269\u4f59\uff0c\u5411\u53f3\u8d70 // (2) \u904d\u5386\u7ed3\u675f if ( prePtr != preorder . size ()) { TreeNode * rNode = new TreeNode ( preorder [ prePtr ]); last -> right = rNode ; ++ prePtr ; stack . push ( rNode ); } } return root ; } };","title":"105. construct binary tree from preorder and inorder traversal"},{"location":"_problems/_leetcode/105/#_1","text":"\u89c4\u5f8b \u524d\u5e8f [root, [left subtree], [right subtree]] \u4e2d\u5e8f [[left subtree], root, [right subtree]] \u4f2a\u4ee3\u7801 construct ( pre [ l1 ... r1 ), in [ l2 ... r2 )) { if ( l1 == r1 ) return NULL ; i = find_index ( in , root ); root = Node ( pre [ l1 ]); root -> left = construct ( pre [ l1 + 1 , l1 + i - l2 + 1 ), in [ l2 , i )) root -> right = constuct ( pre [ l1 + i - l2 + 1 , r1 ), in [ i + 1 , r2 )) return root ; } \u65f6\u95f4\u590d\u6742\u5ea6: \u5982\u679c find_index \u4e3a $O(n)$\uff0c\u5219\u6700\u574f $T(n) = T(n-2) + O(n)$\uff0c$T(n)=n^2$\uff0c\u6700\u597d $T(n) = 2T(n/2) + O(n)$\uff0c$T(n)=n\\log n$ \u5982\u679c find_index \u67e5\u8868\uff0c\u6700\u597d\u6700\u574f\u5747 $O(n)$ solution \u2003 1 class Solution { public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { return buildTreeSubProcess ( preorder , inorder , 0 , preorder . size (), 0 , inorder . size ()); } TreeNode * buildTreeSubProcess ( vector < int >& preorder , vector < int >& inorder , int preL , int preR , int inL , int inR ) { if ( preL == preR ) return nullptr ; int root = preorder [ preL ]; int rootIdx = find ( inorder . begin () + inL , inorder . begin () + inR , root ) - inorder . begin (); TreeNode * thisNode = new TreeNode ; thisNode -> val = root ; thisNode -> left = buildTreeSubProcess ( preorder , inorder , preL + 1 , preL + rootIdx - inL + 1 , inL , rootIdx ); thisNode -> right = buildTreeSubProcess ( preorder , inorder , preL + rootIdx - inL + 1 , preR , rootIdx + 1 , inR ); return thisNode ; } }; \u2003 2 class Solution { private : unordered_map < int , int > val2Index ; public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { for ( int i = 0 ; i < inorder . size (); ++ i ) val2Index [ inorder [ i ]] = i ; return buildTreeSubProcess ( preorder , inorder , 0 , preorder . size (), 0 , inorder . size ()); } TreeNode * buildTreeSubProcess ( vector < int >& preorder , vector < int >& inorder , int preL , int preR , int inL , int inR ) { if ( preL == preR ) return nullptr ; int root = preorder [ preL ]; int rootIdx = val2Index [ root ]; TreeNode * thisNode = new TreeNode ; thisNode -> val = root ; thisNode -> left = buildTreeSubProcess ( preorder , inorder , preL + 1 , preL + rootIdx - inL + 1 , inL , rootIdx ); thisNode -> right = buildTreeSubProcess ( preorder , inorder , preL + rootIdx - inL + 1 , preR , rootIdx + 1 , inR ); return thisNode ; } };","title":"\u9012\u5f52"},{"location":"_problems/_leetcode/105/#_2","text":"\u8003\u8651\u524d\u5e8f\u548c\u4e2d\u5e8f\u975e\u9012\u5f52\u904d\u5386\u7684\u6a21\u677f void traversal ( TreeNode * root ) { stack < TreeNode *> stack ; while ( ! stack . empty () || root != nullptr ) { while ( root != nullptr ) { // preorder stack . push ( root ); root = root -> left ; } while ( ! stack . empty () && root != nullptr ) { // inorder root = stack . top (); stack . pop (); root = root -> right ; } } } \u601d\u8def: \u5148\u5411\u5de6\u8d70\uff0c\u8d70\u5230\u5934\u518d\u8003\u8651\u6808\u4e2d\u6700\u8fd1\u7684\u7ed3\u70b9\u7684\u53f3\u5b50\u6811 \u5165\u6808\u4e3a\u5148\u5e8f\u65f6\u673a\uff0c\u51fa\u6808\u4e3a\u4e2d\u5e8f\u65f6\u673a \u51fa\u6808\u65f6\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4 (1). \u6808\u548c root \u90fd\u4e3a\u7a7a\uff0c\u4ee3\u8868\u6808\u4e2d\u6240\u6709\u7ed3\u70b9\u6ca1\u6709\u53f3\u5b50\u6811\uff0c\u904d\u5386\u7ed3\u675f (2). \u6808\u4e3a\u7a7a\uff0c root \u4e0d\u4e3a\u7a7a\uff0c\u8bf4\u660e\u6070\u597d\u6808\u4e2d\u6700\u5185\u4fa7\u7ed3\u70b9\u6709\u53f3\u5b50\u6811 \u7ed9\u5b9a\u5148\u5e8f\u548c\u4e2d\u5e8f\u5e8f\u5217\uff0c\u53ef\u4ee5\u6a21\u62df\u6808\u7684\u72b6\u6001: preorder[0...prePtr) : \u5148\u5e8f\u5b8c\u6210\u904d\u5386\u7684\u90e8\u5206 inorder[0...inPtr) : \u4e2d\u5e8f\u5b8c\u6210\u904d\u5386\u7684\u90e8\u5206 solution class Solution { public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { int prePtr = 1 , inPtr = 0 ; stack < TreeNode *> stack ; TreeNode * root = new TreeNode ( preorder [ 0 ]); stack . push ( root ); while ( prePtr != preorder . size ()) { while ( stack . top () -> val != inorder [ inPtr ]) { // \u5411\u5de6\u4e00\u76f4\u8d70 TreeNode * lNode = new TreeNode ( preorder [ prePtr ]); ++ prePtr ; stack . top () -> left = lNode ; stack . push ( lNode ); } // \u8d70\u5230\u5934\uff0c\u5f53\u524d\u503c preorder[prePtr] \u5e94\u5f53\u662f\u6808\u4e2d\u67d0\u7ed3\u70b9\u7684\u53f3\u5b50\u6811 TreeNode * last = nullptr ; // \u6700\u540e\u4e00\u4e2a\u5f39\u51fa\u7684\u7ed3\u70b9\u7684\u53f3\u5b69\u5b50\uff0c\u662f\u5f53\u524d\u503c while ( ! stack . empty () && stack . top () -> val == inorder [ inPtr ]) { ++ inPtr ; last = stack . top (); stack . pop (); } // \u6808\u4e3a\u7a7a\uff0c\u6709\u4e24\u79cd\u60c5\u51b5: (1) \u5411\u6808\u4e2d\u5185\u4fa7\u7ed3\u70b9\u7684\u53f3\u5b50\u6811\u8f6c\u79fb\uff0cprePtr \u8fd8\u6709\u5269\u4f59\uff0c\u5411\u53f3\u8d70 // (2) \u904d\u5386\u7ed3\u675f if ( prePtr != preorder . size ()) { TreeNode * rNode = new TreeNode ( preorder [ prePtr ]); last -> right = rNode ; ++ prePtr ; stack . push ( rNode ); } } return root ; } };","title":"\u8fed\u4ee3"},{"location":"_problems/_leetcode/106/","text":"\u7ed9\u5b9a\u4e8c\u53c9\u6811\u7684\u524d\u5e8f\u904d\u5386\u548c\u540e\u5e8f\u904d\u5386\uff0c\u6784\u9020\u4e8c\u53c9\u6811\u5e76\u8fd4\u56de\u5176\u6839\u7ed3\u70b9 Example: \u4e2d\u5e8f\u904d\u5386 inorder = [9,3,15,20,7] \u540e\u5e8f\u904d\u5386 postorder = [9,15,7,20,3] 3 / \\ 9 20 / \\ 15 7 Note: -3000 < preorder[i], inorder[i] < 3000 \u4e8c\u53c9\u6811\u6bcf\u4e2a\u7ed3\u70b9\u7684\u503c\u552f\u4e00 (Medium) \u9012\u5f52 \ud83e\uddd0 solution class Solution { private : unordered_map < int , int > val2index ; public : TreeNode * buildTree ( vector < int >& inorder , vector < int >& postorder ) { for ( int i = 0 ; i < inorder . size (); ++ i ) val2index [ inorder [ i ]] = i ; return buildTreeSubProcess ( inorder , postorder , 0 , inorder . size (), 0 , postorder . size ()); } TreeNode * buildTreeSubProcess ( vector < int >& inorder , vector < int >& postorder , int inL , int inR , int postL , int postR ) { if ( inL == inR ) return nullptr ; int root = postorder [ postR - 1 ]; int i = val2index [ root ]; TreeNode * thisNode = new TreeNode ( root ); thisNode -> left = buildTreeSubProcess ( inorder , postorder , inL , i , postL , postL + i - inL ); thisNode -> right = buildTreeSubProcess ( inorder , postorder , i + 1 , inR , postL + i - inL , postR - 1 ); return thisNode ; } };","title":"106. construct binary tree from inorder and postorder traversal"},{"location":"_problems/_leetcode/106/#_1","text":"solution class Solution { private : unordered_map < int , int > val2index ; public : TreeNode * buildTree ( vector < int >& inorder , vector < int >& postorder ) { for ( int i = 0 ; i < inorder . size (); ++ i ) val2index [ inorder [ i ]] = i ; return buildTreeSubProcess ( inorder , postorder , 0 , inorder . size (), 0 , postorder . size ()); } TreeNode * buildTreeSubProcess ( vector < int >& inorder , vector < int >& postorder , int inL , int inR , int postL , int postR ) { if ( inL == inR ) return nullptr ; int root = postorder [ postR - 1 ]; int i = val2index [ root ]; TreeNode * thisNode = new TreeNode ( root ); thisNode -> left = buildTreeSubProcess ( inorder , postorder , inL , i , postL , postL + i - inL ); thisNode -> right = buildTreeSubProcess ( inorder , postorder , i + 1 , inR , postL + i - inL , postR - 1 ); return thisNode ; } };","title":"\u9012\u5f52"},{"location":"_problems/_leetcode/10_regular_exp_matching/","text":"\u7ed9\u5b9a\u5b57\u7b26\u4e32 s \u548c\u4e00\u4e2a\u5b57\u7b26\u89c4\u5f8b p \uff0c\u5b9e\u73b0\u4e00\u4e2a\u652f\u6301 '.' \u548c '*' \u7684\u6b63\u5219\u8868\u8fbe\u5f0f\u5339\u914d Example1: \u8f93\u5165\uff1as = \"aab\" p = \"c*a*b\" \u8f93\u51fa\uff1atrue Example2: \u8f93\u5165\uff1as = \"mississippi\" p = \"mis*is*p*.\" \u8f93\u51fa\uff1afalse Note: 0 <= s.length <= 20, \u2002 0 <= p.length <= 30 s \u53ef\u80fd\u4e3a\u7a7a\uff0c\u4e14\u53ea\u5305\u542b\u4ece a-z \u7684\u5c0f\u5199\u5b57\u6bcd p \u53ef\u80fd\u4e3a\u7a7a\uff0c\u4e14\u53ea\u5305\u542b\u4ece a-z \u7684\u5c0f\u5199\u5b57\u6bcd\uff0c\u4ee5\u53ca\u5b57\u7b26 . \u548c * \u4fdd\u8bc1\u6bcf\u6b21\u51fa\u73b0\u5b57\u7b26 * \u65f6\uff0c\u524d\u9762\u90fd\u5339\u914d\u5230\u6709\u6548\u7684\u5b57\u7b26 $dp[i][j]$ \u8868\u793a $s[0...i)$ \u548c $p[0...j)$ \u662f\u5426\u5339\u914d\uff0c\u8fd9\u6837\u8bbe\u8ba1\u65b9\u4fbf\u7a7a\u4e32\u8868\u793a $ \\displaystyle \\normalsize \\ \\ dp[i][j]= \\begin{cases} dp[i-1][j-1] \\mathrm{\\ and \\ } s[i-1] = p[j-1] & \\mathrm{if\\ } p[j] \\ne \\mathsf{*} \\\\ (dp[i-1][j-2] \\mathrm{\\ or\\ } dp[i-1][j]) \\mathrm{\\ and \\ } (s[i-1] = p[j-2]) \\mathrm{\\ or\\ } dp[i][j-2] & \\mathrm{if\\ } p[j] = \\mathsf{*} \\end{cases} $ \u9700\u8981\u6ce8\u610f\u4e0b\u521d\u59cb\u5316\u65f6\uff0c$s$\u4e3a\u7a7a \u5339\u914d $p$ \u7684 $\\mathsf{*}$ \u7684\u60c5\u5f62: $\\displaystyle \\ \\ dp[ 0][0] = \\mathrm{true},\\enspace dp[ 1... ][0] = \\mathrm{false},\\enspace dp[0][j] = (p[j]=\\mathsf{*})\\mathrm{\\ and\\ } (dp[0][j-2]) $ re match public boolean isMatch ( String s , String p ) { int M = s . length (), N = p . length (); boolean [][] dp = new boolean [ M + 1 ][ N + 1 ] ; dp [ 0 ][ 0 ] = true ; for ( int j = 1 ; j < N + 1 ; ++ j ) dp [ 0 ][ j ] = p . charAt ( j - 1 ) == '*' && dp [ 0 ][ j - 2 ] ; for ( int i = 1 ; i < M + 1 ; ++ i ) { for ( int j = 1 ; j < N + 1 ; ++ j ) { if ( p . charAt ( j - 1 ) != '*' ) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] && ( p . charAt ( j - 1 ) == s . charAt ( i - 1 ) || p . charAt ( j - 1 ) == '.' ); else dp [ i ][ j ] = (( dp [ i - 1 ][ j - 2 ] || dp [ i - 1 ][ j ] ) && ( p . charAt ( j - 2 ) == s . charAt ( i - 1 ) || p . charAt ( j - 2 ) == '.' )) || dp [ i ][ j - 2 ] ; } } return dp [ M ][ N ] ; } \u5f53 $p[j]=\\mathsf{*}$ \u4e14 $s[i-1] \\ne p[j-2]$ \u65f6\uff0c\u53ef\u4ee5\u53ea\u8ba1\u7b97 $dp[i][j-2]$\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c1d\u8bd5\u8bb0\u5fc6\u5316\u641c\u7d22 + \u526a\u679d re match public boolean isMatch ( String s , String p ) { int M = s . length (), N = p . length (); int [][] dp = new int [ M + 1 ][ N + 1 ] ; // 0: \u672a\u627e\u5230, 1: false, 2: true return search ( M , N , dp , s . toCharArray (), p . toCharArray ()) == 2 ; } public int search ( int i , int j , int [][] dp , char [] s , char [] p ) { if ( dp [ i ][ j ] != 0 ) return dp [ i ][ j ] ; if ( j == 0 ) return ( i == 0 ) ? 2 : 1 ; if ( i == 0 ) return ( p [ j - 1 ] == '*' && search ( i , j - 2 , dp , s , p ) == 2 ) ? 2 : 1 ; if ( s [ i - 1 ] == p [ j - 1 ] || p [ j - 1 ] == '.' ) { dp [ i ][ j ] = search ( i - 1 , j - 1 , dp , s , p ); } if ( p [ j - 1 ] == '*' ) { if ( s [ i - 1 ] == p [ j - 2 ] || p [ j - 2 ] == '.' ) { dp [ i ][ j ] = ( search ( i - 1 , j - 2 , dp , s , p ) == 2 || search ( i - 1 , j , dp , s , p ) == 2 ) ? 2 : 1 ; } dp [ i ][ j ] = ( search ( i , j - 2 , dp , s , p ) == 2 ) ? 2 : dp [ i ][ j ] ; } return dp [ i ][ j ] ; }","title":"10. regular exp matching"},{"location":"_problems/_leetcode/112/","text":"\u7ed9\u4f60\u4e8c\u53c9\u6811\u7684\u6839\u8282\u70b9 root \u548c\u4e00\u4e2a\u8868\u793a\u76ee\u6807\u548c\u7684\u6574\u6570 targetSum \uff0c\u5224\u65ad\u8be5\u6811\u4e2d\u662f\u5426\u5b58\u5728 \u6839\u8282\u70b9\u5230\u53f6\u5b50\u8282\u70b9 \u7684\u8def\u5f84\uff0c\u8fd9\u6761\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u503c\u76f8\u52a0\u7b49\u4e8e\u76ee\u6807\u548c targetSum Example: \u8f93\u5165\uff1aroot = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 \u8f93\u51fa\uff1atrue Note: \u6811\u4e2d\u8282\u70b9\u603b\u6570\u5728\u8303\u56f4 [0, 5000] \u5185 -1000 <= Node.val, targetSum <= 1000 (Easy) \u6811\u7684\u524d\u5e8f\u904d\u5386 (BFS \u4e5f\u53ef\u4ee5\uff0c\u7a7a\u95f4 $O(n)$)\uff0c\u6709\u8d1f\u6570\u4e0d\u80fd\u526a\u679d solution class Solution { public : bool hasPathSum ( TreeNode * root , int target_sum ) { if ( ! root ) { return false ; } if ( ! root -> left && ! root -> right ) { return root -> val == target_sum ; } return hasPathSum ( root -> left , target_sum - root -> val ) || hasPathSum ( root -> right , target_sum - root -> val ); } }; \u65f6\u95f4 $O(n)$ \u7a7a\u95f4 $O(h)$","title":"112. path sum"},{"location":"_problems/_leetcode/113/","text":"\u7ed9\u4f60\u4e8c\u53c9\u6811\u7684\u6839\u8282\u70b9 root \u548c\u4e00\u4e2a\u8868\u793a\u76ee\u6807\u548c\u7684\u6574\u6570 targetSum \uff0c\u627e\u51fa\u6240\u6709 \u4ece\u6839\u8282\u70b9\u5230\u53f6\u5b50\u8282\u70b9 \u8def\u5f84\u603b\u548c\u7b49\u4e8e\u7ed9\u5b9a\u76ee\u6807\u548c\u7684\u8def\u5f84 Example: \u8f93\u5165\uff1aroot = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 \u8f93\u51fa\uff1a[[5,4,11,2],[5,8,4,5]] Note: \u6811\u4e2d\u8282\u70b9\u603b\u6570\u5728\u8303\u56f4 [0, 5000] \u5185 -1000 <= Node.val, targetSum <= 1000 (Medium) \u548c 112. path sum \u4e00\u6837\uff0c\u53ea\u662f\u9700\u8981\u7ef4\u62a4\u4e00\u4e2a\u8def\u5f84\uff0c\u5728\u540e\u5e8f\u65f6\u673a\u5220\u9664\u5f53\u524d\u7ed3\u70b9 solution class Solution { public : vector < vector < int >> pathSum ( TreeNode * root , int targetSum ) { tarSum = targetSum ; traverse ( root ); return res ; } void traverse ( TreeNode * root ) { if ( ! root ) return ; curSum += root -> val ; numPath . push_back ( root -> val ); if ( ! root -> left && ! root -> right && curSum == tarSum ) res . push_back ( numPath ); traverse ( root -> left ); traverse ( root -> right ); curSum -= root -> val ; numPath . pop_back (); } private : vector < vector < int >> res ; vector < int > numPath ; int curSum = 0 , tarSum = 0 ; }; \u65f6\u95f4 $O(n)$ \u7a7a\u95f4 $O(h)$","title":"113. path sum ii"},{"location":"_problems/_leetcode/120_triangle/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u4e09\u89d2\u5f62 triangle \uff0c\u627e\u51fa\u81ea\u9876\u5411\u4e0b\u7684\u6700\u5c0f\u8def\u5f84\u548c\u3002 \u6bcf\u4e00\u6b65\u53ea\u80fd\u79fb\u52a8\u5230\u4e0b\u4e00\u884c\u4e2d\u76f8\u90bb\u7684\u7ed3\u70b9\u4e0a\u3002\u76f8\u90bb\u7684\u7ed3\u70b9 \u5728\u8fd9\u91cc\u6307\u7684\u662f \u4e0b\u6807 \u4e0e \u4e0a\u4e00\u5c42\u7ed3\u70b9\u4e0b\u6807 \u76f8\u540c\u6216\u8005\u7b49\u4e8e \u4e0a\u4e00\u5c42\u7ed3\u70b9\u4e0b\u6807 + 1 \u7684\u4e24\u4e2a\u7ed3\u70b9\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c\u6b63\u4f4d\u4e8e\u5f53\u524d\u884c\u7684\u4e0b\u6807 i \uff0c\u90a3\u4e48\u4e0b\u4e00\u6b65\u53ef\u4ee5\u79fb\u52a8\u5230\u4e0b\u4e00\u884c\u7684\u4e0b\u6807 i \u6216 i + 1 \u3002 \u8f93\u5165\uff1atriangle = [[2],[3,4],[6,5,7],[4,1,8,3]] \u8f93\u51fa\uff1a11 \u89e3\u91ca\uff1a\u5982\u4e0b\u9762\u7b80\u56fe\u6240\u793a\uff1a 2 3 4 6 5 7 4 1 8 3 \u81ea\u9876\u5411\u4e0b\u7684\u6700\u5c0f\u8def\u5f84\u548c\u4e3a 11\uff08\u5373\uff0c2 + 3 + 5 + 1 = 11\uff09\u3002 Note: 1 <= triangle.length <= 200 triangle[0].length == 1 triangle[i].length == triangle[i - 1].length + 1 -10^4 <= triangle[i][j] <= 10^4 \u7ecf\u5178 dp \u95ee\u9898 \u81ea\u9876\u5411\u4e0b: dp[i][j] = min { dp[i - 1][j], dp[i - 1][j - 1] } + triangle[i][j] \u81ea\u5e95\u5411\u4e0a: dp[i][j] = min { dp[i + 1][j], dp[i + 1][j + 1] } + triangle[i][j] , \u8868\u793a\u4ece\u6700\u4f4e\u5c42\u67d0\u4e00\u70b9\u5230 triangle[i][j] \u7684\u6700\u77ed\u8def\u957f\uff0c\u4ee3\u7801\u5199\u8d77\u6765\u66f4\u7b80\u6d01 triangle public int minimumTotal ( List < List < Integer >> triangle ) { Integer [] dp = new Integer [ triangle . get ( triangle . size () - 1 ). size () ] ; triangle . get ( triangle . size () - 1 ). toArray ( dp ); for ( int i = triangle . size () - 2 ; i >= 0 ; -- i ) { List < Integer > nodes = triangle . get ( i ); for ( int j = 0 ; j < nodes . size (); ++ j ) dp [ j ] = min ( dp [ j ] , dp [ j + 1 ] ) + nodes . get ( j ); } return dp [ 0 ] ; }","title":"120. triangle"},{"location":"_problems/_leetcode/121_best_time_to_sell_stock/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 prices \uff0c\u5b83\u7684\u7b2c i \u4e2a\u5143\u7d20 prices[i] \u8868\u793a\u4e00\u652f\u7ed9\u5b9a\u80a1\u7968\u7b2c i \u5929\u7684\u4ef7\u683c\u3002 \u4f60\u53ea\u80fd\u9009\u62e9 \u67d0\u4e00\u5929 \u4e70\u5165\u8fd9\u53ea\u80a1\u7968\uff0c\u5e76\u9009\u62e9\u5728 \u672a\u6765\u7684\u67d0\u4e00\u4e2a\u4e0d\u540c\u7684\u65e5\u5b50 \u5356\u51fa\u8be5\u80a1\u7968\u3002\u8bbe\u8ba1\u4e00\u4e2a\u7b97\u6cd5\u6765\u8ba1\u7b97\u4f60\u6240\u80fd\u83b7\u53d6\u7684\u6700\u5927\u5229\u6da6\u3002 \u8fd4\u56de\u4f60\u53ef\u4ee5\u4ece\u8fd9\u7b14\u4ea4\u6613\u4e2d\u83b7\u53d6\u7684\u6700\u5927\u5229\u6da6\u3002\u5982\u679c\u4f60\u4e0d\u80fd\u83b7\u53d6\u4efb\u4f55\u5229\u6da6\uff0c\u8fd4\u56de 0 Example1: \u8f93\u5165\uff1a[7,1,5,3,6,4] \u8f93\u51fa\uff1a5 \u89e3\u91ca\uff1a\u5728\u7b2c 2 \u5929\uff08\u80a1\u7968\u4ef7\u683c = 1\uff09\u7684\u65f6\u5019\u4e70\u5165\uff0c\u5728\u7b2c 5 \u5929\uff08\u80a1\u7968\u4ef7\u683c = 6\uff09\u7684\u65f6\u5019\u5356\u51fa\uff0c\u6700\u5927\u5229\u6da6 = 6-1 = 5 \u3002 \u6ce8\u610f\u5229\u6da6\u4e0d\u80fd\u662f 7-1 = 6, \u56e0\u4e3a\u5356\u51fa\u4ef7\u683c\u9700\u8981\u5927\u4e8e\u4e70\u5165\u4ef7\u683c\uff1b\u540c\u65f6\uff0c\u4f60\u4e0d\u80fd\u5728\u4e70\u5165\u524d\u5356\u51fa\u80a1\u7968\u3002 Example2: \u8f93\u5165\uff1aprices = [7,6,4,3,1] \u8f93\u51fa\uff1a0 \u89e3\u91ca\uff1a\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b, \u6ca1\u6709\u4ea4\u6613\u5b8c\u6210, \u6240\u4ee5\u6700\u5927\u5229\u6da6\u4e3a 0\u3002 Note: 1 <= prices.length <= 10^5 0 <= prices[i] <= 10^4 $dp[i]$ \u8868\u793a\u7b2c $i$ \u5929\u7ed3\u675f\u540e\u80fd\u83b7\u53d6\u7684\u6700\u5927\u5229\u6da6\uff0c\u5219: $$ dp[i] = \\max\\lbrace\\ dp[i-1],\\enspace price[i]- \\min_{j\\leq i}prices[j] \\ \\rbrace $$ solution public int maxProfit ( int [] prices ) { int minPrice = prices [ 0 ] ; int profit = 0 ; for ( int i = 1 ; i < prices . length ; ++ i ) { int t = prices [ i ] - minPrice ; if ( t < 0 ) { minPrice = prices [ i ] ; continue ; } if ( t > profit ) profit = t ; } return profit ; }","title":"121. best time to sell stock"},{"location":"_problems/_leetcode/122_best_time_to_sell_stock_ii/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 prices \uff0c\u5b83\u7684\u7b2c i \u4e2a\u5143\u7d20 prices[i] \u8868\u793a\u4e00\u652f\u7ed9\u5b9a\u80a1\u7968\u7b2c i \u5929\u7684\u4ef7\u683c\u3002 \u8bbe\u8ba1\u4e00\u4e2a\u7b97\u6cd5\u6765\u8ba1\u7b97\u4f60\u6240\u80fd\u83b7\u53d6\u7684\u6700\u5927\u5229\u6da6\u3002\u4f60\u53ef\u4ee5\u5c3d\u53ef\u80fd\u5730\u5b8c\u6210\u66f4\u591a\u7684\u4ea4\u6613\uff08\u591a\u6b21\u4e70\u5356\u4e00\u652f\u80a1\u7968\uff09\u3002 \u6ce8\u610f\uff1a\u4f60\u4e0d\u80fd\u540c\u65f6\u53c2\u4e0e\u591a\u7b14\u4ea4\u6613\uff08\u4f60\u5fc5\u987b\u5728\u518d\u6b21\u8d2d\u4e70\u524d\u51fa\u552e\u6389\u4e4b\u524d\u7684\u80a1\u7968\uff09\u3002 Example1: \u8f93\u5165: prices = [7,1,5,3,6,4] \u8f93\u51fa: 7 \u89e3\u91ca: \u5728\u7b2c 2 \u5929\uff08\u80a1\u7968\u4ef7\u683c = 1\uff09\u7684\u65f6\u5019\u4e70\u5165\uff0c\u5728\u7b2c 3 \u5929\uff08\u80a1\u7968\u4ef7\u683c = 5\uff09\u7684\u65f6\u5019\u5356\u51fa, \u8fd9\u7b14\u4ea4\u6613\u6240\u80fd\u83b7\u5f97\u5229\u6da6 = 5-1 = 4 \u3002 \u968f\u540e\uff0c\u5728\u7b2c 4 \u5929\uff08\u80a1\u7968\u4ef7\u683c = 3\uff09\u7684\u65f6\u5019\u4e70\u5165\uff0c\u5728\u7b2c 5 \u5929\uff08\u80a1\u7968\u4ef7\u683c = 6\uff09\u7684\u65f6\u5019\u5356\u51fa, \u8fd9\u7b14\u4ea4\u6613\u6240\u80fd\u83b7\u5f97\u5229\u6da6 = 6-3 = 3 \u3002 Example2: \u8f93\u5165: prices = [1,2,3,4,5] \u8f93\u51fa: 4 \u89e3\u91ca: \u5728\u7b2c 1 \u5929\uff08\u80a1\u7968\u4ef7\u683c = 1\uff09\u7684\u65f6\u5019\u4e70\u5165\uff0c\u5728\u7b2c 5 \u5929 \uff08\u80a1\u7968\u4ef7\u683c = 5\uff09\u7684\u65f6\u5019\u5356\u51fa, \u8fd9\u7b14\u4ea4\u6613\u6240\u80fd\u83b7\u5f97\u5229\u6da6 = 5-1 = 4 \u3002 \u6ce8\u610f\u4f60\u4e0d\u80fd\u5728\u7b2c 1 \u5929\u548c\u7b2c 2 \u5929\u63a5\u8fde\u8d2d\u4e70\u80a1\u7968\uff0c\u4e4b\u540e\u518d\u5c06\u5b83\u4eec\u5356\u51fa\u3002\u56e0\u4e3a\u8fd9\u6837\u5c5e\u4e8e\u540c\u65f6\u53c2\u4e0e\u4e86\u591a\u7b14\u4ea4\u6613\uff0c\u4f60\u5fc5\u987b\u5728\u518d\u6b21\u8d2d\u4e70\u524d\u51fa\u552e\u6389\u4e4b\u524d\u7684\u80a1\u7968\u3002 Note: 1 <= prices.length <= 10^5 0 <= prices[i] <= 10^4 DP \ud83e\uddd0 \u4ee4 $dp_0[i]$ \u8868\u793a\u7b2c $i$ \u5929\u7ed3\u675f\u65f6\u80fd\u83b7\u53d6\u7684\u6700\u5927\u5229\u6da6\u4e14\u7b2c $i$ \u5929\u7ed3\u675f\u65f6\u672a\u6301\u6709\u80a1\u7968\uff0c$dp_1[i]$ \u8868\u793a\u7ed3\u675f\u65f6\u6301\u6709\uff0c\u5219: $$ \\tag{1} dp_0[i] = \\max\\lbrace\\ dp_0[i-1],\\enspace dp_1[i-1] + prices[i] \\ \\rbrace $$ $$ \\tag{2} dp_1[i] = \\max\\lbrace\\ dp_1[i-1],\\enspace dp_0[i-1] - prices[i] \\ \\rbrace $$ \u5982\u679c\u5141\u8bb8\u540c\u4e00\u5929\u5185\u8d2d\u4e70\u6216\u51fa\u552e\u80a1\u7968\uff0c\u4e0d\u5f71\u54cd\u539f\u95ee\u9898\u89e3\u7684\u503c\u3002\u7531\u4e8e $dp_0[i]$ \u6bd4 $dp_0[i-1]$ \u591a\u8003\u8651\u4e86\u7b2c $i$ \u5929\u51fa\u552e\u4e86\u80a1\u7968\u7684\u60c5\u51b5\uff0c\u4ee4 $dp_1[i] = \\max\\lbrace dp_1[i-1], \\ dp_0[i] - prices[i]\\rbrace$ \u4e5f\u65e0\u59a8\uff0c\u628a $(2)$ \u4ee3\u5165 $(1)$ \u4e5f\u53ef\u4ee5\u9a8c\u8bc1\u8fd9\u4e2a\u4e8b\u5b9e Solution public int maxProfit ( int [] prices ) { int N = prices . length ; int dp0 = 0 , dp1 = - prices [ 0 ] ; for ( int i = 1 ; i < N ; ++ i ) { dp0 = Math . max ( dp0 , dp1 + prices [ i ] ); dp1 = Math . max ( dp1 , dp0 - prices [ i ] ); } return dp0 ; } \u8d2a\u5fc3 \ud83e\uddd0 \u8be5\u95ee\u9898\u76f8\u5f53\u4e8e\u6c42\u89e3\u4e00\u7cfb\u5217\u533a\u95f4 $[x_i,x_{i+1},...,y_i]$\uff0c\u4f7f\u5f97 $\\sum y_i-x_i$ \u6700\u5927\uff0c\u5176\u8d2a\u5fc3\u9009\u62e9\u6027\u53ef\u63cf\u8ff0\u4e3a\uff1a \u8bbe\u5e8f\u5217\u4e3a $S=[x_i,...,x_j]$\uff0c\u8bbe $s=[a_i,a_{i+1},...,b_i]$ \u662f $S$ \u4ece\u5de6\u5f80\u53f3\u6570\u7b2c\u4e00\u4e2a\u5b8c\u5168\u9012\u589e\u7684\u533a\u95f4 ($b_{i+1}< b_i$, $a_{i}< a_{i-1}< a_{i-2}...$)\uff0c\u5219 $s$ \u4e00\u5b9a\u5728\u6700\u4f18\u89e3\u4e2d \u56e0\u6b64\u95ee\u9898\u53ef\u8f6c\u5316\u4e3a\u7edf\u8ba1\u76f8\u90bb\u9012\u589e\u6574\u6570\u7684\u5dee solution public int maxProfit ( int [] prices ) { int profits = 0 ; for ( int i = 1 ; i < prices . length ; ++ i ) { if ( prices [ i ] > prices [ i - 1 ] ) profits += prices [ i ] - prices [ i - 1 ] ; } return profits ; }","title":"122. best time to sell stock ii"},{"location":"_problems/_leetcode/122_best_time_to_sell_stock_ii/#dp","text":"\u4ee4 $dp_0[i]$ \u8868\u793a\u7b2c $i$ \u5929\u7ed3\u675f\u65f6\u80fd\u83b7\u53d6\u7684\u6700\u5927\u5229\u6da6\u4e14\u7b2c $i$ \u5929\u7ed3\u675f\u65f6\u672a\u6301\u6709\u80a1\u7968\uff0c$dp_1[i]$ \u8868\u793a\u7ed3\u675f\u65f6\u6301\u6709\uff0c\u5219: $$ \\tag{1} dp_0[i] = \\max\\lbrace\\ dp_0[i-1],\\enspace dp_1[i-1] + prices[i] \\ \\rbrace $$ $$ \\tag{2} dp_1[i] = \\max\\lbrace\\ dp_1[i-1],\\enspace dp_0[i-1] - prices[i] \\ \\rbrace $$ \u5982\u679c\u5141\u8bb8\u540c\u4e00\u5929\u5185\u8d2d\u4e70\u6216\u51fa\u552e\u80a1\u7968\uff0c\u4e0d\u5f71\u54cd\u539f\u95ee\u9898\u89e3\u7684\u503c\u3002\u7531\u4e8e $dp_0[i]$ \u6bd4 $dp_0[i-1]$ \u591a\u8003\u8651\u4e86\u7b2c $i$ \u5929\u51fa\u552e\u4e86\u80a1\u7968\u7684\u60c5\u51b5\uff0c\u4ee4 $dp_1[i] = \\max\\lbrace dp_1[i-1], \\ dp_0[i] - prices[i]\\rbrace$ \u4e5f\u65e0\u59a8\uff0c\u628a $(2)$ \u4ee3\u5165 $(1)$ \u4e5f\u53ef\u4ee5\u9a8c\u8bc1\u8fd9\u4e2a\u4e8b\u5b9e Solution public int maxProfit ( int [] prices ) { int N = prices . length ; int dp0 = 0 , dp1 = - prices [ 0 ] ; for ( int i = 1 ; i < N ; ++ i ) { dp0 = Math . max ( dp0 , dp1 + prices [ i ] ); dp1 = Math . max ( dp1 , dp0 - prices [ i ] ); } return dp0 ; }","title":"DP"},{"location":"_problems/_leetcode/122_best_time_to_sell_stock_ii/#_1","text":"\u8be5\u95ee\u9898\u76f8\u5f53\u4e8e\u6c42\u89e3\u4e00\u7cfb\u5217\u533a\u95f4 $[x_i,x_{i+1},...,y_i]$\uff0c\u4f7f\u5f97 $\\sum y_i-x_i$ \u6700\u5927\uff0c\u5176\u8d2a\u5fc3\u9009\u62e9\u6027\u53ef\u63cf\u8ff0\u4e3a\uff1a \u8bbe\u5e8f\u5217\u4e3a $S=[x_i,...,x_j]$\uff0c\u8bbe $s=[a_i,a_{i+1},...,b_i]$ \u662f $S$ \u4ece\u5de6\u5f80\u53f3\u6570\u7b2c\u4e00\u4e2a\u5b8c\u5168\u9012\u589e\u7684\u533a\u95f4 ($b_{i+1}< b_i$, $a_{i}< a_{i-1}< a_{i-2}...$)\uff0c\u5219 $s$ \u4e00\u5b9a\u5728\u6700\u4f18\u89e3\u4e2d \u56e0\u6b64\u95ee\u9898\u53ef\u8f6c\u5316\u4e3a\u7edf\u8ba1\u76f8\u90bb\u9012\u589e\u6574\u6570\u7684\u5dee solution public int maxProfit ( int [] prices ) { int profits = 0 ; for ( int i = 1 ; i < prices . length ; ++ i ) { if ( prices [ i ] > prices [ i - 1 ] ) profits += prices [ i ] - prices [ i - 1 ] ; } return profits ; }","title":"\u8d2a\u5fc3"},{"location":"_problems/_leetcode/123_best_time_to_sell_stock_iii/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 prices \uff0c\u5b83\u7684\u7b2c i \u4e2a\u5143\u7d20 prices[i] \u8868\u793a\u4e00\u652f\u7ed9\u5b9a\u80a1\u7968\u7b2c i \u5929\u7684\u4ef7\u683c\u3002 \u8bbe\u8ba1\u4e00\u4e2a\u7b97\u6cd5\u6765\u8ba1\u7b97\u4f60\u6240\u80fd\u83b7\u53d6\u7684\u6700\u5927\u5229\u6da6\u3002\u4f60\u6700\u591a\u53ef\u4ee5\u5b8c\u6210 \u4e24\u7b14 \u4ea4\u6613 \u8fd4\u56de\u4f60\u53ef\u4ee5\u4ece\u8fd9\u7b14\u4ea4\u6613\u4e2d\u83b7\u53d6\u7684\u6700\u5927\u5229\u6da6\u3002\u5982\u679c\u4f60\u4e0d\u80fd\u83b7\u53d6\u4efb\u4f55\u5229\u6da6\uff0c\u8fd4\u56de 0 Example1: \u8f93\u5165\uff1aprices = [3,3,5,0,0,3,1,4] \u8f93\u51fa\uff1a6 \u89e3\u91ca\uff1a\u5728\u7b2c 4 \u5929\uff08\u80a1\u7968\u4ef7\u683c = 0\uff09\u7684\u65f6\u5019\u4e70\u5165\uff0c\u5728\u7b2c 6 \u5929\uff08\u80a1\u7968\u4ef7\u683c = 3\uff09\u7684\u65f6\u5019\u5356\u51fa\uff0c\u8fd9\u7b14\u4ea4\u6613\u6240\u80fd\u83b7\u5f97\u5229\u6da6 = 3-0 = 3 \u3002 \u968f\u540e\uff0c\u5728\u7b2c 7 \u5929\uff08\u80a1\u7968\u4ef7\u683c = 1\uff09\u7684\u65f6\u5019\u4e70\u5165\uff0c\u5728\u7b2c 8 \u5929 \uff08\u80a1\u7968\u4ef7\u683c = 4\uff09\u7684\u65f6\u5019\u5356\u51fa\uff0c\u8fd9\u7b14\u4ea4\u6613\u6240\u80fd\u83b7\u5f97\u5229\u6da6 = 4-1 = 3 \u3002 Example2: \u8f93\u5165\uff1aprices = [1,2,3,4,5] \u8f93\u51fa\uff1a4 \u89e3\u91ca\uff1a\u5728\u7b2c 1 \u5929\uff08\u80a1\u7968\u4ef7\u683c = 1\uff09\u7684\u65f6\u5019\u4e70\u5165\uff0c\u5728\u7b2c 5 \u5929 \uff08\u80a1\u7968\u4ef7\u683c = 5\uff09\u7684\u65f6\u5019\u5356\u51fa, \u8fd9\u7b14\u4ea4\u6613\u6240\u80fd\u83b7\u5f97\u5229\u6da6 = 5-1 = 4 \u3002 \u6ce8\u610f\u4f60\u4e0d\u80fd\u5728\u7b2c 1 \u5929\u548c\u7b2c 2 \u5929\u63a5\u8fde\u8d2d\u4e70\u80a1\u7968\uff0c\u4e4b\u540e\u518d\u5c06\u5b83\u4eec\u5356\u51fa\u3002 \u56e0\u4e3a\u8fd9\u6837\u5c5e\u4e8e\u540c\u65f6\u53c2\u4e0e\u4e86\u591a\u7b14\u4ea4\u6613\uff0c\u4f60\u5fc5\u987b\u5728\u518d\u6b21\u8d2d\u4e70\u524d\u51fa\u552e\u6389\u4e4b\u524d\u7684\u80a1\u7968\u3002 Note: 1 <= prices.length <= 10^5 0 <= prices[i] <= 10^4 DP \ud83e\uddd0 \u7531\u4e8e\u6700\u591a\u53ea\u80fd\u4e24\u7b14\u4ea4\u6613\uff0c\u5728\u4efb\u610f\u4e00\u5929\u7ed3\u675f\u65f6\uff0c\u53ef\u80fd\u6709 0\u3001\u4e70\u3001\u4e70\u5356\u3001\u4e70\u5356\u4e70\u3001\u4e70\u5356\u4e70\u5356 \u4e94\u79cd\u72b6\u6001\uff0c\u4ee4 $dp_{buy2}[i]$ \u8868\u793a\u7b2c $i$ \u5929\u7ed3\u675f\u65f6\u7684\u6700\u5927\u5229\u6da6\u4e14\u5f53\u524d\u5df2\u8d2d\u4e70 2 \u6b21\u80a1\u7968\uff0c\u5176\u4f59\u540c\u7406: $$ \\begin{aligned} dp_{buy1}[i] &= \\max\\lbrace\\ dp_{buy1}[i-1],\\enspace -prices[i]\\ \\rbrace \\\\ dp_{sell1}[i] &= \\max\\lbrace\\ dp_{sell1}[i-1],\\enspace dp_{buy1}[i-1]+prices[i]\\ \\rbrace \\\\ dp_{buy2}[i] &= \\max\\lbrace\\ dp_{buy2}[i-1],\\enspace dp_{sell1}[i-1]-prices[i]\\ \\rbrace \\\\ dp_{sell2}[i] &= \\max\\lbrace\\ dp_{sell2}[i-1],\\enspace dp_{buy2}[i-1]+prices[i]\\ \\rbrace \\end{aligned} $$ \u5982\u679c\u5141\u8bb8\u540c\u4e00\u5929\u5185\u591a\u6b21\u8d2d\u4e70\u6216\u51fa\u552e\u80a1\u7968\uff0c\u5e76\u4e0d\u5f71\u54cd\u539f\u95ee\u9898\u7684\u7ed3\u679c\uff0c\u8fd8\u7b80\u5316\u4e86\u5b9e\u73b0: $dp_{buy1}[i]$ \u6bd4 $dp_{buy1}[i-1]$ \u591a\u8003\u8651\u4e86\u7b2c $i$ \u5929\u4e70\u5165\u80a1\u7968\u7684\u60c5\u51b5\uff0c\u4ee4 $dp_{sell1}[i] = \\max\\lbrace\\ dp_{sell1}[i-1],\\enspace dp_{buy1}[i]+prices[i]\\ \\rbrace$ \u4e5f\u65e0\u59a8 \u521d\u59cb $dp_{buy1}[0] = dp_{buy2}[0] = -prices[0],\\enspace dp_{sell1}[0] = dp_{sell2}[0] = 0$ solution public int maxProfit ( int [] prices ) { int buy1 = - prices [ 0 ] , sell1 = 0 , buy2 = - prices [ 0 ] , sell2 = 0 ; for ( int i = 1 ; i < prices . length ; ++ i ) { buy1 = Math . max ( buy1 , - prices [ i ] ); sell1 = Math . max ( sell1 , buy1 + prices [ i ] ); buy2 = Math . max ( buy2 , sell1 - prices [ i ] ); sell2 = Math . max ( sell2 , buy2 + prices [ i ] ); } return sell2 ; } DP2 \ud83e\uddd0 \u53d7 122. best time to sell stock ii \u7684\u5f71\u54cd\uff0c\u7b2c\u4e00\u53cd\u5e94\u662f\u4ee4 $dp_0[i][j]$ \u8868\u793a\u7b2c $i$ \u5929\u7ed3\u675f\u65f6\u5df2\u5b8c\u6210 $j$ \u7b14\u4ea4\u6613\u7684\u6700\u5927\u5229\u6da6 \u4e14 \u7b2c $i$ \u5929\u4e0d\u6301\u6709\u80a1\u7968\uff0c\u540c\u6837\u5141\u8bb8\u4e00\u5929\u5185\u8d2d\u4e70\u51fa\u552e\u80a1\u7968\uff0c\u5219: $$ \\begin{aligned} dp_0[i][j] &= \\max\\lbrace\\ dp_0[i - 1][j], \\enspace dp_1[i][j - 1] + prices[i]\\ \\rbrace \\\\ dp_1[i][j] &= \\max\\lbrace\\ dp_1[i - 1][j], \\enspace dp_0[i][j] - prices[i]\\ \\rbrace \\end{aligned} $$ solution public int maxProfit ( int [] prices ) { int N = prices . length ; int [][] dp0 = new int [ N ][ 3 ] ; int [][] dp1 = new int [ N ][ 3 ] ; dp1 [ 0 ][ 0 ] = - prices [ 0 ] ; for ( int i = 1 ; i < N ; ++ i ) dp1 [ i ][ 0 ] = Math . max ( dp1 [ i - 1 ][ 0 ] , - prices [ i ] ); for ( int j = 1 ; j <= 2 ; ++ j ) { dp1 [ 0 ][ j ] = - prices [ 0 ] ; for ( int i = 1 ; i < N ; ++ i ) { dp0 [ i ][ j ] = Math . max ( dp0 [ i - 1 ][ j ] , dp1 [ i ][ j - 1 ] + prices [ i ] ); dp1 [ i ][ j ] = Math . max ( dp1 [ i - 1 ][ j ] , dp0 [ i ][ j ] - prices [ i ] ); } } return dp0 [ N - 1 ][ 2 ] ; }","title":"123. best time to sell stock iii"},{"location":"_problems/_leetcode/123_best_time_to_sell_stock_iii/#dp","text":"\u7531\u4e8e\u6700\u591a\u53ea\u80fd\u4e24\u7b14\u4ea4\u6613\uff0c\u5728\u4efb\u610f\u4e00\u5929\u7ed3\u675f\u65f6\uff0c\u53ef\u80fd\u6709 0\u3001\u4e70\u3001\u4e70\u5356\u3001\u4e70\u5356\u4e70\u3001\u4e70\u5356\u4e70\u5356 \u4e94\u79cd\u72b6\u6001\uff0c\u4ee4 $dp_{buy2}[i]$ \u8868\u793a\u7b2c $i$ \u5929\u7ed3\u675f\u65f6\u7684\u6700\u5927\u5229\u6da6\u4e14\u5f53\u524d\u5df2\u8d2d\u4e70 2 \u6b21\u80a1\u7968\uff0c\u5176\u4f59\u540c\u7406: $$ \\begin{aligned} dp_{buy1}[i] &= \\max\\lbrace\\ dp_{buy1}[i-1],\\enspace -prices[i]\\ \\rbrace \\\\ dp_{sell1}[i] &= \\max\\lbrace\\ dp_{sell1}[i-1],\\enspace dp_{buy1}[i-1]+prices[i]\\ \\rbrace \\\\ dp_{buy2}[i] &= \\max\\lbrace\\ dp_{buy2}[i-1],\\enspace dp_{sell1}[i-1]-prices[i]\\ \\rbrace \\\\ dp_{sell2}[i] &= \\max\\lbrace\\ dp_{sell2}[i-1],\\enspace dp_{buy2}[i-1]+prices[i]\\ \\rbrace \\end{aligned} $$ \u5982\u679c\u5141\u8bb8\u540c\u4e00\u5929\u5185\u591a\u6b21\u8d2d\u4e70\u6216\u51fa\u552e\u80a1\u7968\uff0c\u5e76\u4e0d\u5f71\u54cd\u539f\u95ee\u9898\u7684\u7ed3\u679c\uff0c\u8fd8\u7b80\u5316\u4e86\u5b9e\u73b0: $dp_{buy1}[i]$ \u6bd4 $dp_{buy1}[i-1]$ \u591a\u8003\u8651\u4e86\u7b2c $i$ \u5929\u4e70\u5165\u80a1\u7968\u7684\u60c5\u51b5\uff0c\u4ee4 $dp_{sell1}[i] = \\max\\lbrace\\ dp_{sell1}[i-1],\\enspace dp_{buy1}[i]+prices[i]\\ \\rbrace$ \u4e5f\u65e0\u59a8 \u521d\u59cb $dp_{buy1}[0] = dp_{buy2}[0] = -prices[0],\\enspace dp_{sell1}[0] = dp_{sell2}[0] = 0$ solution public int maxProfit ( int [] prices ) { int buy1 = - prices [ 0 ] , sell1 = 0 , buy2 = - prices [ 0 ] , sell2 = 0 ; for ( int i = 1 ; i < prices . length ; ++ i ) { buy1 = Math . max ( buy1 , - prices [ i ] ); sell1 = Math . max ( sell1 , buy1 + prices [ i ] ); buy2 = Math . max ( buy2 , sell1 - prices [ i ] ); sell2 = Math . max ( sell2 , buy2 + prices [ i ] ); } return sell2 ; }","title":"DP"},{"location":"_problems/_leetcode/123_best_time_to_sell_stock_iii/#dp2","text":"\u53d7 122. best time to sell stock ii \u7684\u5f71\u54cd\uff0c\u7b2c\u4e00\u53cd\u5e94\u662f\u4ee4 $dp_0[i][j]$ \u8868\u793a\u7b2c $i$ \u5929\u7ed3\u675f\u65f6\u5df2\u5b8c\u6210 $j$ \u7b14\u4ea4\u6613\u7684\u6700\u5927\u5229\u6da6 \u4e14 \u7b2c $i$ \u5929\u4e0d\u6301\u6709\u80a1\u7968\uff0c\u540c\u6837\u5141\u8bb8\u4e00\u5929\u5185\u8d2d\u4e70\u51fa\u552e\u80a1\u7968\uff0c\u5219: $$ \\begin{aligned} dp_0[i][j] &= \\max\\lbrace\\ dp_0[i - 1][j], \\enspace dp_1[i][j - 1] + prices[i]\\ \\rbrace \\\\ dp_1[i][j] &= \\max\\lbrace\\ dp_1[i - 1][j], \\enspace dp_0[i][j] - prices[i]\\ \\rbrace \\end{aligned} $$ solution public int maxProfit ( int [] prices ) { int N = prices . length ; int [][] dp0 = new int [ N ][ 3 ] ; int [][] dp1 = new int [ N ][ 3 ] ; dp1 [ 0 ][ 0 ] = - prices [ 0 ] ; for ( int i = 1 ; i < N ; ++ i ) dp1 [ i ][ 0 ] = Math . max ( dp1 [ i - 1 ][ 0 ] , - prices [ i ] ); for ( int j = 1 ; j <= 2 ; ++ j ) { dp1 [ 0 ][ j ] = - prices [ 0 ] ; for ( int i = 1 ; i < N ; ++ i ) { dp0 [ i ][ j ] = Math . max ( dp0 [ i - 1 ][ j ] , dp1 [ i ][ j - 1 ] + prices [ i ] ); dp1 [ i ][ j ] = Math . max ( dp1 [ i - 1 ][ j ] , dp0 [ i ][ j ] - prices [ i ] ); } } return dp0 [ N - 1 ][ 2 ] ; }","title":"DP2"},{"location":"_problems/_leetcode/124/","text":"\u8def\u5f84: \u2002 \u4ece\u6811\u4e2d\u4efb\u610f\u7ed3\u70b9\u51fa\u53d1\uff0c\u5230\u8fbe\u4efb\u610f\u7ed3\u70b9\u7684\u7ed3\u70b9\u5e8f\u5217\uff0c\u540c\u4e00\u7ed3\u70b9\u5728\u8def\u5f84\u4e2d\u53ea\u80fd\u51fa\u73b0\u4e00\u6b21. \u7ed9\u5b9a\u4e8c\u53c9\u6811 root \uff0c\u8fd4\u56de\u6700\u5927\u8def\u5f84\u548c (\u8def\u5f84\u4e0a\u7ed3\u70b9\u603b\u548c) Example: \u8f93\u5165\uff1aroot = [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7 \u8f93\u51fa\uff1a42 \u89e3\u91ca\uff1a\u6700\u4f18\u8def\u5f84\u662f 15 -> 20 -> 7 \uff0c\u8def\u5f84\u548c\u4e3a 15 + 20 + 7 = 42 Note: 1 <= n <= 3x10^4 -1000 <= node.val <= 1000 (Hard) \u6811\u578b dp\uff0c\u548c\u4e8c\u53c9\u6811\u76f4\u5f84\u95ee\u9898\u7c7b\u4f3c\u3002\u6700\u5927\u8def\u5f84\u53ef\u80fd\u662f\u4e00\u6839\u6811\u679d\u6216\u4e00\u4e2a\u4e24\u6839\u6811\u679d\u7ec4\u6210\u7684\u6811\u6748 dp[x] : \u2002 x \u5411\u4e0b\u8d70\u7684\u6700\u5927\u8def\u5f84\uff0c dp[x] = max{dp[x->left], dp[x->right]} + x->val \u8ba1\u7b97 dp[x] \u7684\u540c\u65f6\u8ba1\u7b97\u7ecf\u8fc7 x \u7684\u6700\u5927\u8def\u5f84 max[x] \uff0c\u5982\u679c dp[x->left] \u6216 dp[x->right] \u5c0f\u4e8e\u96f6\u5219\u4e0d\u8003\u8651\u76f8\u5e94\u7684\u5b50\u6811 solution class Solution { public : int maxPathSum ( TreeNode * root ) { maxSum = root -> val ; traverse ( root ); return maxSum ; } int traverse ( TreeNode * root ) { if ( root == nullptr ) return 0 ; int lSum = traverse ( root -> left ); int rSum = traverse ( root -> right ); int maxSumByRoot = root -> val ; if ( lSum > 0 ) maxSumByRoot += lSum ; if ( rSum > 0 ) maxSumByRoot += rSum ; maxSum = max ( maxSum , maxSumByRoot ); int mSum = ( lSum > rSum ) ? lSum : rSum ; int res = root -> val ; if ( mSum > 0 ) res += mSum ; return res ; } private : int maxSum = 0 ; };","title":"124. binary tree maximum path sum"},{"location":"_problems/_leetcode/1277/","text":"\u7ed9\u5b9a mxn \u7684\u77e9\u9635\uff0c\u77e9\u9635\u4e2d\u5143\u7d20\u975e 0 \u5373 1\uff0c\u7edf\u8ba1\u7531 1 \u7ec4\u6210\u7684\u5b50\u77e9\u9635\u7684\u4e2a\u6570 Example1: \u8f93\u5165\uff1amatrix = [ [0,1,1,1], [1,1,1,1], [0,1,1,1] ] \u8f93\u51fa\uff1a15 \u89e3\u91ca\uff1a \u8fb9\u957f\u4e3a 1 \u7684\u6b63\u65b9\u5f62\u6709 10 \u4e2a\u3002 \u8fb9\u957f\u4e3a 2 \u7684\u6b63\u65b9\u5f62\u6709 4 \u4e2a\u3002 \u8fb9\u957f\u4e3a 3 \u7684\u6b63\u65b9\u5f62\u6709 1 \u4e2a\u3002 \u6b63\u65b9\u5f62\u7684\u603b\u6570 = 10 + 4 + 1 = 15. Note: 1 <= arr.length <= 300 (Medium) \u89c1 221. \u6700\u5927\u6b63\u65b9\u5f62 solution class Solution { public : int countSquares ( vector < vector < int >>& matrix ) { const int M = matrix . size (), N = matrix [ 0 ]. size (); vector < vector < int >> dp ( M , vector < int > ( N )); int nSquares = 0 ; for ( int j = 0 ; j < N ; ++ j ) { dp [ 0 ][ j ] = matrix [ 0 ][ j ]; nSquares += dp [ 0 ][ j ]; } for ( int i = 1 ; i < M ; ++ i ) { dp [ i ][ 0 ] = matrix [ i ][ 0 ]; nSquares += dp [ i ][ 0 ]; for ( int j = 1 ; j < N ; ++ j ) { if ( matrix [ i ][ j ] == 1 ) { dp [ i ][ j ] = min ( min ( dp [ i -1 ][ j ], dp [ i ][ j -1 ]), dp [ i -1 ][ j -1 ]) + 1 ; } nSquares += dp [ i ][ j ]; } } return nSquares ; } };","title":"1277. count square submatrices with all ones"},{"location":"_problems/_leetcode/128_longest_consecutive_sequence/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u672a\u6392\u5e8f\u7684\u6574\u6570\u6570\u7ec4 nums \uff0c\u627e\u51fa\u6570\u5b57\u8fde\u7eed\u7684\u6700\u957f\u5e8f\u5217\uff08\u4e0d\u8981\u6c42\u5e8f\u5217\u5143\u7d20\u5728\u539f\u6570\u7ec4\u4e2d\u8fde\u7eed\uff09\u7684\u957f\u5ea6\u3002 \u8bf7\u4f60\u8bbe\u8ba1\u5e76\u5b9e\u73b0\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) \u7684\u7b97\u6cd5\u89e3\u51b3\u6b64\u95ee\u9898\u3002 Example1: \u8f93\u5165\uff1anums = [100,4,200,1,3,2] \u8f93\u51fa\uff1a4 \u89e3\u91ca\uff1a\u6700\u957f\u6570\u5b57\u8fde\u7eed\u5e8f\u5217\u662f [1, 2, 3, 4]\u3002\u5b83\u7684\u957f\u5ea6\u4e3a 4\u3002 Example2: \u8f93\u5165\uff1anums = [0,3,7,2,5,8,4,6,0,1] \u8f93\u51fa\uff1a9 Note: 0 <= nums.length <= 10^5 -10^9 <= nums[i] <= 10^9 (Medium) \u54c8\u5e0c\u8868\u67e5\u627e\u76f8\u90bb\u6570\uff0c\u5982\u679c\u4e0d\u662f\u8fde\u7eed\u5e8f\u5217\u7684\u7b2c\u4e00\u4e2a\u6570\u5219\u8df3\u8fc7\u3002\u5b9e\u73b0\u65f6\u6ce8\u610f\u5728\u53bb\u91cd\u540e\u7684\u96c6\u5408\u4e0a\u904d\u5386\u3002 Solution public int longestConsecutive ( int [] nums ) { Set < Integer > integers = new HashSet < Integer > (); for ( int num : nums ) integers . add ( num ); int maxLen = 0 ; for ( int num : integers ) { if ( ! integers . contains ( num - 1 )) { int i = 1 , len = 1 ; while ( integers . contains ( num + i )) { i += 1 ; len += 1 ; } maxLen = Math . max ( maxLen , len ); } } return maxLen ; }","title":"128. longest consecutive sequence"},{"location":"_problems/_leetcode/130_surrounded_regions/","text":"\u7ed9\u4f60\u4e00\u4e2a m x n \u7684\u77e9\u9635 board \uff0c\u7531\u82e5\u5e72\u5b57\u7b26 X \u548c O \uff0c\u627e\u5230\u6240\u6709\u88ab X \u56f4\u7ed5\u7684\u533a\u57df\uff0c\u5e76\u5c06\u8fd9\u4e9b\u533a\u57df\u91cc\u6240\u6709\u7684 O \u7528 X \u586b\u5145\u3002 Example1: \u8f93\u5165\uff1aboard = [[\"X\",\"X\",\"X\",\"X\"], [\"X\",\"O\",\"O\",\"X\"], [\"X\",\"X\",\"O\",\"X\"], [\"X\",\"O\",\"X\",\"X\"]] \u8f93\u51fa\uff1a [[\"X\",\"X\",\"X\",\"X\"], [\"X\",\"X\",\"X\",\"X\"], [\"X\",\"X\",\"X\",\"X\"], [\"X\",\"O\",\"X\",\"X\"]] \u89e3\u91ca\uff1a\u88ab\u56f4\u7ed5\u7684\u533a\u95f4\u4e0d\u4f1a\u5b58\u5728\u4e8e\u8fb9\u754c\u4e0a\uff0c\u6362\u53e5\u8bdd\u8bf4\uff0c\u4efb\u4f55\u8fb9\u754c\u4e0a\u7684 'O' \u90fd\u4e0d\u4f1a\u88ab\u586b\u5145\u4e3a 'X'\u3002 \u4efb\u4f55\u4e0d\u5728\u8fb9\u754c\u4e0a\uff0c\u6216\u4e0d\u4e0e \u8fb9\u754c\u4e0a\u7684 'O' \u76f8\u8fde\u7684 'O' \u6700\u7ec8\u90fd\u4f1a\u88ab\u586b\u5145\u4e3a 'X'\u3002\u5982\u679c\u4e24\u4e2a\u5143\u7d20\u5728\u6c34\u5e73\u6216\u5782\u76f4\u65b9\u5411\u76f8\u90bb\uff0c\u5219\u79f0\u5b83\u4eec\u662f\u201c\u76f8\u8fde\u201d\u7684\u3002 Example2: \u8f93\u5165\uff1aboard = [[\"X\"]] \u8f93\u51fa\uff1a[[\"X\"]] Note: 1 <= board.length, board[0].length <= 200 (Medium) \u548c 200. \u5c9b\u5c7f\u603b\u6570 \u7c7b\u4f3c DFS / BFS: \u4ece\u4f4d\u4e8e\u8fb9\u754c\u4e0a\u7684 O \u5f00\u59cb\u904d\u5386\u5e76\u6807\u8bb0\uff0c\u65f6\u95f4\u4e3a $O(MN)$\uff0c\u7a7a\u95f4 $O(MN)$ \\ $O(\\min(m,n))$\uff0c\u9488\u5bf9\u6b64\u9898\u8003\u8651\u901a\u5e38\u60c5\u51b5\u65f6\u95f4\u53ea\u9700\u8981\u8ba1\u7b97\u8fb9\u7f18\u56e0\u6b64\u65f6\u95f4\u4f1a\u4f4e\u4e00\u4e9b\uff0c\u4f46\u9700\u8981\u989d\u5916\u4fee\u6539\u539f\u6570\u7ec4 \u5e76\u67e5\u96c6: \u4e0d\u9700\u8981\u4fee\u6539\u539f\u6570\u7ec4\uff0c\u5f15\u5165 edge guard node \u5224\u65ad\u662f\u5426\u8fde\u63a5\u8fb9\u7f18\uff0c\u65f6\u95f4\u7a7a\u95f4\u5747\u4e3a $O(MN)$ DFS class Solution { private int M , N ; public void dfs ( int x , int y , char [][] board ) { if ( x < 0 || x == M || y < 0 || y == N || board [ x ][ y ] != 'O' ) return ; board [ x ][ y ] = 'E' ; dfs ( x + 1 , y , board ); dfs ( x - 1 , y , board ); dfs ( x , y + 1 , board ); dfs ( x , y - 1 , board ); } public void solve ( char [][] board ) { M = board . length ; N = board [ 0 ] . length ; for ( int j = 0 ; j < N ; ++ j ) { if ( board [ 0 ][ j ] == 'O' ) dfs ( 0 , j , board ); if ( board [ M - 1 ][ j ] == 'O' ) dfs ( M - 1 , j , board ); } for ( int i = 1 ; i < M - 1 ; ++ i ) { if ( board [ i ][ 0 ] == 'O' ) dfs ( i , 0 , board ); if ( board [ i ][ N - 1 ] == 'O' ) dfs ( i , N - 1 , board ); } for ( int i = 0 ; i < M ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) if ( board [ i ][ j ] == 'E' ) board [ i ][ j ] = 'O' ; else if ( board [ i ][ j ] == 'O' ) board [ i ][ j ] = 'X' ; } } Union-Find Set class Solution { private int [] nodes , rank ; public void solve ( char [][] board ) { int M = board . length , N = board [ 0 ] . length ; nodes = new int [ M * N + 1 ] ; rank = new int [ M * N + 1 ] ; for ( int i = 0 ; i < M ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) { nodes [ i * N + j ] = i * N + j ; if ( board [ i ][ j ] == 'O' && isEdge ( i , j , M , N )) union ( i * N + j , M * N ); } } for ( int i = 0 ; i < M ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) { if ( board [ i ][ j ] == 'X' ) continue ; if ( j != N - 1 && board [ i ][ j + 1 ] == 'O' ) union ( i * N + j , i * N + j + 1 ); if ( i != M - 1 && board [ i + 1 ][ j ] == 'O' ) union ( i * N + j , ( i + 1 ) * N + j ); } } for ( int i = 0 ; i < M ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) { int edgeNode = find ( M * N ); if ( board [ i ][ j ] == 'O' && find ( i * N + j ) != edgeNode ) board [ i ][ j ] = 'X' ; } } } public boolean isEdge ( int x , int y , int M , int N ) { return x == 0 || x == M - 1 || y == 0 || y == N - 1 ; } public void union ( int x , int y ) { int rx = find ( x ), ry = find ( y ); if ( rx == ry ) return ; if ( rank [ rx ] < rank [ ry ] ) nodes [ rx ] = ry ; else nodes [ ry ] = rx ; if ( rank [ rx ] == rank [ ry ] ) rank [ rx ] += 1 ; } public int find ( int x ) { return x == nodes [ x ] ? x : ( nodes [ x ] = find ( nodes [ x ] )); } }","title":"130. surround regions"},{"location":"_problems/_leetcode/134/","text":"\u5728\u4e00\u6761\u73af\u8def\u4e0a\u6709 N \u4e2a\u52a0\u6cb9\u7ad9\uff0c\u5176\u4e2d\u7b2c i \u4e2a\u52a0\u6cb9\u7ad9\u6709\u6c7d\u6cb9 gas[i] \u5347\u3002 \u4f60\u6709\u4e00\u8f86\u6cb9\u7bb1\u5bb9\u91cf\u65e0\u9650\u7684\u7684\u6c7d\u8f66\uff0c\u4ece\u7b2c i \u4e2a\u52a0\u6cb9\u7ad9\u5f00\u5f80\u7b2c i+1 \u4e2a\u52a0\u6cb9\u7ad9\u9700\u8981\u6d88\u8017\u6c7d\u6cb9 cost[i] \u5347\u3002\u4f60\u4ece\u5176\u4e2d\u7684\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u51fa\u53d1\uff0c\u5f00\u59cb\u65f6\u6cb9\u7bb1\u4e3a\u7a7a\u3002 \u5982\u679c\u4f60\u53ef\u4ee5\u7ed5\u73af\u8def\u884c\u9a76\u4e00\u5468\uff0c\u5219\u8fd4\u56de\u51fa\u53d1\u65f6\u52a0\u6cb9\u7ad9\u7684\u7f16\u53f7\uff0c\u5426\u5219\u8fd4\u56de -1\u3002 Example: \u8f93\u5165: gas = [1,2,3,4,5] cost = [3,4,5,1,2] \u8f93\u51fa: 3 Note: 1 <= gas.length, cost.length <= 10^4 \u82e5\u6709\u89e3\uff0c\u5219\u4fdd\u8bc1\u552f\u4e00 \u6570\u7ec4\u5143\u7d20\u975e\u8d1f (Medium) example \u7684\u6570\u7ec4\u53ef\u7b80\u5316\u4e3a arr=[-2,-2,-2,3,3] \uff0c\u95ee\u9898\u8f6c\u5316\u4e3a\u5bfb\u627e\u4e00\u4e2a\u4e0d\u95f4\u65ad\u7684\u5e8f\u5217\u3002\u8be5\u95ee\u9898\u7684\u6027\u8d28: \u82e5\u4ece arr[i] \u6700\u591a\u8d70\u5230 arr[j] \uff0c\u90a3\u4e48\u4ece arr[i..j] \u4efb\u610f\u4e00\u70b9\u4e5f\u6700\u591a\u8d70\u5230 arr[j] \u8fd9\u6837\u5c31\u53ef\u4ee5 $O(n)$ \u65f6\u95f4\u5b8c\u6210\uff0c\u5b9e\u73b0\u4e0a\uff0c\u53ef\u4ee5\u5047\u5b9a\u6570\u7ec4\u4e3a\u4e24\u500d\u957f solution class Solution { public : int canCompleteCircuit ( vector < int >& gas , vector < int >& cost ) { int gasN = 0 , s = 0 ; for ( int i = 0 ; i < gas . size () * 2 ; ++ i ) { gasN += gas [ i % gas . size ()] - cost [ i % gas . size ()]; if ( gasN < 0 ) { s = i + 1 ; gasN = 0 ; if ( s >= gas . size ()) { return -1 ; } continue ; } if ( i - s >= gas . size () - 1 ) return s ; } return -1 ; } };","title":"134. gas station"},{"location":"_problems/_leetcode/138/","text":"\u7ed9\u5b9a\u957f\u5ea6\u4e3a n \u7684\u94fe\u8868\uff0c\u6bcf\u4e2a\u8282\u70b9\u5305\u542b\u4e00\u4e2a\u989d\u5916\u7684\u968f\u673a\u6307\u9488 random \uff0c\u8be5\u6307\u9488\u53ef\u4ee5\u6307\u5411\u94fe\u8868\u4e2d\u968f\u673a\u4e00\u4e2a\u8282\u70b9\u6216\u7a7a\u8282\u70b9\uff0c\u6784\u9020\u8fd9\u4e2a\u94fe\u8868\u7684\u6df1\u62f7\u8d1d\u3002 Example: \u8f93\u5165\uff1ahead = [[7,null],[13,0],[11,4],[10,2],[1,0]] \u8f93\u51fa\uff1a[[7,null],[13,0],[11,4],[10,2],[1,0]] Note: 0 <= linkedlist.length <= 1000 (Medium) \u6700\u57fa\u672c\u7684\u601d\u8def: \u4f7f\u7528\u4e00\u4e2a map<oldNodePtr, newNodePtr> \uff0c\u7b2c\u4e00\u8f6e\u904d\u5386\u6784\u5efa\u8fd9\u4e2a map\uff0c\u7b2c\u4e8c\u8f6e\u6839\u636e\u8fd9\u4e2a map \u586b\u5199\u65b0\u94fe\u8868\u7684 random \u3002\u636e\u6b64: \u7a7a\u95f4\u6362\u65f6\u95f4: \u89c6\u94fe\u8868\u4e3a\u4e00\u4e2a\u6709\u5411\u56fe\uff0c\u901a\u8fc7 dfs \u6784\u5efa\u65b0\u56fe\uff0c\u5c11\u4e00\u8f6e\u904d\u5386\u4f46\u9700\u8981\u9012\u5f52\u7684\u7a7a\u95f4\u5f00\u9500 \u65f6\u95f4\u6362\u7a7a\u95f4: \u5229\u7528\u94fe\u8868\u7ed3\u6784\u8868\u793a map A -> A' -> B -> B' -> ... \uff0c\u8fd9\u6837\u4e0d\u9700\u8981 map\uff0c\u4f46\u9700\u8981\u4e00\u8f6e\u989d\u5916\u7684\u904d\u5386 (\u6784\u5efa\u94fe\u8868\u3001\u586b\u5199 random \u3001\u62c6\u5206\u94fe\u8868) solution 1 class Solution { public : Node * copyRandomList ( Node * head ) { unordered_map < Node * , Node *> old2new ; return dfs ( head , old2new ); } Node * dfs ( Node * node , unordered_map < Node * , Node *>& old2new ) { if ( ! node ) return nullptr ; if ( old2new . count ( node ) == 1 ) // black or gray return old2new [ node ]; Node * newNode = new Node ( node -> val ); old2new [ node ] = newNode ; newNode -> next = dfs ( node -> next , old2new ); newNode -> random = dfs ( node -> random , old2new ); return newNode ; } }; 2 class Solution { public : Node * copyRandomList ( Node * head ) { if ( ! head ) return nullptr ; Node * node = head ; while ( node ) { Node * newNode = new Node ( node -> val ); newNode -> next = node -> next ; node -> next = newNode ; node = newNode -> next ; } node = head ; Node * newHead = node -> next ; while ( node ) { node -> next -> random = ( node -> random ) ? node -> random -> next : nullptr ; node = node -> next -> next ; } node = head ; while ( node ) { Node * copyNode = node -> next ; node -> next = copyNode -> next ; copyNode -> next = ( copyNode -> next ) ? ( copyNode -> next -> next ) : nullptr ; node = node -> next ; } return newHead ; } };","title":"138. copy list with random pointer"},{"location":"_problems/_leetcode/139/","text":"\u7ed9\u5b9a\u975e\u7a7a\u5b57\u7b26\u4e32 s \u548c\u5305\u542b\u975e\u7a7a\u5355\u8bcd\u7684\u5217\u8868 wordDict \uff0c\u5224\u5b9a s \u662f\u5426\u53ef\u4ee5\u88ab\u7a7a\u683c\u62c6\u5206\u4e3a\u4e00\u4e2a\u6216\u591a\u4e2a\u5728\u5b57\u5178\u4e2d\u51fa\u73b0\u7684\u5355\u8bcd\u3002Note: \u62c6\u5206\u65f6\u53ef\u4ee5\u91cd\u590d\u4f7f\u7528\u5b57\u5178\u4e2d\u7684\u5355\u8bcd \u53ef\u4ee5\u5047\u8bbe\u5b57\u5178\u4e2d\u6ca1\u6709\u91cd\u590d\u7684\u5355\u8bcd Example1: \u8f93\u5165: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"] \u8f93\u51fa: true Example2: \u8f93\u5165: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] \u8f93\u51fa: false Note: 1 <= s.length <= 300 1 <= wordDict.length <= 1000 all the strings of wordDict are unique (Medium) dp[i] \u8868\u793a s[0...i) \u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\uff0c\u5219 dp[i] = V{ dp[j] && match(s[0...j)) } \uff0c\u82e5 match \u4e3a $O(1)$\uff0c\u5219\u9700\u8981\u65f6\u95f4 $O(n^2)$\uff0c\u5b9e\u73b0 match \u7684\u65b9\u5f0f: \u76f4\u63a5 hashmap(string) \u4f7f\u7528 trie\uff0c\u98a0\u5012 wordDict \u4e2d\u7684\u5355\u8bcd\uff0c j \u4ece\u540e\u5411\u524d\u5728 trie \u4e2d\u5339\u914d\uff0c\u7406\u8bba\u4e0a\u65f6\u95f4\u548c\u7a7a\u95f4\u90fd\u8981\u4f18\u4e8e hashmap solution dp + trie (no gc) class Trie { private : struct TrieNode { vector < TrieNode *> children ; bool isEnd ; TrieNode () : children ( 26 ), isEnd ( false ) { } }; TrieNode * root ; TrieNode * _nextNode ( char c , TrieNode * curNodePtr ) { int idx = c - 'a' ; if ( curNodePtr -> children [ idx ] == nullptr ) return nullptr ; return curNodePtr -> children [ idx ]; } public : Trie () : root ( new TrieNode ()) { } void insert ( string word ) { TrieNode * curNodePtr = root ; for ( int i = word . size () - 1 ; i >= 0 ; -- i ) { int idx = word [ i ] - 'a' ; if ( curNodePtr -> children [ idx ] == nullptr ) curNodePtr -> children [ idx ] = new TrieNode (); curNodePtr = curNodePtr -> children [ idx ]; } curNodePtr -> isEnd = true ; } bool trieWordBreak ( string s ) { vector < bool > dp ( s . size () + 1 ); dp [ 0 ] = true ; for ( int i = 1 ; i <= s . size (); ++ i ) { int j = i - 1 ; TrieNode * curNodePtr = root ; while ( j >= 0 ) { curNodePtr = _nextNode ( s [ j ], curNodePtr ); if ( curNodePtr == nullptr || j < 0 ) break ; if ( curNodePtr -> isEnd && dp [ j ]) { dp [ i ] = true ; break ; } -- j ; } } return dp . back (); } }; class Solution { public : bool wordBreak ( string s , vector < string > & wordDict ) { Trie wordDictTree ; for ( string & word : wordDict ) { wordDictTree . insert ( word ); } return wordDictTree . trieWordBreak ( s ); } }; dp + trie (auto gc) class Trie { private : struct TrieNode { vector < unique_ptr < TrieNode >> children ; bool isEnd ; TrieNode () : children ( 26 ), isEnd ( false ) { } }; unique_ptr < TrieNode > root ; TrieNode * _nextNode ( char c , TrieNode * curNodePtr ) { int idx = c - 'a' ; if ( curNodePtr -> children [ idx ] == nullptr ) return nullptr ; return curNodePtr -> children [ idx ]. get (); } public : Trie () : root ( new TrieNode ()) { } void insert ( string word ) { TrieNode * curNodePtr = root . get (); for ( int i = word . size () - 1 ; i >= 0 ; -- i ) { int idx = word [ i ] - 'a' ; if ( curNodePtr -> children [ idx ] == nullptr ) curNodePtr -> children [ idx ]. reset ( new TrieNode ()); curNodePtr = curNodePtr -> children [ idx ]. get (); } curNodePtr -> isEnd = true ; } bool trieWordBreak ( string s ) { vector < bool > dp ( s . size () + 1 ); dp [ 0 ] = true ; for ( int i = 1 ; i <= s . size (); ++ i ) { int j = i - 1 ; TrieNode * curNodePtr = root . get (); while ( j >= 0 ) { curNodePtr = _nextNode ( s [ j ], curNodePtr ); if ( curNodePtr == nullptr || j < 0 ) break ; if ( curNodePtr -> isEnd && dp [ j ]) { dp [ i ] = true ; break ; } -- j ; } } return dp . back (); } }; class Solution { public : bool wordBreak ( string s , vector < string > & wordDict ) { Trie wordDictTree ; for ( string & word : wordDict ) { wordDictTree . insert ( word ); } return wordDictTree . trieWordBreak ( s ); } }; dp + hashmap class Solution { public : bool wordBreak ( string s , vector < string >& wordDict ) { unordered_set < string > wordDictSet ( wordDict . begin (), wordDict . end ()); vector < bool > dp ( s . size () + 1 ); dp [ 0 ] = true ; for ( int i = 1 ; i <= s . size (); ++ i ) { for ( int j = i - 1 ; j >= 0 ; -- j ) { if ( ! dp [ j ]) continue ; if ( wordDictSet . count ( s . substr ( j , i - j )) == 1 ) { dp [ i ] = true ; break ; } } } return dp . back (); } }; \u5339\u914d trie \u7684\u5faa\u73af\u600e\u4e48\u5199","title":"139. word break"},{"location":"_problems/_leetcode/140/","text":"\u5728\u5355\u8bcd\u62c6\u5206\u7684\u57fa\u7840\u4e0a\uff0c\u6c42\u51fa\u6240\u6709\u53ef\u80fd\u7684\u89e3 \u62c6\u5206\u65f6\u53ef\u4ee5\u91cd\u590d\u4f7f\u7528\u5b57\u5178\u4e2d\u7684\u5355\u8bcd \u53ef\u4ee5\u5047\u8bbe\u5b57\u5178\u4e2d\u6ca1\u6709\u91cd\u590d\u7684\u5355\u8bcd Example: \u8f93\u5165: s = \"pineapplepenapple\" wordDict = [\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"] \u8f93\u51fa: [ \"pine apple pen apple\", \"pineapple pen apple\", \"pine applepen apple\" ] Note: 1 <= s.length <= 20 1 <= wordDict.length <= 1000 all the strings of wordDict are unique (Hard) \u56de\u987e \u5355\u8bcd\u5212\u5206 \u7684\u505a\u6cd5: dp[i] \u8868\u793a\u5b57\u7b26\u4e32 [0, i) \u662f\u5426\u53ef\u5212\u5206 dp[i] = V { dp[j] && exist(s[j...i)) } \uff0c dp[0] = true \u4f7f\u7528 hashmap / trie \u67e5\u627e\u5355\u8bcd \u8003\u8651\u7528\u81ea\u5e95\u5411\u4e0a\u505a: dp[i] \u5b58\u4e00\u4e2a vector<int> \uff0c\u56de\u5934\u8fd8\u5f97\u904d\u5386\u6811\u7ed3\u6784\u6784\u5efa\u89e3 dp[i] \u76f4\u63a5\u5b58 vector<string> \uff0c\u65e0\u7528\u7684 dp[i] \u6d6a\u8d39\u7a7a\u95f4 \u56e0\u6b64\u8fd8\u662f\u81ea\u9876\u5411\u4e0b + \u8bb0\u5fc6\u5316\u641c\u7d22\u597d solution class Trie { private : struct TrieNode { vector < TrieNode *> children ; bool isEnd ; TrieNode () : children ( 26 ), isEnd ( false ) { } }; TrieNode * root ; public : Trie () : root ( new TrieNode ()) { } void insertInReverse ( string word ) { TrieNode * node = root ; for ( int i = word . size () - 1 ; i >= 0 ; -- i ) { int idx = word [ i ] - 'a' ; if ( node -> children [ idx ] == nullptr ) node -> children [ idx ] = new TrieNode (); node = node -> children [ idx ]; } node -> isEnd = true ; } vector < string > wordBreak ( string s ) { vector < vector < string >> memo ( s . size () + 1 ); return _wordBreakSubProcess ( s , s . size (), memo ); } vector < string > _wordBreakSubProcess ( string s , int i , vector < vector < string >>& memo ) { if ( i == 0 ) return { \"\" }; if ( memo [ i ]. size () != 0 ) return memo [ i ]; int j = i - 1 ; vector < string > res ; TrieNode * node = root ; while ( j >= 0 ) { int idx = s [ j ] - 'a' ; node = node -> children [ idx ]; if ( node == nullptr ) break ; if ( node -> isEnd ) { auto resJ = _wordBreakSubProcess ( s , j , memo ); if ( resJ . size () != 0 ) { for ( int k = 0 ; k < resJ . size (); ++ k ) { if ( resJ [ k ]. size () != 0 ) resJ [ k ] += \" \" ; resJ [ k ] += s . substr ( j , i - j ); } res . insert ( res . end (), resJ . begin (), resJ . end ()); } } -- j ; } memo [ i ] = res ; return res ; } }; class Solution { public : vector < string > wordBreak ( string s , vector < string > & wordDict ) { Trie trie ; for ( string word : wordDict ) trie . insertInReverse ( word ); return trie . wordBreak ( s ); } }; \u8003\u8651\u6700\u574f\u60c5\u51b5: s = \"aaa...aaa\" wordDict = [\"a\", \"aa\", ... ,\"aaa...aaa\"] \u9700\u8981 $O(n\\cdot 2^n)$ \u7684\u7a7a\u95f4\uff0c\u76f8\u5e94\u7684\u6700\u5c11\u4e5f\u8981 $O(n\\cdot 2^n)$ \u7684\u65f6\u95f4","title":"140. word break ii"},{"location":"_problems/_leetcode/143/","text":"\u5c06\u94fe\u8868 L0 \u2192 L1 \u2192 \u2026 \u2192 Ln-1 \u2192 Ln \u91cd\u6392\u4e3a L0 \u2192 Ln \u2192 L1 \u2192 Ln-1 \u2192 L2 \u2192 Ln-2 \u2192 \u2026 Example: \u8f93\u5165: head = [1,2,3,4,5] \u8f93\u51fa: [1,5,2,4,3] Note: 1 <= linkedlist.length <= 5x10^4 (Medium) \u5982\u679c\u53ef\u4ee5\u4f7f\u7528\u8f85\u52a9\u7a7a\u95f4 \u5c06\u94fe\u8868\u7ed3\u70b9\u5b58\u5165\u6570\u7ec4\u4e2d\uff0c\u76f4\u63a5\u64cd\u4f5c \u5c06\u4e2d\u70b9\u540e\u7684\u7ed3\u70b9\u5b58\u5165\u6808\u4e2d\uff0c\u518d\u904d\u5386 \u4f46\u5b58\u5728\u65f6\u95f4 $O(n)$ \u7a7a\u95f4 $O(1)$ \u7684\u65b9\u6cd5: \u5bfb\u627e\u4e2d\u70b9 + \u9006\u5e8f\u540e\u4e00\u534a\u94fe\u8868 + \u5408\u5e76\u94fe\u8868 solution class Solution { public : void reorderList ( ListNode * head ) { ListNode * midNode = findMiddleNode ( head ); ListNode * newHead = reverseList ( midNode -> next ); midNode -> next = nullptr ; mergeList ( head , newHead ); } ListNode * findMiddleNode ( ListNode * head ) { ListNode * slow = head , * fast = head -> next ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } ListNode * reverseList ( ListNode * head ) { ListNode * lastNode = nullptr ; while ( head ) { ListNode * nextNode = head -> next ; head -> next = lastNode ; lastNode = head ; head = nextNode ; } return lastNode ; } void mergeList ( ListNode * first , ListNode * second ) { while ( second ) { ListNode * firstNext = first -> next ; ListNode * secondNext = second -> next ; first -> next = second ; second -> next = firstNext ; first = firstNext ; second = secondNext ; } } };","title":"143. reorder list"},{"location":"_problems/_leetcode/15/","text":"\u627e\u51fa\u6570\u7ec4 nums \u4e2d\u6240\u6709\u548c\u4e3a 0 \u4e14\u4e0d\u91cd\u590d\u7684\u4e09\u5143\u7ec4 Note: 0 <= numbers.length <= 3000 (Medium) \u4e0d\u7ba1\u662f\u76f4\u63a5\u4e09\u91cd\u5faa\u73af\u679a\u4e3e\u8fd8\u662f\u4f7f\u7528 1.\u4e24\u6570\u4e4b\u548c \u7684\u65b9\u6cd5\uff0c\u53bb\u91cd\u90fd\u5f88\u9ebb\u70e6 (hashmap) \u9996\u5148\uff0c\u5728\u300c\u7ec4\u5408\u300d\u7684\u610f\u4e49\u4e0a\u53bb\u91cd\uff0c\u5fc5\u7136\u9700\u8981\u5148\u6392\u5e8f\u518d\u679a\u4e3e \u6392\u597d\u5e8f\u540e\uff0c\u8981\u907f\u514d\u76f8\u540c\u5143\u7d20\u5e26\u6765\u7684\u91cd\u590d\uff0c\u548c\u5168\u6392\u5217\u7684\u601d\u8def\u4e00\u6837 (\u56e0\u4e3a\u5f71\u54cd\u91cd\u590d\u7684\u65b9\u5f0f\u90fd\u4e00\u6837)\uff0c\u8ba9\u540c\u4e00\u5143\u7d20\u5728\u4e00\u4e2a\u4f4d\u7f6e\u53ea\u80fd\u51fa\u73b0\u4e00\u6b21 \u8fd9\u6837\u601d\u8def\u5c31\u5f88\u660e\u786e\uff0c\u5148\u56fa\u5b9a\u4e00\u4e2a\u6570\uff0c\u518d\u7528\u53cc\u6307\u9488\u6c42\u4e24\u6570\u4e4b\u548c\uff0c\u8df3\u8dc3\u91cd\u590d\u5143\u7d20\u53bb\u91cd solution class Solution { public : vector < vector < int >> threeSum ( vector < int >& nums ) { sort ( nums . begin (), nums . end ()); vector < vector < int >> res ; for ( int pin = 0 ; pin < nums . size (); pin = next ( pin , nums . size () - 1 , nums )) { int i = pin + 1 , j = nums . size () - 1 ; while ( i < j ) { int s = nums [ i ] + nums [ j ]; if ( s > - nums [ pin ]) { j = last ( j , 0 , nums ); } else if ( s < - nums [ pin ]) { i = next ( i , nums . size () - 1 , nums ); } else { res . push_back ({ nums [ pin ], nums [ i ], nums [ j ]}); i = next ( i , nums . size () - 1 , nums ); j = last ( j , 0 , nums ); } } } return res ; } int next ( int ptr , int right_end , vector < int >& nums ) { int i = ptr ; while ( i != right_end + 1 && nums [ i ] == nums [ ptr ]) ++ i ; return i ; } int last ( int ptr , int left_end , vector < int >& nums ) { int i = ptr ; while ( i != left_end - 1 && nums [ i ] == nums [ ptr ]) -- i ; return i ; } }; \u5982\u679c\u8f93\u5165\u4fdd\u8bc1\u6ca1\u6709\u91cd\u590d\u5143\u7d20\uff0c\u76f4\u63a5\u7528 1.\u4e24\u6570\u4e4b\u548c \u7684\u65b9\u6cd5\u8c8c\u4f3c\u4e5f\u8fd8\u4e0d\u9519","title":"15. three sum"},{"location":"_problems/_leetcode/152_maximum_product_subarray/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u8bf7\u4f60\u627e\u51fa\u6570\u7ec4\u4e2d\u4e58\u79ef\u6700\u5927\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\uff08\u8be5\u5b50\u6570\u7ec4\u4e2d\u81f3\u5c11\u5305\u542b\u4e00\u4e2a\u6570\u5b57\uff09\uff0c\u5e76\u8fd4\u56de\u8be5\u5b50\u6570\u7ec4\u6240\u5bf9\u5e94\u7684\u4e58\u79ef\u3002 Example1: \u8f93\u5165: [2,3,-2,4] \u8f93\u51fa: 6 \u89e3\u91ca: \u5b50\u6570\u7ec4 [2,3] \u6709\u6700\u5927\u4e58\u79ef 6\u3002 Example2 \u8f93\u5165: [-2,0,-1] \u8f93\u51fa: 0 \u89e3\u91ca: \u7ed3\u679c\u4e0d\u80fd\u4e3a 2, \u56e0\u4e3a [-2,-1] \u4e0d\u662f\u5b50\u6570\u7ec4\u3002 Note: 1 <= nums.length <= 2 * 10^4 -10 <= nums[i] <= 10 The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer \u4ee4 $dp_{max}[i]$ \u4ee5 $\\mathrm{nums}[i]$ \u7ed3\u5c3e\u7684\u6700\u5927\u4e58\u79ef\u5b50\u6570\u7ec4\uff0c$dp_{min}[i]$ \u540c\u7406\uff0c\u5219: $$ \\begin{aligned} &\\mathsf{if}\\ \\mathrm{nums}[i] \\geq 0 \\\\ &\\qquad dp_{max}[i] = \\max\\lbrace dp_{max}[i-1] \\times \\mathrm{nums}[i],\\enspace \\mathrm{nums}[i] \\rbrace \\\\ &\\qquad dp_{min}[i] = \\min\\lbrace dp_{min}[i-1] \\times \\mathrm{nums}[i],\\enspace \\mathrm{nums}[i] \\rbrace \\\\ &\\mathsf{else} \\\\ &\\qquad dp_{max}[i] = \\max\\lbrace dp_{min}[i-1] \\times \\mathrm{nums}[i],\\enspace \\mathrm{nums}[i] \\rbrace \\\\ &\\qquad dp_{min}[i] = \\min\\lbrace dp_{max}[i-1] \\times \\mathrm{nums}[i],\\enspace \\mathrm{nums}[i] \\rbrace \\\\ \\end{aligned} $$ solution public int maxProduct ( int [] nums ) { int maxPro = nums [ 0 ] , minPro = nums [ 0 ] ; int m = maxPro ; for ( int i = 1 ; i < nums . length ; ++ i ) { if ( nums [ i ] >= 0 ) { maxPro = Math . max ( maxPro * nums [ i ] , nums [ i ] ); minPro = Math . min ( minPro * nums [ i ] , nums [ i ] ); } else { int tMaxPro = Math . max ( minPro * nums [ i ] , nums [ i ] ); minPro = Math . min ( maxPro * nums [ i ] , nums [ i ] ); maxPro = tMaxPro ; } m = Math . max ( m , maxPro ); } return m ; }","title":"152. maximum product subarray"},{"location":"_problems/_leetcode/155/","text":"\u8bbe\u8ba1\u4e00\u4e2a\u652f\u6301\u5e38\u89c4\u6808\u64cd\u4f5c ( push , pop , top ) \u4e14\u65f6\u95f4\u590d\u6742\u5ea6\u4e0d\u53d8\uff0c\u5e76\u989d\u5916\u652f\u6301\u5e38\u6570\u65f6\u95f4\u6c42\u6808\u4e2d\u6700\u5c0f\u503c\u7684\u6808\u3002 Example: \u8f93\u5165\uff1a [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] \u8f93\u51fa\uff1a[null,null,null,null,-3,null,0,-2] Note: -2^31 <= val <= 2^31-1 pop , top , getMin \u6c38\u8fdc\u5728\u975e\u7a7a\u6808\u4e0a\u8c03\u7528 (Easy) \u8f85\u52a9\u6808\u8bb0\u5f55\u72b6\u6001 solution class MinStack { public : /** initialize your data structure here. */ MinStack () { } void push ( int val ) { if ( valStack . empty ()) minValStack . push ( val ); else minValStack . push ( std :: min ( val , minValStack . top ())); valStack . push ( val ); } void pop () { valStack . pop (); minValStack . pop (); } int top () { return valStack . top (); } int getMin () { return minValStack . top (); } private : stack < int > valStack ; stack < int > minValStack ; };","title":"155. min stack"},{"location":"_problems/_leetcode/16/","text":"\u627e\u51fa nums \u4e2d\u7684\u4e09\u4e2a\u6574\u6570\uff0c\u5b83\u4eec\u4e09\u4e2a\u7684\u548c\u4e0e target \u6700\u63a5\u8fd1\uff0c\u8fd4\u56de\u8fd9\u4e2a\u548c Example: \u8f93\u5165\uff1anums = [-1,2,1,-4], target = 1 \u8f93\u51fa\uff1a2 \u89e3\u91ca\uff1a\u4e0e target \u6700\u63a5\u8fd1\u7684\u548c\u662f 2 (-1 + 2 + 1 = 2) \u3002 Note: 1 <= nums.length <= 1000 (Medium) \u548c 15. \u4e09\u6570\u4e4b\u548c \u51e0\u4e4e\u4e00\u6837\uff0c\u7565\u6709\u533a\u522b \u53ea\u9700\u8981\u6c42\u548c\uff0c\u4e0d\u9700\u8981\u53bb\u91cd \u53cc\u6307\u9488\u4f9d\u7136\u9002\u7528\u6c42\u6709\u5e8f\u6570\u7ec4\u7684\u4e24\u6570\u4e4b\u6700\u63a5\u8fd1\u548c\uff0c\u8bc1\u660e\u601d\u8def\u4e5f\u4e00\u6837 solution class Solution { public : int threeSumClosest ( vector < int >& nums , int target ) { int diff = 10000000 ; sort ( nums . begin (), nums . end ()); for ( int pin = 0 ; pin < nums . size () - 2 ; ++ pin ) { int sub_target = target - nums [ pin ]; int i = pin + 1 , j = nums . size () - 1 ; while ( i < j ) { int s_ij = nums [ i ] + nums [ j ]; if ( abs ( s_ij - sub_target ) < abs ( diff )) diff = s_ij - sub_target ; if ( s_ij < sub_target ) ++ i ; else if ( s_ij > sub_target ) -- j ; else return target ; } } return target + diff ; } private : int abs ( int a ) { return a > 0 ? a : - a ; } };","title":"16. three sum closet"},{"location":"_problems/_leetcode/162/","text":"\u5cf0\u503c\u5143\u7d20\u662f\u6307\u5176\u503c\u4e25\u683c\u5927\u4e8e\u5de6\u53f3\u76f8\u90bb\u503c\u7684\u5143\u7d20\u3002 \u7ed9\u5b9a\u6570\u7ec4 nums \uff0c\u8fd4\u56de\u5cf0\u503c\u5143\u7d20\u7d22\u5f15\u3002\u5982\u679c\u6709\u591a\u4e2a\u5cf0\u503c\uff0c\u8fd4\u56de\u4efb\u610f\u4e00\u4e2a\u7d22\u5f15\u5747\u53ef\u3002 \u53ef\u4ee5\u5047\u8bbe nums[-1] = nums[n] = -\u221e Example1: \u8f93\u5165\uff1anums = [1,2,1,3,5,6,4] \u8f93\u51fa\uff1a1 \u6216 5 Note: 1 <= nums.length <= 1000 -2^31 <= nums[i] <= 2^31-1 (Medium) \u9700\u8981\u7406\u89e3\u300c\u5bf9\u4efb\u610f\u533a\u95f4 [l, r] \uff0c\u53ea\u8981\u6ee1\u8db3 nums[l-1] < nums[l] && nums[r+1] < nums[r] \uff0c [l, r] \u4e2d\u4e00\u5b9a\u6709\u5cf0\u503c\u300d\uff0c\u5269\u4e0b\u7684\u662f\u57fa\u672c\u7684\u4e8c\u5206\u601d\u8def: \u6700\u7ec8\u72b6\u6001: \u95ed\u533a\u95f4 [l, r] \uff0c\u4e14 l == r \uff0c\u8868\u793a\u5cf0\u503c\u7d22\u5f15 \u82e5 nums[mid + 1] > nums[mid] \uff0c\u5cf0\u503c\u4e00\u5b9a\u4f4d\u4e8e [mid+1, n-1] \u4e2d\uff0c\u5426\u5219\u4f4d\u4e8e [0, mid] \u4e2d \u533a\u95f4\u957f\u5ea6\u4e3a 2 \u6216 3 \u65f6\uff0c\u533a\u95f4\u7684\u5212\u5206\u5747\u6b63\u786e solution class Solution { public : int findPeakElement ( vector < int >& nums ) { int left = 0 , right = nums . size () - 1 ; // closed interval [left, right] while ( left < right ) { int mid = left + ( right - left ) / 2 ; if ( nums [ mid + 1 ] > nums [ mid ]) { left = mid + 1 ; } else { right = mid ; } } return left ; } };","title":"162. find peak element"},{"location":"_problems/_leetcode/165/","text":"\u6bd4\u8f83\u4e24\u4e2a\u7248\u672c\u53f7 version1 \u548c version2 \u3002\u7248\u672c\u53f7\u7684\u5b9a\u4e49: \u7248\u672c\u53f7\u7531\u4e00\u4e2a\u6216\u591a\u4e2a\u4fee\u8ba2\u53f7\u6784\u6210\uff0c\u4fee\u8ba2\u53f7\u4e4b\u95f4\u4ee5 . \u8fde\u63a5\uff0c\u4e14\u81f3\u5c11\u6709\u4e00\u4e2a\u4fee\u8ba2\u53f7 \u7248\u672c\u53f7\u4e0d\u4ee5 . \u5f00\u5934\u6216\u7ed3\u5c3e \u4fee\u8ba2\u53f7\u53ef\u80fd\u5305\u542b\u524d\u5bfc 0\uff0c\u4fee\u8ba2\u53f7\u7684\u503c\u6309\u5ffd\u7565\u524d\u5bfc 0 \u7684\u6574\u6570\u503c\u7b97 \u7248\u672c\u53f7\u5927\u5c0f\u8981\u4f9d\u6b21\u6bd4\u8f83\u4fee\u8ba2\u53f7\u7684\u5927\u5c0f\uff0c\u82e5\u67d0\u4e2a\u7248\u672c\u53f7\u4fee\u8ba2\u53f7\u8f83\u5c11\uff0c\u7a7a\u51fa\u7684\u4f4d\u7f6e\u6309 0 \u7b97 \u8fd4\u56de\u89c4\u5219: \u5982\u679c version1 > version2 \uff0c\u8fd4\u56de 1 \u5982\u679c version1 < version2 , \u8fd4\u56de -1 \u5426\u5219\uff0c\u8fd4\u56de 0 Example1: \u8f93\u5165\uff1aversion1 = \"1.01\", version2 = \"1.001\" \u8f93\u51fa\uff1a0 Example2 \u8f93\u5165\uff1aversion1 = \"1.2\", version2 = \"1.10\" \u8f93\u51fa: 0 Note: version1 \u548c version2 \u90fd\u662f\u6709\u6548\u7248\u672c\u53f7 \u4fee\u8ba2\u53f7\u7684\u5927\u5c0f\u53ef\u4ee5\u5bb9\u7eb3\u5728 32-bit integer \u4e2d (Medium) \u6a21\u62df\uff0c\u5199\u7684\u597d\u770b\u4e0d\u592a\u5bb9\u6613 solution class Solution { public : int compareVersion ( string version1 , string version2 ) { int v1i = 0 , v2i = 0 ; const int M = version1 . size (), N = version2 . size (); while ( v1i < M || v2i < N ) { int val1 = 0 ; for (; v1i < M && version1 [ v1i ] != '.' ; ++ v1i ) val1 = val1 * 10 + version1 [ v1i ] - '0' ; ++ v1i ; int val2 = 0 ; for (; v2i < N && version2 [ v2i ] != '.' ; ++ v2i ) val2 = val2 * 10 + version2 [ v2i ] - '0' ; ++ v2i ; if ( val1 != val2 ) return val1 > val2 ? 1 : -1 ; } return 0 ; } };","title":"165. compare version numbers"},{"location":"_problems/_leetcode/166/","text":"\u7ed9\u5b9a\u4e24\u4e2a\u6574\u6570: \u5206\u5b50 numerator \u548c\u5206\u6bcd denominator \uff0c\u4ee5\u5b57\u7b26\u4e32\u5f62\u5f0f\u8fd4\u56de\u5176\u5c0f\u6570\u5f62\u5f0f\uff0c\u5faa\u73af\u90e8\u5206\u9700\u8981\u7528\u62ec\u53f7\u6269\u51fa\u3002 Example: \u8f93\u5165\uff1anumerator = 4, denominator = 333 \u8f93\u51fa\uff1a\"0.(012)\" Note: -2^31 <= numerator, denominator <= 2^31-1 denominator != 0 (Medium) \u9996\u5148: \u6709\u7406\u6570\u7ed3\u679c\u53ef\u80fd\u4e3a\u6709\u9650\u5c0f\u6570\u6216\u65e0\u9650\u5faa\u73af\u5c0f\u6570\uff0c\u5faa\u73af\u8d77\u59cb\u4f4d\u4e0d\u4e00\u5b9a\u5728\u54ea \u957f\u9664\u6cd5\u5148\u83b7\u5f97\u6574\u6570\u90e8\u5206\uff0c\u7136\u540e\u6bcf\u4e00\u8f6e\u90fd x10 \u505a\u9664\u6cd5\u5f97\u5c0f\u6570\u4f4d \u9700\u8981\u8003\u8651\u7684\u7279\u6b8a\u60c5\u51b5: \u7ed3\u679c\u4e3a \u6574\u6570 (\u4e0d\u5e26 . )\u3001\u666e\u901a\u5c0f\u6570\u3001\u65e0\u9650\u5faa\u73af\u5c0f\u6570\u30010 (\u4e0d\u5e26 - ) numerator \u548c denominator \u53ef\u80fd\u5bfc\u81f4\u8d8a\u754c numerator \u548c denominator \u5176\u4e2d\u4e00\u4e2a\u4e3a\u8d1f\u6216\u4e24\u4e2a\u90fd\u4e3a\u8d1f (\u5f02\u6216) solution class Solution { public : string fractionToDecimal ( int numerator1 , int denominator1 ) { string res ; long numerator = numerator1 ; long denominator = denominator1 ; if (( numerator ^ denominator ) < 0 && numerator != 0 ) res += \"-\" ; numerator = abs ( numerator ); denominator = abs ( denominator ); res += to_string ( numerator / denominator ); numerator = numerator % denominator ; if ( numerator != 0 ) { res += \".\" ; unordered_map < int , int > denom2idx ; int idx = res . size (); while ( numerator != 0 ) { numerator *= 10 ; if ( denom2idx . count ( numerator ) == 1 ) { res . insert ( res . begin () + denom2idx [ numerator ], '(' ); res += \")\" ; break ; } denom2idx [ numerator ] = idx ++ ; res += to_string ( numerator / denominator ); numerator = numerator % denominator ; } } return res ; } };","title":"166. fraction to recurring decimal"},{"location":"_problems/_leetcode/167/","text":"\u7ed9\u5b9a\u5347\u5e8f\u6392\u5217\u7684\u6570\u7ec4 numbers \uff0c\u627e\u51fa\u548c target \u7684\u4e24\u4e2a\u5143\u7d20\uff0c\u5047\u8bbe\u7b54\u6848\u552f\u4e00 Note: 2 <= numbers.length <= 3*10^4 (Easy) \u7ecf\u5178\u53cc\u6307\u9488\u95ee\u9898\uff0c\u8bc1\u660e\u7684\u8fc7\u7a0b: \u5047\u8bbe nums[i'] + nums[j'] \u662f\u7b2c\u4e00\u4e2a\u89e3\uff0c\u5219\u5fc5\u7136\u6709 i \u5148\u5230 i' \u6216 j \u5148\u5230 j' \uff0c\u4e0d\u7ba1\u8c01\u5148\u5230\uff0c\u5269\u4e0b\u7684\u8fc7\u7a0b\u5c31\u662f\u540e\u5230\u7684\u90a3\u4e2a\u4e0d\u65ad\u79fb\u52a8\u7684\u8fc7\u7a0b \u9898\u76ee\u5047\u8bbe\u4e86\u89e3\u552f\u4e00\uff0c\u5982\u679c\u4e0d\u552f\u4e00\u4e14\u9700\u8981\u627e\u51fa\u6240\u6709\u7684\u8bdd\u5c31\u9700\u8981\u6ce8\u610f: \u5047\u8bbe\u627e\u5230\u4e86\u4e00\u4e2a\u89e3 nums[i] + nums[j] \uff0c\u90a3\u4e0b\u4e00\u4e2a\u89e3\u5fc5\u6709 i2 > i && j2 < j \u8c03\u7528 next(i) \u548c last(j) \u65f6\u9700\u8981\u6ce8\u610f\u8df3\u8fc7\u91cd\u590d\u5143\u7d20\uff0c\u4ee5\u53bb\u91cd solution class Solution { public : vector < int > twoSum ( vector < int >& numbers , int target ) { int i = 0 , j = numbers . size () - 1 ; while ( i != j ) { int s = numbers [ i ] + numbers [ j ]; if ( s > target ) -- j ; else if ( s < target ) ++ i ; else return { i + 1 , j + 1 }; } return { -1 , -1 }; } };","title":"167. two sum ii"},{"location":"_problems/_leetcode/179/","text":"\u7ed9\u5b9a\u975e\u8d1f\u6574\u6570\u6570\u7ec4 nums \uff0c\u91cd\u6392\u6bcf\u4e2a\u6570\u7684\u987a\u5e8f\uff0c\u4f7f\u4e4b\u7ec4\u6210\u4e00\u4e2a\u6700\u5927\u7684\u6574\u6570\u3002 Example: \u8f93\u5165\uff1anums = [3,30,34,5,9] \u8f93\u51fa\uff1a\"9534330\" Note: 1 <= nums.length <= 100 0 <= nums[i] <= 10^9 (Medium) \u5bf9\u6570\u7ec4\u6392\u5e8f\uff0c\u6392\u5e8f\u89c4\u5219: \u6309\u7b2c\u4e00\u4e2a\u6570\u5b57\u7531\u5927\u5230\u5c0f\u6392\u5e8f \u5982\u679c\u7b2c\u4e00\u4e2a\u6570\u5b57\u76f8\u540c\uff0c\u8fd8\u662f\u8981\u6bd4\u8f83\u62fc\u63a5\u7684\u7ed3\u679c (\u4f8b\u5982 34 > 3 > 30 ) \u6392\u5e8f\u51fd\u6570: \u5bf9\u9884\u671f\u6392\u5e8f\u4e2d\u4efb\u610f\u4e24\u4e2a\u76f8\u90bb\u5143\u7d20 a \u548c b ( a != b )\uff0c\u4ee3\u5165 cmp(param1=a, param2=b) \u7ed3\u679c\u4e3a true \u65f6\u95f4 $O(n\\log n\\log M)$\uff0c$M$ \u662f MAX_INT solution class Solution { public : string largestNumber ( vector < int > & nums ) { sort ( nums . begin (), nums . end (), []( const int & a , const int & b ) { long ax = 10 , bx = 10 ; while ( ax <= a ) ax *= 10 ; while ( bx <= b ) bx *= 10 ; return a * bx + b > b * ax + a ; }); if ( nums [ 0 ] == 0 ) return \"0\" ; string res = \"\" ; for ( int num : nums ) { res += to_string ( num ); } return res ; } };","title":"179. largest number"},{"location":"_problems/_leetcode/188_best_time_to_sell_stock_iv/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 prices \uff0c\u5b83\u7684\u7b2c i \u4e2a\u5143\u7d20 prices[i] \u8868\u793a\u4e00\u652f\u7ed9\u5b9a\u80a1\u7968\u7b2c i \u5929\u7684\u4ef7\u683c\u3002 \u8bbe\u8ba1\u4e00\u4e2a\u7b97\u6cd5\u6765\u8ba1\u7b97\u4f60\u6240\u80fd\u83b7\u53d6\u7684\u6700\u5927\u5229\u6da6\u3002\u4f60\u6700\u591a\u53ef\u4ee5\u5b8c\u6210 k \u7b14 \u4ea4\u6613 \u6ce8\u610f\uff1a\u4f60\u4e0d\u80fd\u540c\u65f6\u53c2\u4e0e\u591a\u7b14\u4ea4\u6613\uff08\u4f60\u5fc5\u987b\u5728\u518d\u6b21\u8d2d\u4e70\u524d\u51fa\u552e\u6389\u4e4b\u524d\u7684\u80a1\u7968\uff09 Example1: \u8f93\u5165\uff1ak = 2, prices = [2,4,1] \u8f93\u51fa\uff1a2 \u89e3\u91ca\uff1a\u5728\u7b2c 1 \u5929 (\u80a1\u7968\u4ef7\u683c = 2) \u7684\u65f6\u5019\u4e70\u5165\uff0c\u5728\u7b2c 2 \u5929 (\u80a1\u7968\u4ef7\u683c = 4) \u7684\u65f6\u5019\u5356\u51fa\uff0c\u8fd9\u7b14\u4ea4\u6613\u6240\u80fd\u83b7\u5f97\u5229\u6da6 = 4-2 = 2 \u3002 Example2: \u8f93\u5165\uff1ak = 2, prices = [3,2,6,5,0,3] \u8f93\u51fa\uff1a7 \u89e3\u91ca\uff1a\u5728\u7b2c 2 \u5929 (\u80a1\u7968\u4ef7\u683c = 2) \u7684\u65f6\u5019\u4e70\u5165\uff0c\u5728\u7b2c 3 \u5929 (\u80a1\u7968\u4ef7\u683c = 6) \u7684\u65f6\u5019\u5356\u51fa, \u8fd9\u7b14\u4ea4\u6613\u6240\u80fd\u83b7\u5f97\u5229\u6da6 = 6-2 = 4 \u3002 \u968f\u540e\uff0c\u5728\u7b2c 5 \u5929 (\u80a1\u7968\u4ef7\u683c = 0) \u7684\u65f6\u5019\u4e70\u5165\uff0c\u5728\u7b2c 6 \u5929 (\u80a1\u7968\u4ef7\u683c = 3) \u7684\u65f6\u5019\u5356\u51fa, \u8fd9\u7b14\u4ea4\u6613\u6240\u80fd\u83b7\u5f97\u5229\u6da6 = 3-0 = 3 \u3002 Note: 0 <= k <= 100 0 <= prices.length <= 1000 0 <= prices[i] <= 1000 \u5df2\u7528\u6b64\u6cd5\u505a\u8fc7 123. best time to sell stock iii \uff0c\u4e0d\u540c\u5728\u4e8e\u672c\u9898\u53ef\u4ee5\u6709 prices.length = 0 $$ \\begin{aligned} dp_0[i][j] &= \\max\\lbrace\\ dp_0[i - 1][j], \\enspace dp_1[i][j - 1] + prices[i]\\ \\rbrace \\\\ dp_1[i][j] &= \\max\\lbrace\\ dp_1[i - 1][j], \\enspace dp_0[i][j] - prices[i]\\ \\rbrace \\end{aligned} $$ solution public int maxProfit ( int k , int [] prices ) { int N = prices . length ; if ( N == 0 ) return 0 ; int [][] dp0 = new int [ N ][ k + 1 ] ; int [][] dp1 = new int [ N ][ k + 1 ] ; dp1 [ 0 ][ 0 ] = - prices [ 0 ] ; for ( int i = 1 ; i < N ; ++ i ) dp1 [ i ][ 0 ] = Math . max ( dp1 [ i - 1 ][ 0 ] , - prices [ i ] ); for ( int j = 1 ; j <= k ; ++ j ) { dp1 [ 0 ][ j ] = - prices [ 0 ] ; for ( int i = 1 ; i < N ; ++ i ) { dp0 [ i ][ j ] = Math . max ( dp0 [ i - 1 ][ j ] , dp1 [ i ][ j - 1 ] + prices [ i ] ); dp1 [ i ][ j ] = Math . max ( dp1 [ i - 1 ][ j ] , dp0 [ i ][ j ] - prices [ i ] ); } } return dp0 [ N - 1 ][ k ] ; }","title":"188. best time to sell stock iv"},{"location":"_problems/_leetcode/1894/","text":"\u4e00\u4e2a\u73ed\u7ea7\u91cc\u6709 n \u4e2a\u5b66\u751f\uff0c\u7f16\u53f7\u4e3a 0 \u5230 n - 1 \u3002\u6bcf\u4e2a\u5b66\u751f\u4f1a\u4f9d\u6b21\u56de\u7b54\u95ee\u9898\uff0c\u7f16\u53f7\u4e3a 0 \u7684\u5b66\u751f\u5148\u56de\u7b54\uff0c\u7136\u540e\u662f\u7f16\u53f7\u4e3a 1 \u7684\u5b66\u751f\uff0c\u4ee5\u6b64\u7c7b\u63a8\uff0c\u76f4\u5230\u7f16\u53f7\u4e3a n - 1 \u7684\u5b66\u751f\uff0c\u7136\u540e\u8001\u5e08\u4f1a\u91cd\u590d\u8fd9\u4e2a\u8fc7\u7a0b\uff0c\u91cd\u65b0\u4ece\u7f16\u53f7\u4e3a 0 \u7684\u5b66\u751f\u5f00\u59cb\u56de\u7b54\u95ee\u9898\u3002 \u7ed9\u4f60\u4e00\u4e2a\u957f\u5ea6\u4e3a n \u4e14\u4e0b\u6807\u4ece 0 \u5f00\u59cb\u7684\u6574\u6570\u6570\u7ec4 chalk \u548c\u4e00\u4e2a\u6574\u6570 k \u3002\u4e00\u5f00\u59cb\u7c89\u7b14\u76d2\u91cc\u603b\u5171\u6709 k \u652f\u7c89\u7b14\u3002\u5f53\u7f16\u53f7\u4e3a i \u7684\u5b66\u751f\u56de\u7b54\u95ee\u9898\u65f6\uff0c\u4ed6\u4f1a\u6d88\u8017 chalk[i] \u652f\u7c89\u7b14\u3002\u5982\u679c\u5269\u4f59\u7c89\u7b14\u6570\u91cf \u4e25\u683c\u5c0f\u4e8e chalk[i] \uff0c\u90a3\u4e48\u5b66\u751f i \u9700\u8981 \u8865\u5145 \u7c89\u7b14\u3002 \u8fd4\u56de\u9700\u8981\u8865\u5145\u7c89\u7b14\u7684\u5b66\u751f\u7f16\u53f7 Example: \u8f93\u5165\uff1achalk = [5,1,5], k = 22 \u8f93\u51fa\uff1a0 Note: 1 <= chalk.length <= 10^5 1 <= chalk[i] <= 10^5 (Medium) \u6807\u51c6\u7684\u524d\u7f00\u548c + \u4e8c\u5206\u3002\u4ee4 k' = k % sum(chalk) \uff0c\u5219 0 <= k' <= sum(chalk) - 1 \u7531\u9898\u610f\u53ef\u77e5\u9700\u8981\u4e8c\u5206\u67e5\u627e\u300c > value \u7684\u4e0b\u754c\u300d\uff0c\u5373 upper_bound \uff0c\u4e14\u8fd4\u56de\u7ed3\u679c\u4e00\u5b9a\u6709\u6548 (\u4e0d\u4f1a\u7b49\u4e8e chalk.size() ) solution class Solution { public : int chalkReplacer ( vector < int >& chalk , int k ) { vector < long > prefixSum ( chalk . size () + 1 ); prefixSum [ 0 ] = 0 ; for ( int i = 1 ; i < prefixSum . size (); ++ i ) { prefixSum [ i ] = chalk [ i - 1 ] + prefixSum [ i - 1 ]; } long lastK = k % prefixSum . back (); int res = upper_bound ( prefixSum . begin (), prefixSum . end (), lastK ) - prefixSum . begin () - 1 ; return res ; } };","title":"1894. find the student that will replace the chalk"},{"location":"_problems/_leetcode/198/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\u6570\u7ec4\uff0c\u4ee3\u8868\u4e00\u6392\u5b58\u6709\u91d1\u94b1\u7684\u5c0f\u5c4b\uff0c\u5c0f\u5077\u6cbf\u9014\u5077\u7a83\uff0c\u5982\u679c\u8fde\u7eed\u5077\u7a83\u4e24\u95f4\u76f8\u90bb\u7684\u5c0f\u5c4b\uff0c\u7cfb\u7edf\u4f1a\u81ea\u52a8\u62a5\u8b66\u3002\u6c42\u5c0f\u5077\u80fd\u5077\u5230\u7684\u6700\u9ad8\u91d1\u989d\u3002 Example: \u8f93\u5165\uff1a[200,1,1,200] \u8f93\u51fa\uff1a400 Note: 1 <= nums.length <= 100 (Medium) \u53ef\u4ee5\u8de8\u4e00\u5bb6\u6216\u8de8\u4e24\u5bb6\u5077 dp[i]: nums[i] \u88ab\u5077\u7684\u60c5\u51b5\u4e0b nums[0...i] \u80fd\u5077\u5230\u7684\u6700\u9ad8\u91d1\u989d dp[i] = max{dp[i-2], dp[i-3]} + nums[i] \u66f4\u597d\u7684\u5b9a\u4e49\u65b9\u5f0f: dp[i]: nums[0...i] \u80fd\u5077\u5230\u7684\u6700\u9ad8\u91d1\u989d\uff0c\u5219 dp[i] = max{\u5077nums[i]\u7684\u6700\u5927\u503c\uff0c\u4e0d\u5077nums[i]\u7684\u6700\u5927\u503c} dp[i] = max{ dp[i-1], dp[i-2] + nums[i] } solution class Solution { public : int rob ( vector < int >& nums ) { int n = nums . size () + 1 ; if ( n == 2 ) return nums [ 0 ]; vector < int > dp ( n ); dp [ 1 ] = nums [ 0 ]; dp [ 2 ] = nums [ 1 ]; for ( int i = 3 ; i <= nums . size (); ++ i ) { dp [ i ] = max ( dp [ i - 2 ], dp [ i - 3 ]) + nums [ i - 1 ]; } return max ( dp [ n - 1 ], dp [ n - 2 ]); } };","title":"198. house robbery"},{"location":"_problems/_leetcode/199/","text":"\u7ed9\u5b9a\u4e00\u68f5\u4e8c\u53c9\u6811\uff0c\u60f3\u8c61\u7ad9\u5728\u5b83\u7684\u53f3\u4fa7\uff0c\u6309\u7167\u4ece\u4e0a\u5230\u4e0b\u7684\u987a\u5e8f\uff0c\u8fd4\u56de\u80fd\u770b\u5230\u7684\u8282\u70b9\u503c\u3002 Example: \u8f93\u5165: [1,2,3,null,5,null,4] \u8f93\u51fa: [1,3,4] Note: \u8282\u70b9\u4e2a\u6570\u8303\u56f4 [0, 100] (Medium) \u5c42\u5e8f\u904d\u5386 solution class Solution { public : vector < int > rightSideView ( TreeNode * root ) { if ( ! root ) return {}; vector < int > res ; queue < TreeNode *> nodeQueue ; nodeQueue . push ( root ); while ( ! nodeQueue . empty ()) { int nodeNum = nodeQueue . size (); TreeNode * lastNode ; for ( int i = 0 ; i < nodeNum ; ++ i ) { lastNode = nodeQueue . front (); nodeQueue . pop (); if ( lastNode -> left ) nodeQueue . push ( lastNode -> left ); if ( lastNode -> right ) nodeQueue . push ( lastNode -> right ); } res . push_back ( lastNode -> val ); } return res ; } };","title":"199. binary tree right side view"},{"location":"_problems/_leetcode/2/","text":"\u7ed9\u4f60\u4e24\u4e2a \u975e\u7a7a \u7684\u94fe\u8868\uff0c\u8868\u793a\u4e24\u4e2a\u975e\u8d1f\u7684\u6574\u6570\u3002\u5b83\u4eec\u6bcf\u4f4d\u6570\u5b57\u90fd\u662f\u6309\u7167 \u9006\u5e8f \u7684\u65b9\u5f0f\u5b58\u50a8\u7684\uff0c\u5e76\u4e14\u6bcf\u4e2a\u8282\u70b9\u53ea\u80fd\u5b58\u50a8 \u4e00\u4f4d \u6570\u5b57 \u6c42\u94fe\u8868\u8868\u793a\u7684\u548c\uff0c\u53ef\u4ee5\u5047\u8bbe\u9664 0 \u672c\u8eab\u610f\u5916\uff0c\u4e24\u4e2a\u6570\u4e0d\u4ee5 0 \u5f00\u5934\u3002 Example: \u8f93\u5165\uff1al1 = [2,4,3], l2 = [5,6,4] 2->4->3 5->6->4 \u8f93\u51fa\uff1a[7,0,8] 7->0->8 \u89e3\u91ca\uff1a342 + 465 = 807. Note: 2 <= nums.length <= 10^4 -10^9 <= nums[i], target <= 10^9 \u53ea\u4f1a\u5b58\u5728\u4e00\u4e2a\u6709\u6548\u7b54\u6848 (Medium) \u767d\u7ed9\uff0c\u9700\u8981\u4ed4\u7ec6\u4e0e\u8010\u5fc3","title":"2. add two numbers"},{"location":"_problems/_leetcode/20/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u53ea\u5305\u62ec ( ) { } [ ] \u7684\u5b57\u7b26\u4e32 s \uff0c\u5224\u65ad\u5b57\u7b26\u4e32\u662f\u5426\u6709\u6548\u3002\u6709\u6548\u6709\u6c42\u62ec\u53f7\u5fc5\u987b\u4ee5\u6b63\u786e\u7684\u987a\u5e8f\u95ed\u5408\u3002 Example: \u8f93\u5165\uff1as = \"()[]{}\" \u8f93\u51fa\uff1atrue Note: 1 <= s.length <= 10^4 (Easy) \u5de6\u62ec\u53f7\u5165\u6808\uff0c\u53f3\u62ec\u53f7\u5339\u914d\u5373\u53ef\uff0cspecial case: \u53f3\u62ec\u53f7\u5339\u914d\u65f6\u53ef\u80fd\u6808\u7a7a\uff0c\u4f8b\u5982 []] solution class Solution { public : bool isValid ( string s ) { unordered_map < char , char > p_map = {{ '[' , ']' }, { '{' , '}' }, { '(' , ')' }}; stack < char > stack ; for ( char c : s ) { if ( isLeft ( c )) { stack . push ( c ); } else { if ( stack . empty ()) return false ; char t = stack . top (); if ( p_map [ t ] != c ) return false ; stack . pop (); } } return stack . empty (); } private : bool isLeft ( char c ) { return c == '(' || c == '[' || c == '{' ; } };","title":"20. valid parentheses"},{"location":"_problems/_leetcode/200_number_of_islands/","text":"\u7ed9\u4f60\u4e00\u4e2a\u7531 1 \uff08\u9646\u5730\uff09\u548c 0 \uff08\u6c34\uff09\u7ec4\u6210\u7684\u7684\u4e8c\u7ef4\u7f51\u683c\uff0c\u8bf7\u4f60\u8ba1\u7b97\u7f51\u683c\u4e2d\u5c9b\u5c7f\u7684\u6570\u91cf\u3002 \u5c9b\u5c7f\u603b\u662f\u88ab\u6c34\u5305\u56f4\uff0c\u5e76\u4e14\u6bcf\u5ea7\u5c9b\u5c7f\u53ea\u80fd\u7531\u6c34\u5e73\u65b9\u5411\u548c/\u6216\u7ad6\u76f4\u65b9\u5411\u4e0a\u76f8\u90bb\u7684\u9646\u5730\u8fde\u63a5\u5f62\u6210\u3002 \u6b64\u5916\uff0c\u4f60\u53ef\u4ee5\u5047\u8bbe\u8be5\u7f51\u683c\u7684\u56db\u6761\u8fb9\u5747\u88ab\u6c34\u5305\u56f4\u3002 Example1: \u8f93\u5165\uff1agrid = [ [\"1\",\"1\",\"1\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"0\",\"0\"] ] \u8f93\u51fa\uff1a1 Example2: \u8f93\u5165\uff1agrid = [ [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"1\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"1\",\"1\"] ] \u8f93\u51fa\uff1a3 Note: 1 <= grid.length, grid[0].length <= 300 (Medium) \u5982\u679c\u7528 DFS / BFS \u505a\u4e14\u53ef\u4ee5\u4fee\u6539\u539f\u6570\u7ec4\u7684\u8bdd\uff0c\u5728\u5168\u662f\u9646\u5730\u7684\u60c5\u51b5\u4e0b\u9700\u8981\u65f6\u95f4 $O(MN)$\uff0c\u7a7a\u95f4 $O(MN)$ / $O(\\min(M, N))$\u3002\u4f7f\u7528\u5e76\u67e5\u96c6\u4e0d\u9700\u8981\u989d\u5916\u4fee\u6539\u539f\u6570\u7ec4\uff0c\u65f6\u95f4\u7a7a\u95f4\u5747\u4e3a $O(MN)$ Solution class Solution { private int [] nodes , rank ; private int islandsNum = 0 ; public int numIslands ( char [][] grid ) { int M = grid . length , N = grid [ 0 ] . length ; nodes = new int [ M * N ] ; rank = new int [ M * N ] ; for ( int i = 0 ; i < M ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) { int nodeIdx = i * N + j ; if ( grid [ i ][ j ] == '1' ) { islandsNum ++ ; nodes [ nodeIdx ] = nodeIdx ; } } } for ( int i = 0 ; i < M ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) { if ( grid [ i ][ j ] == '0' ) continue ; if ( j != N - 1 && grid [ i ][ j + 1 ] == '1' ) union ( i * N + j , i * N + j + 1 ); if ( i != M - 1 && grid [ i + 1 ][ j ] == '1' ) union ( i * N + j , ( i + 1 ) * N + j ); } } return islandsNum ; } public void union ( int x , int y ) { int rx = find ( x ), ry = find ( y ); if ( rx == ry ) return ; if ( rank [ ry ] > rank [ rx ] ) nodes [ rx ] = ry ; else nodes [ ry ] = rx ; if ( rank [ rx ] == rank [ ry ] ) ++ rank [ rx ] ; islandsNum -- ; } public int find ( int x ) { return x == nodes [ x ] ? x : ( nodes [ x ] = find ( nodes [ x ] )); } }","title":"200. number of islands"},{"location":"_problems/_leetcode/206/","text":"\u7ed9\u5b9a\u94fe\u8868\u5934\uff0c\u53cd\u8f6c\u94fe\u8868\uff0c\u5e76\u8fd4\u56de\u53cd\u8f6c\u540e\u7684\u94fe\u8868 Note: \u94fe\u8868\u7ed3\u70b9\u6570\u76ee\u8303\u56f4 [0, 5000] (Easy) \u4ece\u5934\u7ed3\u70b9\u5f00\u59cb\uff0c\u6bcf\u6b21\u4f7f curr->next \u6307\u5411\u4e0a\u4e00\u8f6e\u7684\u5907\u9009\u7ed3\u70b9\u3002 solution class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = nullptr ; while ( head ) { ListNode * next = head -> next ; head -> next = prev ; prev = head ; head = next ; } return prev ; } };","title":"206. reverse linked list"},{"location":"_problems/_leetcode/207/","text":"\u4f60\u8fd9\u4e2a\u5b66\u671f\u5fc5\u987b\u9009\u4fee numCourses \u95e8\u8bfe\u7a0b\uff0c\u8bb0\u4e3a 0 \u5230 numCourses - 1 \u3002 \u5728\u9009\u4fee\u67d0\u4e9b\u8bfe\u7a0b\u4e4b\u524d\u9700\u8981\u4e00\u4e9b\u5148\u4fee\u8bfe\u7a0b\u3002 \u5148\u4fee\u8bfe\u7a0b\u6309\u6570\u7ec4 prerequisites \u7ed9\u51fa\uff0c\u5176\u4e2d prerequisites[i] = [ai, bi] \uff0c\u8868\u793a\u5982\u679c\u8981\u5b66\u4e60\u8bfe\u7a0b ai \u5219 \u5fc5\u987b \u5148\u5b66\u4e60\u8bfe\u7a0b bi \u3002 \u4f8b\u5982\uff0c\u5148\u4fee\u8bfe\u7a0b\u5bf9 [0, 1] \u8868\u793a\uff1a\u60f3\u8981\u5b66\u4e60\u8bfe\u7a0b 0 \uff0c\u4f60\u9700\u8981\u5148\u5b8c\u6210\u8bfe\u7a0b 1 \u3002 \u8bf7\u4f60\u5224\u65ad\u662f\u5426\u53ef\u80fd\u5b8c\u6210\u6240\u6709\u8bfe\u7a0b\u7684\u5b66\u4e60\uff1f\u5982\u679c\u53ef\u4ee5\uff0c\u8fd4\u56de true \uff1b\u5426\u5219\uff0c\u8fd4\u56de false \u3002 Example1: \u8f93\u5165\uff1anumCourses = 2, prerequisites = [[1,0],[0,1]] \u8f93\u51fa\uff1afalse \u89e3\u91ca\uff1a\u603b\u5171\u6709 2 \u95e8\u8bfe\u7a0b\u3002\u5b66\u4e60\u8bfe\u7a0b 1 \u4e4b\u524d\uff0c\u4f60\u9700\u8981\u5148\u5b8c\u6210\u200b\u8bfe\u7a0b 0 \uff1b\u5e76\u4e14\u5b66\u4e60\u8bfe\u7a0b 0 \u4e4b\u524d\uff0c\u4f60\u8fd8\u5e94\u5148\u5b8c\u6210\u8bfe\u7a0b 1 \u3002\u8fd9\u662f\u4e0d\u53ef\u80fd\u7684\u3002 Note: 1 <= numCourses <= 10^5, 0 <= prerequisites.length <= 5000 0 <= ai, bi < numCourses ai != bi \u4e14 prerequisites[i] \u4e2d\u7684\u6240\u6709\u8bfe\u7a0b\u5bf9 \u4e92\u4e0d\u76f8\u540c (Medium) \u7ecf\u5178\u62d3\u6251\u6392\u5e8f\u95ee\u9898\u3002\u9700\u8981\u6ce8\u610f \u5f88\u660e\u663e\u5e94\u8be5\u4f7f\u7528\u90bb\u63a5\u8868 Kahn class Solution { public boolean canFinish ( int numCourses , int [][] prerequisites ) { List < List < Integer >> graph = new ArrayList <> (); for ( int i = 0 ; i < numCourses ; ++ i ) { graph . add ( new ArrayList < Integer > ()); } int [] indegrees = new int [ numCourses ] ; for ( int i = 0 ; i < prerequisites . length ; ++ i ) { graph . get ( prerequisites [ i ][ 1 ] ). add ( prerequisites [ i ][ 0 ] ); indegrees [ prerequisites [ i ][ 0 ]]++ ; } Queue < Integer > queue = new LinkedList < Integer > (); for ( int i = 0 ; i < indegrees . length ; ++ i ) { if ( indegrees [ i ] == 0 ) { queue . offer ( i ); } } int visited = 0 ; while ( ! queue . isEmpty ()) { int bald = queue . poll (); visited ++ ; for ( int neighbor : graph . get ( bald )) { indegrees [ neighbor ]-- ; if ( indegrees [ neighbor ] == 0 ) { queue . offer ( neighbor ); } } } return visited == numCourses ; } } DFS class Solution { public boolean canFinish ( int numCourses , int [][] prerequisites ) { List < List < Integer >> graph = new ArrayList <> (); for ( int i = 0 ; i < numCourses ; ++ i ) { graph . add ( new ArrayList < Integer > ()); } for ( int i = 0 ; i < prerequisites . length ; ++ i ) { graph . get ( prerequisites [ i ][ 1 ] ). add ( prerequisites [ i ][ 0 ] ); } int [] nodeState = new int [ numCourses ] ; for ( int i = 0 ; i < numCourses ; ++ i ) { if ( nodeState [ i ] == 0 ) { if ( ! dfs ( graph , nodeState , i )) { return false ; } } } return true ; } public boolean dfs ( List < List < Integer >> graph , int [] nodeState , int node ) { nodeState [ node ] = - 1 ; for ( int neighbor : graph . get ( node )) { if ( nodeState [ neighbor ] == - 1 ) { return false ; } else if ( nodeState [ neighbor ] == 0 ) { if ( ! dfs ( graph , nodeState , neighbor )) { return false ; } } } nodeState [ node ] = 1 ; return true ; } }","title":"207. course schedule"},{"location":"_problems/_leetcode/208/","text":"\u5b9e\u73b0\u524d\u7f00\u6811 Trie \u7c7b: Trie() \u521d\u59cb\u5316\u524d\u7f00\u6811 void insert(string word) \u5411\u524d\u7f00\u6811\u63d2\u5165\u5355\u8bcd word bool search(string word) \u5982\u679c word \u5728\u524d\u7f00\u6811\u4e2d\uff0c\u8fd4\u56de true bool startsWith(string prefix) \u5982\u679c\u4e4b\u524d\u63d2\u5165\u8fc7\u7684\u67d0\u4e2a word \u7684\u524d\u7f00\u4e3a prefix \uff0c\u8fd4\u56de true Example: \u8f93\u5165 [\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"] [[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]] \u8f93\u51fa [null, null, true, false, true, null, true] Note: 1 <= word.length, prefix.length <= 2000 (Medium) solution class Trie { private : struct TrieNode { vector < unique_ptr < TrieNode >> children ; bool isEnd ; TrieNode () : children ( 26 ), isEnd ( false ) { } }; unique_ptr < TrieNode > root ; TrieNode * _searchPrefix ( string word ) { TrieNode * node = root . get (); for ( char c : word ) { int idx = c - 'a' ; if ( node -> children [ idx ] == nullptr ) { return nullptr ; } node = node -> children [ idx ]. get (); } return node ; } public : Trie () : root ( new TrieNode ()) { } void insert ( string word ) { TrieNode * node = root . get (); for ( char c : word ) { int idx = c - 'a' ; if ( node -> children [ idx ] == nullptr ) { node -> children [ idx ]. reset ( new TrieNode ()); } node = node -> children [ idx ]. get (); } node -> isEnd = true ; } bool search ( string word ) { TrieNode * node = _searchPrefix ( word ); return node && node -> isEnd ; } bool startsWith ( string prefix ) { return _searchPrefix ( prefix ); } };","title":"208. implement trie prefix tree"},{"location":"_problems/_leetcode/209/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u542b\u6709 n \u4e2a\u6b63\u6574\u6570\u7684\u6570\u7ec4\u548c\u4e00\u4e2a\u6574\u6570 target \uff0c\u627e\u51fa\u6570\u7ec4\u4e2d \u300c\u548c >= target \u7684\u8fde\u7eed\u5b50\u6570\u7ec4\u4e14\u957f\u5ea6\u6700\u5c0f\u300d\uff0c\u8fd4\u56de\u5176\u957f\u5ea6 Example: \u8f93\u5165\uff1atarget = 7, nums = [2,3,1,2,4,3] \u8f93\u51fa\uff1a2 \u89e3\u91ca\uff1a\u5b50\u6570\u7ec4 [4,3] \u662f\u8be5\u6761\u4ef6\u4e0b\u7684\u957f\u5ea6\u6700\u5c0f\u7684\u5b50\u6570\u7ec4\u3002 Note: 1 <= target <= 10^9 1 <= nums.length <= 10^5 (Medium) naive \u505a\u6cd5: \u4ece\u6bcf\u4e2a\u5143\u7d20\u5f00\u59cb\uff0c\u641c\u7d22\u6ee1\u8db3\u6761\u4ef6\u7684\u5b50\u6570\u7ec4\uff0c$O(n^2)$ \u7531\u4e8e\u6bcf\u4e2a\u5143\u7d20\u90fd\u4e3a\u6b63 \u524d\u7f00\u548c\u4f7f\u6570\u7ec4\u5347\u5e8f\uff0c\u901a\u8fc7 upper_bound - 1 \u5bfb\u627e\u76ee\u6807\u5143\u7d20\uff0c$O(n\\log n)$ \u6216\u76f4\u63a5\u4ece\u6ed1\u52a8\u7a97\u53e3\u7684\u601d\u8def\u5165\u624b \u5b8c\u6210\u4e00\u6b21\u641c\u7d22\u5f97\u5230\u7ed3\u679c [start,end) \u540e\uff0c\u4e0b\u4e00\u8f6e\u4ece start+1 \u5f00\u59cb\u65f6\uff0c end \u53ef\u4ee5\u4e0d\u52a8\uff0c$O(n)$ solution \u524d\u7f00\u548c + \u4e8c\u5206 class Solution { public : int minSubArrayLen ( int target , vector < int >& nums ) { vector < int > prefixSum ( nums . size () + 1 ); prefixSum [ 0 ] = 0 ; for ( int i = 1 ; i <= nums . size (); ++ i ) { prefixSum [ i ] = prefixSum [ i - 1 ] + nums [ i - 1 ]; } int res = nums . size () + 1 ; for ( auto rightEnd = prefixSum . end () - 1 ; rightEnd != prefixSum . begin (); -- rightEnd ) { auto leftEnd = upper_bound ( prefixSum . begin (), rightEnd , * rightEnd - target ); if ( leftEnd == prefixSum . begin ()) continue ; res = std :: min ( res , ( int )( rightEnd - leftEnd + 1 )); } return ( res == nums . size () + 1 ) ? 0 : res ; } }; \u6ed1\u52a8\u7a97\u53e3 class Solution { public : int minSubArrayLen ( int target , vector < int >& nums ) { int start = 0 , end = 1 ; int res = nums . size () + 1 ; int sum = nums [ start ]; while ( start < nums . size ()) { while ( end < nums . size () && sum < target ) { sum += nums [ end ]; ++ end ; } if ( sum < target ) break ; res = std :: min ( res , end - start ); sum -= nums [ start ]; ++ start ; } return ( res == nums . size () + 1 ) ? 0 : res ; } };","title":"209. mininum size subarray sum"},{"location":"_problems/_leetcode/210/","text":"\u73b0\u5728\u4f60\u603b\u5171\u6709 n \u95e8\u8bfe\u9700\u8981\u9009\uff0c\u8bb0\u4e3a 0 \u5230 n-1 \u3002 \u5728\u9009\u4fee\u67d0\u4e9b\u8bfe\u7a0b\u4e4b\u524d\u9700\u8981\u4e00\u4e9b\u5148\u4fee\u8bfe\u7a0b\u3002 \u4f8b\u5982\uff0c\u60f3\u8981\u5b66\u4e60\u8bfe\u7a0b 0 \uff0c\u4f60\u9700\u8981\u5148\u5b8c\u6210\u8bfe\u7a0b 1 \uff0c\u6211\u4eec\u7528\u4e00\u4e2a\u5339\u914d\u6765\u8868\u793a\u4ed6\u4eec: [0,1] \u7ed9\u5b9a\u8bfe\u7a0b\u603b\u91cf\u4ee5\u53ca\u5b83\u4eec\u7684\u5148\u51b3\u6761\u4ef6\uff0c\u8fd4\u56de\u4f60\u4e3a\u4e86\u5b66\u5b8c\u6240\u6709\u8bfe\u7a0b\u6240\u5b89\u6392\u7684\u5b66\u4e60\u987a\u5e8f\u3002 \u53ef\u80fd\u4f1a\u6709\u591a\u4e2a\u6b63\u786e\u7684\u987a\u5e8f\uff0c\u4f60\u53ea\u8981\u8fd4\u56de\u4e00\u79cd\u5c31\u53ef\u4ee5\u4e86\u3002\u5982\u679c\u4e0d\u53ef\u80fd\u5b8c\u6210\u6240\u6709\u8bfe\u7a0b\uff0c\u8fd4\u56de\u4e00\u4e2a\u7a7a\u6570\u7ec4\u3002 Example1: \u8f93\u5165: 4, [[1,0],[2,0],[3,1],[3,2]] \u8f93\u51fa: [0,1,2,3] or [0,2,1,3] \u89e3\u91ca: \u603b\u5171\u6709 4 \u95e8\u8bfe\u7a0b\u3002\u8981\u5b66\u4e60\u8bfe\u7a0b 3\uff0c\u4f60\u5e94\u8be5\u5148\u5b8c\u6210\u8bfe\u7a0b 1 \u548c\u8bfe\u7a0b 2\u3002\u5e76\u4e14\u8bfe\u7a0b 1 \u548c\u8bfe\u7a0b 2 \u90fd\u5e94\u8be5\u6392\u5728\u8bfe\u7a0b 0 \u4e4b\u540e\u3002 \u56e0\u6b64\uff0c\u4e00\u4e2a\u6b63\u786e\u7684\u8bfe\u7a0b\u987a\u5e8f\u662f [0,1,2,3] \u3002\u53e6\u4e00\u4e2a\u6b63\u786e\u7684\u6392\u5e8f\u662f [0,2,1,3] \u3002 Note: 1 <= numCourses <= 2000, 0 <= prerequisites.length <= numCourses * (numCourses - 1) 0 <= ai, bi < numCourses ai != bi \u4e14 prerequisites[i] \u4e2d\u7684\u6240\u6709\u8bfe\u7a0b\u5bf9 \u4e92\u4e0d\u76f8\u540c (Medium) \u7ecf\u5178\u62d3\u6251\u6392\u5e8f\u95ee\u9898\u3002\u548c 207. \u8bfe\u7a0b\u8868 \u4e00\u6837 \u5f88\u660e\u663e\u5e94\u8be5\u4f7f\u7528\u90bb\u63a5\u8868 Kahn class Solution { public int [] findOrder ( int numCourses , int [][] prerequisites ) { List < List < Integer >> graph = new ArrayList <> (); int [] result = new int [ numCourses ] ; int rPtr = 0 ; for ( int i = 0 ; i < numCourses ; ++ i ) graph . add ( new ArrayList < Integer > ()); int [] indegrees = new int [ numCourses ] ; for ( int i = 0 ; i < prerequisites . length ; ++ i ) { graph . get ( prerequisites [ i ][ 1 ] ). add ( prerequisites [ i ][ 0 ] ); indegrees [ prerequisites [ i ][ 0 ]]++ ; } Queue < Integer > queue = new LinkedList < Integer > (); for ( int i = 0 ; i < indegrees . length ; ++ i ) { if ( indegrees [ i ] == 0 ) { queue . offer ( i ); } } int visited = 0 ; while ( ! queue . isEmpty ()) { int bald = queue . poll (); result [ rPtr ++] = bald ; visited ++ ; for ( int neighbor : graph . get ( bald )) { indegrees [ neighbor ]-- ; if ( indegrees [ neighbor ] == 0 ) { queue . offer ( neighbor ); } } } if ( visited != numCourses ) return new int [ 0 ] ; return result ; } } DFS class Solution { int [] result ; int rPtr ; public int [] findOrder ( int numCourses , int [][] prerequisites ) { result = new int [ numCourses ] ; rPtr = numCourses ; List < List < Integer >> graph = new ArrayList <> (); for ( int i = 0 ; i < numCourses ; ++ i ) { graph . add ( new ArrayList < Integer > ()); } for ( int i = 0 ; i < prerequisites . length ; ++ i ) { graph . get ( prerequisites [ i ][ 1 ] ). add ( prerequisites [ i ][ 0 ] ); } int [] nodeState = new int [ numCourses ] ; for ( int i = 0 ; i < numCourses ; ++ i ) { if ( nodeState [ i ] == 0 ) { if ( ! dfs ( graph , nodeState , i )) { return new int [ 0 ] ; } } } return result ; } public boolean dfs ( List < List < Integer >> graph , int [] nodeState , int node ) { nodeState [ node ] = - 1 ; for ( int neighbor : graph . get ( node )) { if ( nodeState [ neighbor ] == - 1 ) { return false ; } else if ( nodeState [ neighbor ] == 0 ) { if ( ! dfs ( graph , nodeState , neighbor )) { return false ; } } } result [-- rPtr ] = node ; nodeState [ node ] = 1 ; return true ; } }","title":"210. course schedule ii"},{"location":"_problems/_leetcode/212/","text":"\u5728\u5355\u8bcd\u641c\u7d22\u7684\u57fa\u7840\u4e0a\uff0c\u8fdb\u884c\u591a\u4e2a\u5355\u8bcd\u7684\u5339\u914d Example1: \u8f93\u5165\uff1aboard = [[\"o\",\"a\",\"b\",\"n\"],[\"o\",\"t\",\"a\",\"e\"],[\"a\",\"h\",\"k\",\"r\"],[\"a\",\"f\",\"l\",\"v\"]] words = [\"oa\",\"oaa\"] \u8f93\u51fa\uff1a[\"oa\", \"oaa\"] Example2: \u8f93\u5165\uff1aboard = [[\"o\",\"a\",\"a\",\"n\"], [\"e\",\"t\",\"a\",\"e\"], [\"i\",\"h\",\"k\",\"r\"], [\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"] \u8f93\u51fa\uff1a[\"eat\",\"oath\"] Note: 1 <= board.length, board[i].length <= 12 1 <= words[i].length <= 10 (Hard) \u6cbf\u7528\u5355\u8bcd\u641c\u7d22 I \u7684\u601d\u8def\uff0c\u4ece\u6bcf\u4e00\u4e2a board[i][j] \u51fa\u53d1\u6267\u884c\u6392\u5217 DFS\uff0c\u8fd9\u6837\u7684\u95ee\u9898\u5728\u4e8e: \u65f6\u95f4\u4e0d\u53ef\u63a5\u53d7 \u540c\u4e00\u4e2a\u5355\u8bcd\u53ef\u80fd\u5728\u4e0d\u540c\u7684\u4f4d\u7f6e\u5339\u914d\u9020\u6210\u91cd\u590d \u4f7f\u7528 trie \u964d\u4f4e\u65f6\u95f4: \u4f7f\u6392\u5217 DFS \u7684\u9012\u5f52\u8fc7\u7a0b\u548c trie \u7684\u5339\u914d\u540c\u6b65\uff0c\u89e3\u51b3\u91cd\u590d\u7684\u65b9\u6cd5: \u76f4\u63a5\u5bf9\u7ed3\u679c\u53bb\u91cd \u5bf9 TrieNode \u6253\u6807\u8bb0 Note: \u6761\u4ef6\u5141\u8bb8\u53ef\u4ee5\u901a\u8fc7\u4fee\u6539 board \u5b9e\u73b0 visited solution no gc class Trie { private : struct TrieNode { vector < TrieNode *> children ; bool isEnd ; bool visited ; TrieNode () : children ( 26 ), isEnd ( false ), visited ( false ) { } }; TrieNode * root ; vector < string > resWords ; void _insert ( string word ) { TrieNode * curNodePtr = root ; for ( char c : word ) { int idx = c - 'a' ; if ( curNodePtr -> children [ idx ] == nullptr ) { curNodePtr -> children [ idx ] = new TrieNode (); } curNodePtr = curNodePtr -> children [ idx ]; } curNodePtr -> isEnd = true ; } public : Trie () : root ( new TrieNode ()) { } void buildTree ( vector < string >& words ) { for ( string & word : words ) { this -> _insert ( word ); } } vector < string > trieFindWords ( vector < vector < char >>& board ) { vector < vector < bool >> visited ( board . size (), vector < bool > ( board [ 0 ]. size ())); string resWord ; for ( int i = 0 ; i < board . size (); ++ i ) { for ( int j = 0 ; j < board [ 0 ]. size (); ++ j ) { int childIdx = board [ i ][ j ] - 'a' ; if ( root -> children [ childIdx ] == nullptr ) continue ; trieFindWordsDFS ( board , visited , root -> children [ childIdx ], i , j , resWord ); } } return resWords ; } void trieFindWordsDFS ( vector < vector < char >>& board , vector < vector < bool >>& visited , TrieNode * curNodePtr , int i , int j , string & curWord ) { visited [ i ][ j ] = true ; curWord . push_back ( board [ i ][ j ]); if ( curNodePtr -> isEnd && ! curNodePtr -> visited ) { resWords . push_back ( curWord ); curNodePtr -> visited = true ; } for ( int * dir : DIRECTIONS ) { int ni = i + dir [ 0 ], nj = j + dir [ 1 ]; if ( inArea ( ni , nj , board ) && ! visited [ ni ][ nj ]) { int childIdx = board [ ni ][ nj ] - 'a' ; if ( curNodePtr -> children [ childIdx ] == nullptr ) continue ; trieFindWordsDFS ( board , visited , curNodePtr -> children [ childIdx ], ni , nj , curWord ); } } visited [ i ][ j ] = false ; curWord . pop_back (); } bool inArea ( int i , int j , vector < vector < char >>& board ) { return i >= 0 && i < board . size () && j >= 0 && j < board [ 0 ]. size (); } int DIRECTIONS [ 4 ][ 2 ] = {{ 0 , 1 }, { 0 , -1 }, { 1 , 0 }, { -1 , 0 }}; }; class Solution { public : vector < string > findWords ( vector < vector < char >>& board , vector < string >& words ) { Trie trie ; trie . buildTree ( words ); return trie . trieFindWords ( board ); } }; auto gc class Trie { private : struct TrieNode { vector < unique_ptr < TrieNode >> children ; bool isEnd ; bool arrived ; TrieNode () : children ( 26 ), isEnd ( false ), arrived ( false ) { } }; unique_ptr < TrieNode > root ; vector < string > resWords ; void _insert ( string word ) { TrieNode * curNodePtr = root . get (); for ( char c : word ) { int idx = c - 'a' ; if ( curNodePtr -> children [ idx ] == nullptr ) curNodePtr -> children [ idx ]. reset ( new TrieNode ()); curNodePtr = curNodePtr -> children [ idx ]. get (); } curNodePtr -> isEnd = true ; } public : Trie () : root ( new TrieNode ()) { } void buildTree ( vector < string >& words ) { for ( string & word : words ) { this -> _insert ( word ); } } vector < string > trieFindWords ( vector < vector < char >>& board ) { vector < vector < bool >> visited ( board . size (), vector < bool > ( board [ 0 ]. size ())); string resWord ; for ( int i = 0 ; i < board . size (); ++ i ) { for ( int j = 0 ; j < board [ 0 ]. size (); ++ j ) { int childIdx = board [ i ][ j ] - 'a' ; if ( root -> children [ childIdx ] == nullptr ) continue ; trieFindWordsDFS ( board , visited , root -> children [ childIdx ]. get (), i , j , resWord ); } } return resWords ; } void trieFindWordsDFS ( vector < vector < char >>& board , vector < vector < bool >>& visited , TrieNode * curNodePtr , int i , int j , string & curWord ) { visited [ i ][ j ] = true ; curWord . push_back ( board [ i ][ j ]); if ( curNodePtr -> isEnd && ! curNodePtr -> arrived ) { resWords . push_back ( curWord ); curNodePtr -> arrived = true ; } for ( int * dir : DIRECTIONS ) { int ni = i + dir [ 0 ], nj = j + dir [ 1 ]; if ( inArea ( ni , nj , board ) && ! visited [ ni ][ nj ]) { int childIdx = board [ ni ][ nj ] - 'a' ; if ( curNodePtr -> children [ childIdx ] == nullptr ) continue ; trieFindWordsDFS ( board , visited , curNodePtr -> children [ childIdx ]. get (), ni , nj , curWord ); } } visited [ i ][ j ] = false ; curWord . pop_back (); } bool inArea ( int i , int j , vector < vector < char >>& board ) { return i >= 0 && i < board . size () && j >= 0 && j < board [ 0 ]. size (); } int DIRECTIONS [ 4 ][ 2 ] = {{ 0 , 1 }, { 0 , -1 }, { 1 , 0 }, { -1 , 0 }}; }; class Solution { public : vector < string > findWords ( vector < vector < char >>& board , vector < string >& words ) { Trie trie ; trie . buildTree ( words ); return trie . trieFindWords ( board ); } }; \u590d\u6742\u5ea6: \u65f6\u95f4: $O(m\\times n \\times 4 \\times 3^{\\mathrm{len}-1})$\uff0c\u5171 $m\\times n$ \u4e2a\u5355\u5143\u683c\uff0c\u6bcf\u4e2a\u5355\u5143\u683c\u8981\u6700\u591a\u904d\u5386 $4\\times 3^{\\mathrm{len}-1}$ \u6761\u8def\u5f84\uff0c\u5176\u4e2d $\\mathrm{len}$ \u662f\u5355\u8bcd\u957f\u5ea6\u3002 \u7a7a\u95f4: $O(k\\times \\mathrm{len})$\uff0c$k$ \u662f\u5355\u8bcd\u8868\u957f\u5ea6\uff0c\u6700\u574f\u60c5\u51b5\u9700\u8981 $O(k\\times \\mathrm{len})$ \u5b58\u50a8\u524d\u7f00\u6811","title":"212. word search ii"},{"location":"_problems/_leetcode/213/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\u6570\u7ec4\uff0c\u4ee3\u8868\u4e00\u6392\u5b58\u6709\u91d1\u94b1\u7684\u5c0f\u5c4b (\u5c0f\u5c4b\u9996\u5c3e\u76f8\u8fde)\uff0c\u5c0f\u5077\u6cbf\u9014\u5077\u7a83\uff0c\u5982\u679c\u8fde\u7eed\u5077\u7a83\u4e24\u95f4\u76f8\u90bb\u7684\u5c0f\u5c4b\uff0c\u7cfb\u7edf\u4f1a\u81ea\u52a8\u62a5\u8b66\u3002\u6c42\u5c0f\u5077\u80fd\u5077\u5230\u7684\u6700\u9ad8\u91d1\u989d\u3002 Example: \u8f93\u5165\uff1anums = [2,3,2] \u8f93\u51fa\uff1a3 Note: 1 <= nums.length <= 100 (Medium) \u4e0e 198. \u6253\u5bb6\u52ab\u820d \u5bf9\u6bd4\uff0c\u672c\u9898\u76f8\u5f53\u4e8e\u4ece\u539f\u672c\u7684\u503c\u57df All(start...end) \u4e2d\u5228\u51fa\u4e86\u9996\u5c3e\u5747\u88ab\u9009\u4e2d\u7684\u503c\uff0c\u5269\u4e0b\u7684\u7a7a\u95f4\u6070\u597d\u4e3a All(start...end-1) + All(start+1...end) \uff0c\u5bf9\u4e24\u4e2a\u7a7a\u95f4\u5206\u522b dp \u518d\u6c42\u6700\u5927\u503c\u5373\u53ef solution class Solution { public : int rob ( vector < int >& nums ) { const int N = nums . size (); if ( N == 1 ) return nums [ 0 ]; if ( N == 2 ) return std :: max ( nums [ 0 ], nums [ 1 ]); return std :: max ( robRange ( nums , 0 , N - 2 ), robRange ( nums , 1 , N - 1 )); } int robRange ( vector < int >& nums , int start , int end ) { int first = nums [ start ], second = std :: max ( nums [ start ], nums [ start + 1 ]); for ( int i = start + 2 ; i <= end ; ++ i ) { int temp = second ; second = std :: max ( first + nums [ i ], second ); first = temp ; } return second ; } };","title":"213. house robbery ii"},{"location":"_problems/_leetcode/22/","text":"\u6570\u5b57 n \u4ee3\u8868\u62ec\u53f7\u751f\u6210\u7684\u5bf9\u6570\uff0c\u8bbe\u8ba1\u51fd\u6570\u751f\u6210\u6240\u6709\u7684\u6709\u6548\u62ec\u53f7\u7ec4\u5408\u3002 \u6709\u6548\u62ec\u53f7\u6307\u5de6\u62ec\u53f7\u53ef\u4ee5\u6b63\u786e\u95ed\u5408\uff0ci.e. \u6ee1\u8db3\u5de6\u62ec\u53f7\u6808\u7684\u5339\u914d\u8fc7\u7a0b Example: \u8f93\u5165\uff1an = 3 \u8f93\u51fa\uff1a[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"] Note: 1 <= n <= 8 (Medium) \u6392\u5217 DFS \u95ee\u9898\uff0c\u9009\u62e9\u9012\u5f52\u5de6\u62ec\u53f7\u6216\u53f3\u62ec\u53f7\u53ef\u7531\u4e24\u4e2a\u6807\u5fd7\u51b3\u5b9a: curr_left_n : \u2002 \u5f53\u524d\u5df2\u5728\u6808\u4e2d\u7684\u5de6\u62ec\u53f7\u6570 remain_left_n : \u2002 \u5269\u4f59\u6ca1\u7528\u7684\u5de6\u62ec\u53f7\u6570 solution class Solution { public : vector < string > generateParenthesis ( int n ) { gen ( '(' , 1 , n - 1 , n ); // or gen2 ( 0 , 0 , n , n ); return res ; } private : void gen ( char par , int curr_left_n , int remain_left_n , int n ) { pars . push_back ( par ); if ( pars . size () == n * 2 ) { res . push_back ( pars ); pars . pop_back (); return ; } if ( remain_left_n > 0 ) gen ( '(' , curr_left_n + 1 , remain_left_n - 1 , n ); if ( curr_left_n > 0 ) gen ( ')' , curr_left_n - 1 , remain_left_n , n ); pars . pop_back (); } void gen2 ( int length , int curr_left_n , int remain_left_n , int n ) { if ( length == n * 2 ) { res . push_back ( pars ); return ; } if ( remain_left_n > 0 ) { pars . push_back ( '(' ); gen2 ( length + 1 , curr_left_n + 1 , remain_left_n - 1 , n ); pars . pop_back (); } if ( curr_left_n > 0 ) { pars . push_back ( ')' ); gen2 ( length + 1 , curr_left_n - 1 , remain_left_n , n ); pars . pop_back (); } } vector < string > res ; string pars ; };","title":"22. generate parentheses"},{"location":"_problems/_leetcode/221/","text":"\u5728\u4e00\u4e2a\u975e 0 \u5373 1 \u7684\u4e8c\u7ef4\u77e9\u9635\u5185\uff0c\u627e\u5230\u53ea\u5305\u542b 1 \u7684\u6700\u5927\u6b63\u65b9\u5f62\uff0c\u8fd4\u56de\u5176\u9762\u79ef Example1: \u8f93\u5165\uff1amatrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]] \u8f93\u51fa\uff1a4 Note: 1 <= m, n <= 300 (Medium) `dp[i][j] = min { dp[i-1][j], dp[i][j-1], dp[i-1][j-1] } + 1 \u8bc1\u660e: \u628a\u4e09\u4e2a\u6b63\u65b9\u5f62\u7684\u8fb9\u90fd\u6309\u6700\u5c0f\u7684\u90a3\u4e2a\u7b97\uff0c\u5728\u6b64\u57fa\u7840\u4e0a\u8003\u8651 solution class Solution { public : int maximalSquare ( vector < vector < char >> & matrix ) { const int M = matrix . size (), N = matrix [ 0 ]. size (); vector < vector < int >> dp ( M , vector < int > ( N )); int maxWidth = 0 ; for ( int j = 0 ; j < N ; ++ j ) { if ( matrix [ 0 ][ j ] == '1' ) { dp [ 0 ][ j ] = 1 ; maxWidth = max ( maxWidth , 1 ); } } for ( int i = 1 ; i < M ; ++ i ) { if ( matrix [ i ][ 0 ] == '1' ) { dp [ i ][ 0 ] = 1 ; maxWidth = max ( maxWidth , 1 ); } for ( int j = 1 ; j < N ; ++ j ) { if ( matrix [ i ][ j ] == '1' ) { dp [ i ][ j ] = min ( min ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]), dp [ i - 1 ][ j - 1 ]) + 1 ; maxWidth = max ( maxWidth , dp [ i ][ j ]); } } } return maxWidth * maxWidth ; } };","title":"221. maximal square"},{"location":"_problems/_leetcode/239/","text":"\u7ed9\u5b9a\u6574\u6570\u6570\u7ec4 nums \u548c\u5927\u5c0f\u4e3a k \u7684\u7a97\u53e3\uff0c\u7a97\u53e3\u6bcf\u6b21\u5411\u53f3\u6ed1\u52a8\u4e00\u4f4d\uff0c\u8fd4\u56de\u6bcf\u4e2a\u7a97\u53e3\u4e2d\u7684\u6700\u5927\u503c\u3002 Example: \u8f93\u5165\uff1anums = [1,3,-1,-3,5,3,6,7], k = 3 \u8f93\u51fa\uff1a[3,3,5,5,6,7] \u89e3\u91ca\uff1a \u6ed1\u52a8\u7a97\u53e3\u7684\u4f4d\u7f6e \u6700\u5927\u503c --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Note: 1 <= nums.length <= 10^5 1 <= k <= nums.length (Hard) \u53ef\u4ee5\u4f7f\u7528\u5806\u7ef4\u62a4\u6700\u5927\u503c: \u76f4\u63a5\u7528\u5806\uff0cpop \u51fa\u7684\u5143\u7d20\u5982\u679c\u5728\u754c\u5916\u5c31\u63a5\u7740 pop \u4e0b\u4e00\u4e2a\uff0c\u65f6\u95f4 $O(n\\log n)$\uff0c\u7a7a\u95f4 $O(n)$ \u628a\u7a97\u53e3\u79fb\u52a8\u89c6\u4e3a\u5143\u7d20\u66ff\u6362\uff0c\u6839\u636e\u66ff\u6362\u7684\u5927\u5c0f\u60c5\u51b5\u9009\u62e9\u5411\u4e0a\u8fd8\u662f\u5411\u4e0b\u8c03\u6574\u5806\uff0c\u65f6\u95f4 $O(n\\log k)$\uff0c\u7a7a\u95f4 $O(k)$ \u5982\u679c\u7a97\u53e3\u5185\u65b0\u589e\u4e00\u4e2a nums[j] \u4e14 nums[j] >= nums[i] (j > i) \uff0c\u90a3\u4e48 nums[i] \u5c31\u6ca1\u7528\u4e86\uff0c\u8fd9\u548c\u5355\u8c03\u6808\u7684\u64cd\u4f5c\u7c7b\u4f3c \u6bcf\u9047\u5230 nums[i] \uff0c\u5c31\u52a0\u5165\u5355\u8c03\u6808\uff0c\u6b64\u64cd\u4f5c\u53ef\u80fd pop \u6389\u6808\u5185\u4e00\u4e9b\u65e0\u7528\u5143\u7d20 (\u76f8\u7b49\u4e5f pop) \u7531\u5355\u8c03\u6808\u6027\u8d28\uff0c mono[i] \u662f mono[i+1] \u5de6\u4fa7\u7b2c\u4e00\u4e2a\u6bd4\u5b83\u5927\u7684\u5143\u7d20\uff0c\u5219\u6808\u5185\u5143\u7d20\u9012\u51cf\u4e14\u6808\u5e95\u67d0\u90e8\u5206\u53ef\u80fd\u5728\u754c\u5916\uff0c\u628a\u754c\u5916\u5143\u7d20 pop \u6389\u540e\u6808\u5e95\u5143\u7d20\u5c31\u662f\u5f53\u524d\u533a\u95f4\u6700\u5927\u503c \u6bcf\u4e2a\u5143\u7d20\u5165\u6808\u4e00\u6b21\uff0c\u51fa\u6808\u4e00\u6b21\uff0c\u65f6\u95f4 $O(n)$\uff0c\u7a7a\u95f4 $O(k)$ solution heap class Heap { private : vector < int >& nums ; // \u539f\u59cb\u6570\u7ec4 vector < int > heap ; // heap vector < int > ni2hi ; // nums index to heap index void maxHeapifyDown ( int hi ) { int father = hi , child = 2 * hi + 1 ; int ni = heap [ hi ]; while ( child < heap . size ()) { if ( child + 1 < heap . size () && nums [ heap [ child + 1 ]] > nums [ heap [ child ]]) ++ child ; if ( nums [ ni ] >= nums [ heap [ child ]]) break ; heap [ father ] = heap [ child ]; ni2hi [ heap [ child ]] = father ; father = child ; child = child * 2 + 1 ; } heap [ father ] = ni ; ni2hi [ ni ] = father ; } void maxHeapifyUp ( int hi ) { int child = hi , father = ( hi - 1 ) / 2 ; int ni = heap [ hi ]; while ( child != 0 ) { if ( nums [ heap [ father ]] >= nums [ ni ]) break ; heap [ child ] = heap [ father ]; ni2hi [ heap [ father ]] = child ; child = father ; father = ( father - 1 ) / 2 ; } heap [ child ] = ni ; ni2hi [ ni ] = child ; } void buildHeap () { for ( int hi = heap . size () / 2 - 1 ; hi >= 0 ; -- hi ) { maxHeapifyDown ( hi ); } } public : Heap ( vector < int >& pNums , int k ) : nums ( pNums ), heap ( k ), ni2hi ( pNums . size (), -1 ) { for ( int i = 0 ; i < k ; ++ i ) { heap [ i ] = i ; ni2hi [ i ] = i ; } buildHeap (); } int maxElement () { return nums [ heap [ 0 ]]; } void replace ( int ni1 , int ni2 ) { heap [ ni2hi [ ni1 ]] = ni2 ; ni2hi [ ni2 ] = ni2hi [ ni1 ]; ni2hi [ ni1 ] = -1 ; if ( nums [ ni1 ] > nums [ ni2 ]) { maxHeapifyDown ( ni2hi [ ni2 ]); } else if ( nums [ ni1 ] < nums [ ni2 ]) { maxHeapifyUp ( ni2hi [ ni2 ]); } } }; class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { Heap heap ( nums , k ); vector < int > res ( nums . size () - k + 1 ); res [ 0 ] = heap . maxElement (); for ( int i = 1 ; i < res . size (); ++ i ) { heap . replace ( i - 1 , i + k - 1 ); res [ i ] = heap . maxElement (); } return res ; } }; monostack class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { deque < int > monoQueue ; vector < int > res ( nums . size () - k + 1 ); for ( int i = 0 ; i < k ; ++ i ) { while ( ! monoQueue . empty () && nums [ monoQueue . back ()] <= nums [ i ]) { monoQueue . pop_back (); } monoQueue . push_back ( i ); } res [ 0 ] = nums [ monoQueue . front ()]; for ( int i = k ; i < nums . size (); ++ i ) { while ( ! monoQueue . empty () && nums [ monoQueue . back ()] <= nums [ i ]) { monoQueue . pop_back (); } monoQueue . push_back ( i ); while ( monoQueue . front () < i - k + 1 ) { monoQueue . pop_front (); } res [ i - k + 1 ] = nums [ monoQueue . front ()]; } return res ; } };","title":"239. sliding window maximum"},{"location":"_problems/_leetcode/23_merge_k_sorted_lists/","text":"\u7ed9\u4f60\u4e00\u4e2a\u94fe\u8868\u6570\u7ec4\uff0c\u6bcf\u4e2a\u94fe\u8868\u90fd\u5df2\u7ecf\u6309\u5347\u5e8f\u6392\u5217\u3002\u8bf7\u4f60\u5c06\u6240\u6709\u94fe\u8868\u5408\u5e76\u5230\u4e00\u4e2a\u5347\u5e8f\u94fe\u8868\u4e2d\uff0c\u8fd4\u56de\u5408\u5e76\u540e\u7684\u94fe\u8868\u3002 Example1: \u8f93\u5165\uff1alists = [[1,4,5],[1,3,4],[2,6]] \u8f93\u51fa\uff1a[1,1,2,3,4,4,5,6] \u89e3\u91ca\uff1a\u94fe\u8868\u6570\u7ec4\u5982\u4e0b\uff1a [ 1->4->5, 1->3->4, 2->6 ] \u5c06\u5b83\u4eec\u5408\u5e76\u5230\u4e00\u4e2a\u6709\u5e8f\u94fe\u8868\u4e2d\u5f97\u5230\u3002 1->1->2->3->4->4->5->6 Example2: \u8f93\u5165\uff1alists = [] \u8f93\u51fa\uff1a[] Example3: \u8f93\u5165\uff1alists = [[]] \u8f93\u51fa\uff1a[] Note: k == lists.length, 0 <= k <= 10^4 0 <= lists[i].length <= 500, -10^4 <= lists[i][j] <= 10^4 (Hard) \u76f8\u5f53\u4e8e\u7ed9\u5b9a\u4e86\u5f52\u5e76\u6392\u5e8f\u7684\u4e00\u4e2a\u4e2d\u95f4\u72b6\u6001\uff0c\u7ee7\u7eed\u4e8c\u8def\u5f52\u5e76\u5373\u53ef\uff0c\u719f\u6089\u5f52\u5e76\u6392\u5e8f\u4f1a\u975e\u5e38\u597d\u5199 Solution class Solution { public ListNode mergeKLists ( ListNode [] lists ) { int validLength = lists . length ; if ( validLength == 0 ) return null ; while ( validLength > 1 ) { int t = validLength , i , j ; for ( i = 0 , j = 0 ; i < t - 1 ; i += 2 ) { ListNode newNode = merge2Lists ( lists [ i ] , lists [ i + 1 ] ); validLength -- ; lists [ j ++] = newNode ; } if ( t % 2 == 1 ) lists [ j ++] = lists [ i ] ; } return lists [ 0 ] ; } public ListNode merge2Lists ( ListNode node1 , ListNode node2 ) { ListNode head = new ListNode (); ListNode p1 = node1 , p2 = node2 , curr = head ; while ( p1 != null && p2 != null ) { if ( p1 . val < p2 . val ) p1 = appendNode ( p1 , curr ); else p2 = appendNode ( p2 , curr ); curr = curr . next ; } while ( p1 != null ) { p1 = appendNode ( p1 , curr ); curr = curr . next ; } while ( p2 != null ) { p2 = appendNode ( p2 , curr ); curr = curr . next ; } return head . next ; } public ListNode appendNode ( ListNode node , ListNode curr ) { ListNode ret = node . next ; node . next = null ; curr . next = node ; return ret ; } } \u8bbe\u6709 $k$ \u7ec4\u94fe\u8868\uff0c\u6700\u957f\u4e00\u4e2a\u4e3a $n$\uff0c\u5219\u7b2c\u4e00\u8f6e\u590d\u6742\u5ea6\u4e3a $O(\\frac{k}{2} \\cdot 2n)$\uff0c\u7b2c\u4e8c\u8f6e $O(\\frac{k}{4} \\cdot 4n)$\uff0c\u6545\u603b\u590d\u6742\u5ea6 $O(kn\\log k)$","title":"23. merge K sorted lists"},{"location":"_problems/_leetcode/240/","text":"\u5224\u65ad\u77e9\u9635\u662f\u5426\u5b58\u5728\u4e00\u4e2a\u76ee\u6807\u503c\u3002\u77e9\u9635\u7684\u7279\u70b9: \u6bcf\u884c\u4ece\u5de6\u5230\u53f3\u9012\u589e\uff0c\u6bcf\u5217\u4ece\u5de6\u5230\u53f3\u9012\u589e Example1: \u8f93\u5165\uff1amatrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5 \u8f93\u51fa\uff1atrue (Medium) \u6839\u636e\u4e24\u4e2a\u9012\u589e\u7684\u7279\u6027\uff0c\u4ece\u5de6\u4e0b\u5230\u53f3\u4e0a\u641c\u7d22\u51fa\u4e00\u4e2a\u5206\u754c\u7ebf solution class Solution { public : bool searchMatrix ( vector < vector < int >> & matrix , int target ) { const int M = matrix . size (), N = matrix [ 0 ]. size (); int i = M - 1 , j = 0 ; while ( i >= 0 && j < N ) { if ( matrix [ i ][ j ] < target ) { ++ j ; } else if ( matrix [ i ][ j ] > target ) { -- i ; } else { return true ; } } return false ; } };","title":"240. search a 2d matrix ii"},{"location":"_problems/_leetcode/263/","text":"\u5224\u65ad\u7ed9\u5b9a\u7684 n \u662f\u5426\u4e3a\u4e11\u6570\uff0c\u4e11\u6570\u662f\u503c\u5305\u542b\u8d28\u56e0\u6570 2/3/5 \u7684\u6b63\u6574\u6570 ( 1 \u662f\u4e11\u6570) Example: \u8f93\u5165\uff1an = 6 \u8f93\u51fa\uff1atrue \u89e3\u91ca\uff1a6 = 2 \u00d7 3 Note: -2^31 <= n <= 2^31-1 (Easy) \u6bcf\u8f6e\u5206\u522b\u6309 [2,3,5] \u7684\u987a\u5e8f\u5206\u89e3 ==> \u8822\u7684\u4e00 solution class Solution { public : bool isUgly ( int n ) { if ( n < 1 ) return false ; while ( n % 5 == 0 ) n /= 5 ; while ( n % 3 == 0 ) n /= 3 ; while ( n % 2 == 0 ) n /= 2 ; return n == 1 ; } };","title":"263. ugly number"},{"location":"_problems/_leetcode/268/","text":"\u7ed9\u5b9a\u8981\u7ed9\u5305\u542b [0, n] \u4e2d n \u4e2a\u6570\u7684\u6570\u7ec4 nums \uff0c\u627e\u51fa [0, n] \u8fd9\u4e2a\u8303\u56f4\u5185\u6ca1\u6709\u51fa\u73b0\u5728\u6570\u7ec4\u4e2d\u7684\u90a3\u4e2a\u6570 Example1: \u8f93\u5165\uff1anums = [3,0,1] \u8f93\u51fa\uff1a2 \u8f93\u5165\uff1anums = [9,6,4,2,3,5,7,0,1] \u8f93\u51fa\uff1a8 \u8f93\u5165\uff1anums = [0] \u8f93\u51fa\uff1a1 Note: num \u4e2d\u6240\u6709\u6570\u5b57\u72ec\u4e00\u65e0\u4e8c (Medium) \u539f\u5730\u54c8\u5e0c or \u6570\u7ec4\u6c42\u548c solution 1 class Solution { public : int missingNumber ( vector < int >& nums ) { int N = nums . size (); for ( int i = 0 ; i < N ; ++ i ) { while ( nums [ i ] != N && i != nums [ i ]) { swap ( nums [ i ], nums [ nums [ i ]]); } } for ( int i = 0 ; i < N ; ++ i ) { if ( nums [ i ] != i ) { return i ; } } return N ; } }; 2 class Solution { public : int missingNumber ( vector < int >& nums ) { int sum = 0 , N = nums . size (); for ( int num : nums ) { sum += num ; } return ( 1 + N ) * N / 2 - sum ; } };","title":"268. missing number"},{"location":"_problems/_leetcode/27/","text":"\u7ed9\u5b9a\u6570\u7ec4 nums \u548c\u4e00\u4e2a\u503c val \uff0c\u79fb\u9664\u6240\u6709\u6570\u503c\u7b49\u4e8e val \u7684\u5143\u7d20\uff0c\u8fd4\u56de\u79fb\u9664\u540e\u6570\u7ec4\u7684\u957f\u5ea6\uff0c\u7cfb\u7edf\u4f1a\u6839\u636e\u8fd9\u4e2a\u957f\u5ea6\u8f93\u51fa\u6570\u7ec4\u7684\u503c\u3002 \u4fdd\u7559\u4e0b\u6765\u7684\u6570\u7ec4\u7684\u503c\u53ef\u4ee5\u4e71\u5e8f\u3002 Example: \u8f93\u5165\uff1anums = [0,1,2,2,3,0,4,2], val = 2 \u8f93\u51fa\uff1a5, nums = [0,1,4,0,3] Note: 1 <= nums.length <= 100 (Easy) \u601d\u8def: \u6ca1 get \u5230\u70b9\uff0c\u76f4\u63a5\u5728 vector \u4e2d erase \uff0c\u590d\u6742\u5ea6 $O(n^2)$ \u53cc\u6307\u9488\uff0c\u4e24\u4e2a\u6307\u9488\u90fd\u4ece\u5de6\u4fa7\u5f00\u59cb\uff0c\u4e00\u4e2a\u4ee3\u8868\u65b0\u6570\u7ec4\u7684\u5c3e\u6307\u9488\uff0c\u4e00\u4e2a\u4ee3\u8868\u65e7\u6570\u7ec4\u7684\u904d\u5386\u6307\u9488\uff0c\u8fd9\u4e5f\u662f vector \u7684 remove \u7684\u5b9e\u73b0\u65b9\u5f0f ($O(n)$) \u7531\u4e8e\u672c\u9898\u53ef\u4ee5\u4e71\u5e8f\uff0c\u9700\u8981\u4fdd\u7559\u7684\u503c\u53ef\u4ee5\u539f\u4f4d\u4e0d\u52a8\uff0c\u5728\u9047\u5230 val \u65f6\uff0c\u76f4\u63a5\u628a\u6570\u7ec4\u5c3e\u7aef\u7684\u503c\u62ff\u6765\u586b\u4e0a\uff0c\u5982\u679c\u4f9d\u7136\u4e3a val \u5c31\u5982\u6b64\u5faa\u73af\u3002\u8fd9\u79cd\u65b9\u6cd5\u4e24\u4e2a\u6307\u9488\u52a0\u8d77\u6765\u53ea\u904d\u5386\u4e86\u4e00\u6b21\uff0c\u4e14\u907f\u514d\u4e86\u4e00\u4e9b\u4e0d\u9700\u8981\u5220\u9664\u7684\u5143\u7d20\u7684\u8d4b\u503c\uff0c\u5728\u76ee\u6807\u503c val \u8f83\u5c11\u65f6\u662f\u4e2a\u5f88\u597d\u7684\u4f18\u5316 ($O(n)$) solution naive class Solution { public : int removeElement ( vector < int >& nums , int val ) { auto iter = nums . begin (); while ( iter != nums . end ()) { if ( * iter == val ) iter = nums . erase ( iter ); else ++ iter ; } return nums . size (); } }; double pointers 1 class Solution { public : int removeElement ( vector < int >& nums , int val ) { int size = nums . size (); int w_i = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( nums [ i ] != val ) { nums [ w_i ] = nums [ i ]; ++ w_i ; } else { -- size ; } } return size ; } }; double pointers 2 class Solution { public : int removeElement ( vector < int >& nums , int val ) { int size = nums . size (); int mv_i = size - 1 ; for ( int i = 0 ; i <= mv_i ; ) { if ( nums [ i ] == val ) { nums [ i ] = nums [ mv_i ]; -- mv_i ; -- size ; } else { ++ i ; } } return size ; } };","title":"27. remove element"},{"location":"_problems/_leetcode/300_longest_increasing_subsequence/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u627e\u5230\u5176\u4e2d\u6700\u957f\u4e25\u683c\u9012\u589e\u5b50\u5e8f\u5217\u7684\u957f\u5ea6\u3002 Example1: \u5165\uff1anums = [10,9,2,5,3,7,101,18] \u8f93\u51fa\uff1a4 \u89e3\u91ca\uff1a\u6700\u957f\u9012\u589e\u5b50\u5e8f\u5217\u662f [2,3,7,101]\uff0c\u56e0\u6b64\u957f\u5ea6\u4e3a 4 \u3002 Example2 \u8f93\u5165\uff1anums = [7,7,7,7,7,7,7] \u8f93\u51fa\uff1a1 Note: 1 <= nums.length <= 2500 -10^4 <= nums[i] <= 10^4 \u7b80\u5355 DP \ud83e\uddd0 \u4ee4 $dp[i]$ \u8868\u793a\u4ee5 $\\mathrm{nums}[i]$ \u7ed3\u5c3e\u7684 LIS \u957f\u5ea6\uff0c\u5219: $$ dp[i] = \\max_{\\substack{0 \\leq j \\leq i-1\\\\ \\mathrm{nums}[j] < \\mathrm{nums}[i]}} \\lbrace \\ dp[j] + 1 \\ \\rbrace $$ solution public int lengthOfLIS ( int [] nums ) { int [] dp = new int [ nums . length ] ; int maxLen = 1 ; dp [ 0 ] = 1 ; for ( int i = 1 ; i < nums . length ; ++ i ) { dp [ i ] = 1 ; for ( int j = i - 1 ; j >= 0 ; -- j ) { if ( nums [ j ] < nums [ i ] ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ); } maxLen = Math . max ( dp [ i ] , maxLen ); } return maxLen ; } \u65f6\u95f4 $O(n^2)$\uff0c\u7a7a\u95f4 $O(n)$ DP + \u4e8c\u5206 \ud83e\uddd0 \u6784\u9020 LIS \u7684\u8fc7\u7a0b\u4e2d\uff0c\u5bf9\u4e8e\u7b49\u957f\u7684 LIS\uff0c\u5e94\u4f7f LIS[-1] \u5c3d\u53ef\u80fd\u5c0f\u3002\u53d7\u6b64\u542f\u53d1\uff0c\u4ee4 $dp_i[k]$ \u8868\u793a $\\mathrm{nums}[0...i]$ \u4e2d\u957f\u4e3a $k+1$ \u7684 LIS[-1] \u7684\u6700\u5c0f\u503c $$ dp_i[k] = \\begin{cases} \\mathrm{nums}[i] & \\text{if } dp_{i-1}[k-1] < \\text{nums}[i]\\leq dp_{i-1}[k] \\\\ dp_{i-1}[k] &\\text{else} \\end{cases} $$ \u5b9e\u9645\u53ea\u9700\u7ef4\u62a4\u4e00\u4e2a\u4e00\u7ef4\u6570\u7ec4\uff0c\u7531\u4e8e $dp_{i-1}[0...\\mathsf{maxLen})$ \u90e8\u5206\u4e00\u5b9a\u662f\u6709\u5e8f\u7684\uff0c\u53ef\u4ee5\u901a\u8fc7\u4e8c\u5206\u67e5\u627e\uff0c\u627e\u5230\u7b2c\u4e00\u4e2a\u5927\u4e8e\u6216\u7b49\u4e8e $\\mathrm{nums}[i]$ \u7684\u5143\u7d20; \u5982\u679c\u67e5\u627e\u5931\u8d25\uff0c\u8bf4\u660e $\\text{nums}[i]$ \u5f88\u5927\uff0c\u9700\u8981\u6269\u5c55 $\\mathsf{maxLen}$ solution public int lengthOfLIS ( int [] nums ) { int [] dp = new int [ nums . length ] ; dp [ 0 ] = nums [ 0 ] ; int maxLen = 1 ; for ( int i = 1 ; i < nums . length ; ++ i ) { int l = 0 , r = maxLen ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( nums [ i ] > dp [ mid ] ) l = mid + 1 ; else if ( nums [ i ] < dp [ mid ] ) r = mid ; else l = r = mid ; } dp [ l ] = nums [ i ] ; maxLen = Math . max ( l + 1 , maxLen ); } return maxLen ; } \u65f6\u95f4 $O(n\\log n)$\uff0c\u7a7a\u95f4 $O(n)$","title":"300. longest increasing subsequence"},{"location":"_problems/_leetcode/300_longest_increasing_subsequence/#dp","text":"\u4ee4 $dp[i]$ \u8868\u793a\u4ee5 $\\mathrm{nums}[i]$ \u7ed3\u5c3e\u7684 LIS \u957f\u5ea6\uff0c\u5219: $$ dp[i] = \\max_{\\substack{0 \\leq j \\leq i-1\\\\ \\mathrm{nums}[j] < \\mathrm{nums}[i]}} \\lbrace \\ dp[j] + 1 \\ \\rbrace $$ solution public int lengthOfLIS ( int [] nums ) { int [] dp = new int [ nums . length ] ; int maxLen = 1 ; dp [ 0 ] = 1 ; for ( int i = 1 ; i < nums . length ; ++ i ) { dp [ i ] = 1 ; for ( int j = i - 1 ; j >= 0 ; -- j ) { if ( nums [ j ] < nums [ i ] ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ); } maxLen = Math . max ( dp [ i ] , maxLen ); } return maxLen ; } \u65f6\u95f4 $O(n^2)$\uff0c\u7a7a\u95f4 $O(n)$","title":"\u7b80\u5355 DP"},{"location":"_problems/_leetcode/300_longest_increasing_subsequence/#dp_1","text":"\u6784\u9020 LIS \u7684\u8fc7\u7a0b\u4e2d\uff0c\u5bf9\u4e8e\u7b49\u957f\u7684 LIS\uff0c\u5e94\u4f7f LIS[-1] \u5c3d\u53ef\u80fd\u5c0f\u3002\u53d7\u6b64\u542f\u53d1\uff0c\u4ee4 $dp_i[k]$ \u8868\u793a $\\mathrm{nums}[0...i]$ \u4e2d\u957f\u4e3a $k+1$ \u7684 LIS[-1] \u7684\u6700\u5c0f\u503c $$ dp_i[k] = \\begin{cases} \\mathrm{nums}[i] & \\text{if } dp_{i-1}[k-1] < \\text{nums}[i]\\leq dp_{i-1}[k] \\\\ dp_{i-1}[k] &\\text{else} \\end{cases} $$ \u5b9e\u9645\u53ea\u9700\u7ef4\u62a4\u4e00\u4e2a\u4e00\u7ef4\u6570\u7ec4\uff0c\u7531\u4e8e $dp_{i-1}[0...\\mathsf{maxLen})$ \u90e8\u5206\u4e00\u5b9a\u662f\u6709\u5e8f\u7684\uff0c\u53ef\u4ee5\u901a\u8fc7\u4e8c\u5206\u67e5\u627e\uff0c\u627e\u5230\u7b2c\u4e00\u4e2a\u5927\u4e8e\u6216\u7b49\u4e8e $\\mathrm{nums}[i]$ \u7684\u5143\u7d20; \u5982\u679c\u67e5\u627e\u5931\u8d25\uff0c\u8bf4\u660e $\\text{nums}[i]$ \u5f88\u5927\uff0c\u9700\u8981\u6269\u5c55 $\\mathsf{maxLen}$ solution public int lengthOfLIS ( int [] nums ) { int [] dp = new int [ nums . length ] ; dp [ 0 ] = nums [ 0 ] ; int maxLen = 1 ; for ( int i = 1 ; i < nums . length ; ++ i ) { int l = 0 , r = maxLen ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( nums [ i ] > dp [ mid ] ) l = mid + 1 ; else if ( nums [ i ] < dp [ mid ] ) r = mid ; else l = r = mid ; } dp [ l ] = nums [ i ] ; maxLen = Math . max ( l + 1 , maxLen ); } return maxLen ; } \u65f6\u95f4 $O(n\\log n)$\uff0c\u7a7a\u95f4 $O(n)$","title":"DP + \u4e8c\u5206"},{"location":"_problems/_leetcode/309_best_time_to_buy_and_sell_stock_with_cooldown/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 prices \uff0c\u5b83\u7684\u7b2c i \u4e2a\u5143\u7d20 prices[i] \u8868\u793a\u4e00\u652f\u7ed9\u5b9a\u80a1\u7968\u7b2c i \u5929\u7684\u4ef7\u683c\u3002 \u8bbe\u8ba1\u4e00\u4e2a\u7b97\u6cd5\u6765\u8ba1\u7b97\u4f60\u6240\u80fd\u83b7\u53d6\u7684\u6700\u5927\u5229\u6da6\u3002\u4f60\u4e0d\u80fd\u540c\u65f6\u53c2\u4e0e\u591a\u7b14\u4ea4\u6613\uff08\u4f60\u5fc5\u987b\u5728\u518d\u6b21\u8d2d\u4e70\u524d\u51fa\u552e\u6389\u4e4b\u524d\u7684\u80a1\u7968\u3002\u4f60\u53ef\u4ee5\u5c3d\u53ef\u80fd\u5730\u5b8c\u6210\u66f4\u591a\u7684\u4ea4\u6613\uff08\u591a\u6b21\u4e70\u5356\u4e00\u652f\u80a1\u7968\uff09 \u5356\u51fa\u80a1\u7968\u540e\uff0c\u4f60\u65e0\u6cd5\u5728\u7b2c\u4e8c\u5929\u4e70\u5165\u80a1\u7968 (\u5373\u51b7\u51bb\u671f\u4e3a 1 \u5929) Example1: \u8f93\u5165: [1,2,3,0,2] \u8f93\u51fa: 3 \u89e3\u91ca: \u5bf9\u5e94\u7684\u4ea4\u6613\u72b6\u6001\u4e3a: [\u4e70\u5165, \u5356\u51fa, \u51b7\u51bb\u671f, \u4e70\u5165, \u5356\u51fa] Note: 1 <= prices.length <= 5000 0 <= prices[i] <= 1000 \u76f8\u8f83\u4e8e 122. best time to sell stock ii \uff0c\u591a\u4e86\u4e00\u4e2a\u51b7\u51bb\u72b6\u6001\u3002\u6cbf\u7528\u5176\u8868\u793a (\u8003\u8651\u7b2c $i$ \u5929\u7ed3\u675f\u65f6)\uff0c\u5e76\u4ee4\u51b7\u51bb\u72b6\u6001\u4e3a 2\uff0c\u8f93\u5165 [1,2,3,0,2] \u5bf9\u5e94\u7684\u72b6\u6001\u5e8f\u5217\u4e3a [1,2,0,1,2] \uff0c\u56e0\u6b64\u6709: $$ dp_2[i] = dp_1[i-1] + prices[i] \\\\ dp_0[i] = \\max\\lbrace \\ dp_0[i-1], \\enspace dp_2[i-1] \\ \\rbrace = \\max\\lbrace \\ dp_0[i-1], \\enspace dp_1[i-2] + prices[i-1] \\ \\rbrace \\\\ dp_1[i] = \\max\\lbrace \\ dp_1[i-1], \\enspace dp_0[i-1] - prices[i] \\ \\rbrace $$ $\\max\\lbrace\\ dp_0[N-1],\\enspace dp_2[N-1]\\ \\rbrace$ \u5373\u4e3a\u6700\u7ec8\u7ed3\u679c solution public int maxProfit ( int [] prices ) { int N = prices . length ; if ( N == 1 ) return 0 ; int [] dp0 = new int [ N ] , dp1 = new int [ N ] ; dp1 [ 0 ] = - prices [ 0 ] ; dp1 [ 1 ] = Math . max ( - prices [ 0 ] , - prices [ 1 ] ); for ( int i = 2 ; i < N ; ++ i ) { dp0 [ i ] = Math . max ( dp0 [ i - 1 ] , dp1 [ i - 2 ] + prices [ i - 1 ] ); dp1 [ i ] = Math . max ( dp1 [ i - 1 ] , dp0 [ i - 1 ] - prices [ i ] ); } return Math . max ( dp0 [ N - 1 ] , dp1 [ N - 2 ] + prices [ N - 1 ] ); }","title":"309. best time to sell stock with cooldown"},{"location":"_problems/_leetcode/31/","text":"\u83b7\u53d6\u7ed9\u5b9a\u6392\u5217\u5728\u5b57\u5178\u5e8f\u4e0a\u76f8\u90bb\u7684\u4e0b\u4e00\u4e2a\u6392\u5217\uff0c\u5982\u679c\u5df2\u662f\u6700\u5927\uff0c\u5219\u83b7\u53d6\u6700\u5c0f\u6392\u5217 \u5fc5\u987b\u539f\u5730\u4fee\u6539\uff0c\u53ea\u5141\u8bb8\u4f7f\u7528\u989d\u5916\u7a7a\u95f4 Example: \u8f93\u5165\uff1anums = [1,2,3] \u8f93\u51fa\uff1a[1,3,2] Note: 1 <= nums.length <= 100 (Medium) \u66f4\u5927\u7684\u76f8\u90bb\u5b57\u5178\u5e8f\u6392\u5217\u7684\u7279\u70b9: \u5e94\u5c3d\u53ef\u80fd\u5c0f\u7684\u589e\u5927\u6392\u5217\uff0c\u5219\u4ece\u4f4e\u4f4d\u5411\u9ad8\u4f4d\u641c\u7d22\uff0c\u5982\u679c num[i] \u5927\u4e8e nums[i+1...] \u4e2d\u4efb\u4e00\u4e2a\u6570\uff0c\u90a3\u4e48 nums[i...] \u4e0d\u53ef\u518d\u589e\u5927 (\u4e14 num[i...] \u80af\u5b9a\u662f\u964d\u5e8f\u7684) \u82e5\u641c\u7d22\u5230 nums[k] \uff0c nums[k+1...] \u4e2d\u5b58\u5728\u67d0\u4e2a\u6570\u6bd4 nums[k] \u5927\uff0c\u5219\u9700\u8981\u4ece nums[k+1...] \u4e2d\u627e\u5230\u6bd4 nums[k] \u5927\u7684\u6700\u5c0f\u7684\u6570\uff0c\u4e0e nums[k] \u6362\u4f4d\uff0c\u518d\u964d\u5e8f\u6392\u5217 nums[k+1...] \u5373\u53ef \u56e0\u6b64\u7b97\u6cd5\u6d41\u7a0b\u4e3a (\u6536\u5f55\u5728 C++ \u7684 next_permutation \u4e2d): \u4ece\u53f3\u5411\u5de6\uff0c\u627e\u5230\u7b2c\u4e00\u4e2a\u4e0d\u6ee1\u8db3 nums[i] >= nums[i+1] \u7684\u6570 \u518d\u4ece\u53f3\u5411\u5de6\uff0c\u627e\u5230\u7b2c\u4e00\u4e2a nums[j] > nums[i] \u7684\u6570 swap(nums[i], nums[j]) \uff0c\u7136\u540e reverse(nums[i+1...]) special case: \u6700\u5927\u6392\u5217\uff0c\u5e26\u6709\u76f8\u540c\u6570\u7684\u6392\u5217 solution class Solution { public : void nextPermutation ( vector < int >& nums ) { int i = nums . size () - 2 ; while ( i >= 0 && nums [ i ] >= nums [ i + 1 ]) { -- i ; } if ( i != -1 ) { int j ; for ( j = nums . size () - 1 ; j > i ; -- j ) { if ( nums [ j ] > nums [ i ]) { break ; } } swap ( nums [ i ], nums [ j ]); } reverse ( nums . begin () + i + 1 , nums . end ()); } }; \u65f6\u95f4 $O(n)$\uff0c\u7a7a\u95f4 $O(1)$","title":"31. next permutation"},{"location":"_problems/_leetcode/310/","text":"\u6811\u662f\u4e00\u4e2a\u65e0\u5411\u56fe\uff0c\u5176\u4e2d\u4efb\u4f55\u4e24\u4e2a\u9876\u70b9\u53ea\u901a\u8fc7\u4e00\u6761\u8def\u5f84\u8fde\u63a5\u3002 \u6362\u53e5\u8bdd\u8bf4\uff0c\u4e00\u4e2a\u4efb\u4f55\u6ca1\u6709\u7b80\u5355\u73af\u8def\u7684\u8fde\u901a\u56fe\u90fd\u662f\u4e00\u68f5\u6811\u3002 \u7ed9\u4f60\u4e00\u68f5\u5305\u542b n \u4e2a\u8282\u70b9\u7684\u6811\uff0c\u6807\u8bb0\u4e3a 0 \u5230 n - 1 \u3002\u7ed9\u5b9a\u6570\u5b57 n \u548c\u4e00\u4e2a\u6709 n - 1 \u6761\u65e0\u5411\u8fb9\u7684 edges \u5217\u8868\uff08\u6bcf\u4e00\u4e2a\u8fb9\u90fd\u662f\u4e00\u5bf9\u6807\u7b7e\uff09\uff0c\u5176\u4e2d edges[i] = [ai, bi] \u8868\u793a\u6811\u4e2d\u8282\u70b9 ai \u548c bi \u4e4b\u95f4\u5b58\u5728\u4e00\u6761\u65e0\u5411\u8fb9\u3002 \u53ef\u9009\u62e9\u6811\u4e2d\u4efb\u4f55\u4e00\u4e2a\u8282\u70b9\u4f5c\u4e3a\u6839\u3002\u5f53\u9009\u62e9\u8282\u70b9 x \u4f5c\u4e3a\u6839\u8282\u70b9\u65f6\uff0c\u8bbe\u7ed3\u679c\u6811\u7684\u9ad8\u5ea6\u4e3a h \u3002\u5728\u6240\u6709\u53ef\u80fd\u7684\u6811\u4e2d\uff0c\u5177\u6709\u6700\u5c0f\u9ad8\u5ea6\u7684\u6811\uff08\u5373\uff0c min(h) \uff09\u88ab\u79f0\u4e3a \u6700\u5c0f\u9ad8\u5ea6\u6811 \u3002 \u8bf7\u4f60\u627e\u5230\u6240\u6709\u7684 \u6700\u5c0f\u9ad8\u5ea6\u6811 \u5e76\u6309 \u4efb\u610f\u987a\u5e8f \u8fd4\u56de\u5b83\u4eec\u7684\u6839\u8282\u70b9\u6807\u7b7e\u5217\u8868\u3002 \u6811\u7684 \u9ad8\u5ea6 \u662f\u6307\u6839\u8282\u70b9\u548c\u53f6\u5b50\u8282\u70b9\u4e4b\u95f4\u6700\u957f\u5411\u4e0b\u8def\u5f84\u4e0a\u8fb9\u7684\u6570\u91cf Example1: \u8f93\u5165\uff1an = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]] \u8f93\u51fa\uff1a[3,4] Example2: \u8f93\u5165\uff1an = 1, edges = [] \u8f93\u51fa\uff1a[0] Note: 1 <= n <= 2 * 104, edges.length == n - 1 0 <= ai, bi < n \u6240\u6709 (ai, bi) \u4e92\u4e0d\u76f8\u540c, \u7ed9\u5b9a\u7684\u8f93\u5165 \u4fdd\u8bc1 \u662f\u4e00\u68f5\u6811\uff0c\u5e76\u4e14 \u4e0d\u4f1a\u6709\u91cd\u590d\u7684\u8fb9 (Medium) \u4e0d\u65ad\u5220\u9664\u5ea6\u4e3a 1 \u7684\u53f6\u8282\u70b9\uff0c\u76f4\u5230\u5269\u4f59\u4e00\u4e2a\u6216\u4e24\u4e2a\u8282\u70b9 (\u56fe\u8bba\u4e2d\u4f3c\u4e4e\u9047\u5230\u8fc7\u7c7b\u4f3c\u7684\u95ee\u9898)\u3002\u9700\u8981\u6ce8\u610f \u9700\u8981\u6309\u8f6e\u6b21\u5220\u9664\u5ea6\u4e3a 1 \u7684\u70b9 \u8fd9\u53ef\u4ee5\u901a\u8fc7\u7c7b\u4f3c BFS \u7684\u65b9\u5f0f\u7528\u961f\u5217\u5b9e\u73b0 (\u4e5f\u53ef\u4ee5\u76f4\u63a5\u7528\u4e24\u4e2a\u5ea6\u6570\u6570\u7ec4\uff0c\u867d\u7136\u590d\u6742\u5ea6\u4e00\u6837\u4f46\u4e0d\u591f\u7b80\u6d01\u4e5f\u66f4\u6162\u4e00\u4e9b)\u3002\u5b9e\u73b0\u65f6\u9700\u8981\u8003\u8651 \u53ea\u6709\u4e00\u4e2a\u70b9\u7684\u60c5\u51b5\uff0c\u53ea\u6709\u4e24\u4e2a\u70b9\u7684\u60c5\u51b5\uff0c\u7b2c\u4e00\u8f6e\u7684\u53f6\u8282\u70b9\u5c0f\u4e8e\u7b49\u4e8e 2 \u7684\u60c5\u51b5 Solution class Solution { public List < Integer > findMinHeightTrees ( int n , int [][] edges ) { List < Integer > result = new ArrayList < Integer > (); if ( n == 1 ) result . add ( 0 ); int [] degrees = new int [ n ] ; List < List < Integer >> graph = new ArrayList <> (); for ( int i = 0 ; i < n ; ++ i ) { graph . add ( new ArrayList < Integer > ()); } for ( int i = 0 ; i < edges . length ; ++ i ) { degrees [ edges [ i ][ 0 ]]++ ; degrees [ edges [ i ][ 1 ]]++ ; graph . get ( edges [ i ][ 0 ] ). add ( edges [ i ][ 1 ] ); graph . get ( edges [ i ][ 1 ] ). add ( edges [ i ][ 0 ] ); } Queue < Integer > queue = new LinkedList < Integer > (); for ( int i = 0 ; i < degrees . length ; ++ i ) { if ( degrees [ i ] == 1 ) { queue . offer ( i ); } } int nRemains = n ; while ( nRemains > 2 ) { int size = queue . size (); nRemains -= size ; for ( int i = 0 ; i < size ; ++ i ) { int leaf = queue . poll (); for ( int neighbor : graph . get ( leaf )) { degrees [ neighbor ]-- ; if ( degrees [ neighbor ] == 1 ) { queue . offer ( neighbor ); } } } } result . addAll ( queue ); return result ; } }","title":"310. minumum height trees"},{"location":"_problems/_leetcode/312/","text":"\u7ed9\u5b9a n \u4e2a\u6807\u6709\u6570\u5b57\u7684\u6c14\u7403\uff0c\u82e5\u6233\u7834\u7b2c i \u4e2a\u6c14\u7403\uff0c\u53ef\u4ee5\u83b7\u5f97 nums[i-1] * nums[i] * nums[i+1] \u679a\u786c\u5e01\uff0c\u8d8a\u754c\u7684\u90e8\u5206\u6309 1 \u8ba1\uff0c\u6c42\u80fd\u83b7\u5f97\u91d1\u5e01\u7684\u6700\u5927\u6570\u91cf Example: \u8f93\u5165\uff1anums = [3,1,5,8] \u8f93\u51fa\uff1a167 \u89e3\u91ca\uff1a nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 Note: 1 <= n <= 500 0 <= nums[i] <= 100 (Hard) \u9996\u5148\uff0c\u4e3e\u51e0\u4e2a\u4f8b\u5b50\u5c31\u77e5\u9053\u65e0\u6cd5\u8d2a\u5fc3\uff1b\u53d7\u5168\u6392\u5217\u7684\u542f\u53d1\uff0cDFS + \u7528\u4f4d\u538b\u7f29\u72b6\u6001\u7684\u65b9\u5f0f\u8bb0\u5fc6\u5316\u641c\u7d22\u4e5f\u4e0d\u53ef\u884c (\u5728\u8fd9\u91cc\u4e5f\u53ef\u4ee5\u8bf4\u662f dp)\uff0c\u8fd9\u8bf4\u660e\u8fd9\u6837\u5efa\u7acb\u72b6\u6001\u7a7a\u95f4\u8fd8\u662f\u592a\u8fc7\u76f4\u767d\u7b80\u5355\u3002\u8003\u8651\u76f4\u63a5\u7528\u533a\u95f4 dp \u7684\u95ee\u9898: dp[i][j] \u8868\u793a nums[i...j) \u5185\u6233\u6c14\u7403\u83b7\u5f97\u6700\u5927\u91d1\u5e01\u6570\uff0c\u6233\u6389\u4e00\u4e2a\u53d8\u6210 dp[i][m] + dp[m+1][j] \u7ee7\u7eed\u6233\uff0c\u95ee\u9898\u5728\u4e8e dp[i, m) \u548c dp[m+1, j) \u4e0d\u662f\u72ec\u7acb\u7684\uff0c\u4e92\u76f8\u9700\u8981\u5bf9\u65b9\u7684\u4fe1\u606f \u6b63\u96be\u5219\u53cd\uff0c\u6233\u6c14\u7403\u5f97\u91d1\u5e01\u8fc7\u7a0b\u662f\u53ef\u9006\u7684\uff0c dp[i][j] \u8868\u793a nums[i...j] \u5185\u53ea\u6709 i \u548c j \u4e24\u4e2a\u4f4d\u7f6e\u7684\u6c14\u7403\u5f52\u4f4d\uff0c\u5269\u4e0b\u7684\u4f4d\u7f6e\u662f\u7a7a\u7684\u60c5\u51b5\u4e0b\uff0c\u653e\u7f6e\u6c14\u7403\u53ef\u4ee5\u83b7\u5f97\u7684\u6700\u5927\u91d1\u5e01\u6570 dp[i][j] = max_m { dp[i][m] + dp[m][j] + nums[m] * nums[m-1] * nums[m+1] } dp[i][i+1] = 0 solution class Solution { public : int maxCoins ( vector < int >& nums ) { vector < int > nums_t = { 1 }; nums_t . insert ( nums_t . end (), nums . begin (), nums . end ()); nums_t . push_back ( 1 ); vector < vector < int >> dp ( nums_t . size (), vector < int > ( nums_t . size ())); for ( int d = 2 ; d < nums_t . size (); ++ d ) { for ( int i = 0 ; i < nums_t . size () - d ; ++ i ) { int left_val = nums_t [ i ], right_val = nums_t [ i + d ]; for ( int j = i + 1 ; j < i + d ; ++ j ) { dp [ i ][ i + d ] = max ( dp [ i ][ i + d ], nums_t [ j ] * left_val * right_val + dp [ i ][ j ] + dp [ j ][ i + d ]); } } } return dp [ 0 ]. back (); } };","title":"312. burst ballons"},{"location":"_problems/_leetcode/313/","text":"\u8d85\u7ea7\u4e11\u6811\u662f\u4e00\u4e2a\u6b63\u6574\u6570\uff0c\u5e76\u6ee1\u8db3\u5176\u6240\u6709\u8d28\u56e0\u6570\u90fd\u51fa\u73b0\u5728\u8d28\u6570\u6570\u7ec4 primes \u4e2d \u7ed9\u5b9a\u6574\u6570 n \u548c\u9012\u589e\u7684\u8d28\u6570\u6570\u7ec4 primes \uff0c\u8fd4\u56de\u7b2c n \u4e2a\u8d85\u7ea7\u4e11\u6570 ` Example: \u8f93\u5165\uff1an = 12, primes = [2,7,13,19] \u8f93\u51fa\uff1a32 \u89e3\u91ca\uff1a\u7ed9\u5b9a\u957f\u5ea6\u4e3a 4 \u7684\u8d28\u6570\u6570\u7ec4 primes = [2,7,13,19]\uff0c \u524d 12 \u4e2a\u8d85\u7ea7\u4e11\u6570\u5e8f\u5217\u4e3a\uff1a[1,2,4,7,8,13,14,16,19,26,28,32] Note: \u7b2c n \u4e2a\u8d85\u7ea7\u4e11\u6570\u4e00\u5b9a\u5728 \u6709\u7b26\u53f7 32-bit \u6574\u6570\u8303\u56f4\u5185 primes[i] \u4e00\u5b9a\u662f\u8d28\u6570\uff0c primes \u5355\u8c03\u9012\u589e\u4e14\u4e92\u4e0d\u76f8\u540c 1 <= n <= 10^6 1 <= primes.length <= 100, 2 <= primes[i] <= 1000 (Medium) \u9898\u76ee\u7684\u5173\u952e\u5728\u4e8e\u5982\u4f55\u6784\u9020\u4e00\u4e2a\u6709\u5e8f\u7684\u4e11\u6570\u5e8f\u5217 \u9996\u5148\uff0c\u6709\u5e8f\u4e11\u6570\u5e8f\u5217\u4e2d\uff0c\u4efb\u610f\u4e11\u6570 i \u4e00\u5b9a\u7531\u67d0\u4e2a\u4e11\u6570 j (j < i) \u4e58\u67d0\u4e2a primes[k] \u5f97\u5230 \u7531\u6b64\u56de\u5230 ugly = [1], primes = [2,3,5] \u7684\u521d\u72b6\u6001\uff0c\u8fdb\u800c\u8054\u60f3\u5230 k \u6307\u9488\u6cd5 k \u6307\u9488\u6cd5\u6d41\u7a0b ( k = primes.length ): \u4ece\u521d\u72b6\u6001\u5f00\u59cb\uff0c\u5728\u5907\u9009\u503c\u4e2d\u627e\u5230\u6700\u5c0f\u503c\uff0c\u52a0\u5165\u4e11\u6570\u7ec4\uff0c\u5e76\u79fb\u52a8\u5bf9\u5e94\u6307\u9488 \u8bba\u8bc1\u6b63\u786e\u6027: \u7531\u4e8e $\\sf ugly[i]=ugly[j]\\times primes[k] (j< i)$\uff0c\u6807 x \u7684\u90e8\u5206\u5df2\u52a0\u5165\u4e86\u4e11\u6570\u7ec4\uff0c\u4e0b\u4e00\u4e2a\u4e11\u6570\u5fc5\u5728\u5269\u4f59\u641c\u7d22\u7a7a\u95f4\u7684\u6700\u5c0f\u503c\u4e2d\u4ea7\u751f \u91cd\u590d\u503c\u5904\u7406: \u82e5\u6700\u5c0f\u503c\u91cd\u590d\uff0c\u6307\u9488\u540c\u65f6\u53f3\u79fb 1 1 2 1 2 3 1 2 3 4 5 2 ==> x 2 ==> x 2 ==> ... ==> x x 2 3 3 x 3 x 3 5 5 5 x 5 \u6bcf\u8f6e\u9009\u53d6\u6700\u5c0f\u503c\u53ef\u7528\u4f18\u5148\u961f\u5217\u4f18\u5316\uff0c\u4e3a\u4fdd\u8bc1\u91cd\u590d\u503c\u7684\u6307\u9488\u90fd\u4f1a\u79fb\u52a8\uff0c\u5c06\u91cd\u590d\u503c\u52a0\u5165\u4f18\u5148\u961f\u5217\uff0c\u5728\u5f39\u51fa\u961f\u5217\u65f6\u7528 hashset \u5224\u91cd\u3002 solution class Solution { private : using UglyQueue = priority_queue < pair < int , int > , vector < pair < int , int >> , greater < pair < int , int >>> ; public : int nthSuperUglyNumber ( int n , vector < int >& primes ) { UglyQueue prior_queue ; unordered_set < int > seen ; vector < int > primes_ptr ( primes . size ()); vector < int > ugly_nums = { 1 }; for ( int i = 0 ; i < primes . size (); ++ i ) { prior_queue . push ( make_pair ( primes [ i ], i )); } while ( ugly_nums . size () < n ) { auto next_pair = prior_queue . top (); prior_queue . pop (); if ( seen . insert ( next_pair . first ). second ) { ugly_nums . push_back ( next_pair . first ); } primes_ptr [ next_pair . second ] ++ ; int alternative_val = primes [ next_pair . second ] * ugly_nums [ primes_ptr [ next_pair . second ]]; prior_queue . push ( make_pair ( alternative_val , next_pair . second )); } return ugly_nums . back (); } }; $n$ \u4e3a\u5f85\u6c42\u4e11\u6570\u7f16\u53f7\uff0c$m$ \u4e3a primes \u957f\u5ea6\uff0c\u65f6\u95f4 $O(n\\log(m))$\uff0c\u7a7a\u95f4\u9700\u8981\u5806\u548c hashset\uff0c\u5171 $O(m+n)$","title":"313. super ugly number"},{"location":"_problems/_leetcode/322_coin_change/","text":"\u7ed9\u5b9a\u4e0d\u540c\u9762\u989d\u7684\u786c\u5e01 coins \u548c\u4e00\u4e2a\u603b\u91d1\u989d amount\u3002\u7f16\u5199\u4e00\u4e2a\u51fd\u6570\u6765\u8ba1\u7b97\u53ef\u4ee5\u51d1\u6210\u603b\u91d1\u989d\u6240\u9700\u7684\u6700\u5c11\u7684\u786c\u5e01\u4e2a\u6570\u3002\u5982\u679c\u6ca1\u6709\u4efb\u4f55\u4e00\u79cd\u786c\u5e01\u7ec4\u5408\u80fd\u7ec4\u6210\u603b\u91d1\u989d\uff0c\u8fd4\u56de -1\u3002 Example1: \u8f93\u5165\uff1acoins = [1, 2, 5], amount = 11 \u8f93\u51fa\uff1a3 \u89e3\u91ca\uff1a11 = 5 + 5 + 1 Example2: \u8f93\u5165\uff1acoins = [2], amount = 3 \u8f93\u51fa\uff1a-1 Note: 1 <= coins.length <= 12 1 <= coins[i] <= 2^31 - 1 0 <= amount <= 10^4 \u5b8c\u5168\u80cc\u5305 + \u6070\u597d\u88c5\u6ee1 + \u6700\u5c0f\u4ef7\u503c dp[i][c] = min { dp[i - 1][c], dp[i][c - coins[i]] + 1 } dp[0][0] = 0, dp[0][1...] = +INF i \u4ece 0 \u5f00\u59cb\u8ba1\u7b97\uff0c dp \u6570\u7ec4\u6b63\u5411\u904d\u5386 coin change public int coinChange ( int [] coins , int amount ) { int [] dp = new int [ amount + 1 ] ; for ( int i = 1 ; i < amount + 1 ; ++ i ) dp [ i ] = 99999 ; for ( int i = 0 ; i < coins . length ; ++ i ) { for ( int c = 0 ; c < amount + 1 ; ++ c ) { if ( c - coins [ i ] >= 0 ) dp [ c ] = min ( dp [ c ] , dp [ c - coins [ i ]] + 1 ); } } return dp [ amount ] >= 99999 ? - 1 : dp [ amount ] ; }","title":"322. coin change"},{"location":"_problems/_leetcode/337/","text":"\u7ed9\u5b9a\u4e8c\u53c9\u6811\u7ed3\u6784\u7684\u91d1\u94b1\u5c0f\u5c4b\uff0c\u5077\u7a83\u8fde\u7eed\u4e24\u4e2a\u5c0f\u5c4b\u7cfb\u7edf\u4f1a\u62a5\u8b66\uff0c\u6c42\u5c0f\u5077\u80fd\u5077\u76d7\u7684\u6700\u9ad8\u91d1\u989d\u3002 Example: \u8f93\u5165: [3,4,5,1,3,null,1] 3 / \\ 4 5 / \\ \\ 1 3 1 \u8f93\u51fa: 9 \u89e3\u91ca: \u5c0f\u5077\u4e00\u665a\u80fd\u591f\u76d7\u53d6\u7684\u6700\u9ad8\u91d1\u989d = 4 + 5 = 9. Note: 1 <= number of nodes <= 10^4 0 <= node.val <= 10^4 (Medium) \u6811\u578b dp\uff0c\u6bcf\u4e2a\u8282\u70b9\u8fd4\u56de\u5305\u62ec\u548c\u4e0d\u5305\u62ec\u8be5\u8282\u70b9\u7684\u5077\u7a83\u65b9\u6848\u3002 solution class Solution { public : int rob ( TreeNode * root ) { auto res = traverse ( root ); return std :: max ( res . first , res . second ); } pair < int , int > traverse ( TreeNode * root ) { if ( root == nullptr ) { return { 0 , 0 }; } auto leftRes = traverse ( root -> left ); auto rightRes = traverse ( root -> right ); int resEx = std :: max ( leftRes . first , leftRes . second ) + std :: max ( rightRes . first , rightRes . second ); int resIn = leftRes . first + rightRes . first + root -> val ; return { resEx , resIn }; } };","title":"337. house robbery iii"},{"location":"_problems/_leetcode/34/","text":"\u7ed9\u5b9a\u5347\u5e8f\u6570\u7ec4 nums \u548c\u76ee\u6807\u503c target \uff0c\u627e\u51fa\u76ee\u6807\u503c\u5728\u7ed9\u5b9a\u6570\u7ec4\u4e2d\u7684\u8d77\u59cb\u4f4d\u7f6e\u548c\u7ed3\u675f\u4f4d\u7f6e\u3002\u5982\u679c\u76ee\u6807\u6570\u7ec4\u4e2d\u4e0d\u5b58\u5728 target \uff0c\u8fd4\u56de [-1, -1] Example: \u8f93\u5165\uff1anums = [5,7,7,8,8,10], target = 8 \u8f93\u51fa\uff1a[3,4] Note: 0 <= nums.length <= 10^5 -10^9 <= nums[i], target <= 10^9 (Medium) \u5178\u578b\u4e8c\u5206\uff0c\u5fc5\u987b\u8981\u4e24\u6b21\u4e8c\u5206\u3002\u4f7f\u7528 stl\uff0c\u53ef\u4ee5 equal_range / lower_bound+upper_bound solution class Solution { public : vector < int > searchRange ( vector < int >& nums , int target ) { auto [ left , right ] = equal_range ( nums . begin (), nums . end (), target ); if ( left == right ) return { -1 , -1 }; int leftIdx = std :: distance ( nums . begin (), left ); int rightIdx = std :: distance ( nums . begin (), right ) - 1 ; return { leftIdx , rightIdx }; } };","title":"34. find first and last position of element in sorted array"},{"location":"_problems/_leetcode/378/","text":"\u7ed9\u5b9a nxn \u77e9\u9635 matrix \uff0c\u6bcf\u884c\u3001\u6bcf\u5217\u5747\u5347\u5e8f\uff0c\u627e\u51fa\u77e9\u9635\u6392\u5e8f\u540e\u7b2c k \u5c0f\u7684\u5143\u7d20\u3002\u7a7a\u95f4\u5fc5\u987b\u5c0f\u4e8e $O(n^2)$ Example1: \u8f93\u5165\uff1amatrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8 \u8f93\u51fa\uff1a13 \u89e3\u91ca\uff1a\u77e9\u9635\u4e2d\u7684\u5143\u7d20\u4e3a [1,5,9,10,11,12,13,13,15]\uff0c\u7b2c 8 \u5c0f\u5143\u7d20\u662f 13 Notes: 1 <= k <= n^2 (Medium) \u601d\u8def: \u76f4\u63a5\u7528\u6700\u5c0f\u5806 n \u8def\u5f52\u5e76: \u65f6\u95f4 $O(k\\log n)$ \u7a7a\u95f4 $O(n)$\uff0c\u4f46\u6ca1\u7528\u4e0a\u5217\u9012\u589e\u7684\u6761\u4ef6 \u6839\u636e 240. \u641c\u7d22\u4e8c\u7ef4\u77e9\u9635 ii\uff0c\u7ed9\u5b9a mid \u53ef\u4ee5\u7edf\u8ba1\u5176\u4e2d\u591a\u5c11\u4e2a\u503c\u5c0f\u4e8e\u7b49\u4e8e mid \uff0c\u6839\u636e\u8fd9\u4e00\u7279\u70b9\u53ef\u4ee5\u5e94\u7528\u4e8c\u5206\u3002(\u4e00\u79cd\u89e3\u6cd5: \u7edf\u8ba1 <=mid \u7684\u6570\u76ee + \u5de6\u95ed\u53f3\u95ed\u5408\u6700\u7ec8\u72b6\u6001 [a,a] + k>n \u65f6\u8df3\u8f6c left=mid+1 ) solution merge class Solution { public : int kthSmallest ( vector < vector < int >> & matrix , int k ) { struct Pair { int x , y , val ; Pair ( int x , int y , int val ) : x ( x ), y ( y ), val ( val ) { } bool operator > ( const Pair & p ) const { return this -> val > p . val ; } }; const int M = matrix . size (), N = matrix [ 0 ]. size (); priority_queue < Pair , vector < Pair > , greater < Pair >> heap ; for ( int i = 0 ; i < M ; ++ i ) { heap . push ( Pair ( i , 0 , matrix [ i ][ 0 ])); } int cnt = 0 ; while ( ! heap . empty ()) { ++ cnt ; Pair top = heap . top (); if ( cnt == k ) { return top . val ; } heap . pop (); if ( top . y < N - 1 ) { heap . push ( Pair ( top . x , top . y + 1 , matrix [ top . x ][ top . y + 1 ])); } } return -1 ; } }; binary search class Solution { public : int numLessThanTarget ( vector < vector < int >> & matrix , int target ) { const int M = matrix . size (), N = matrix [ 0 ]. size (); int i = M - 1 , j = 0 ; int cnt = 0 ; while ( i >= 0 && j < N ) { if ( matrix [ i ][ j ] <= target ) { ++ j ; cnt += i + 1 ; } else { -- i ; } } return cnt ; } int kthSmallest ( vector < vector < int >> & matrix , int k ) { int left = matrix [ 0 ][ 0 ], right = matrix . back (). back (); while ( left < right ) { int mid = left + ( right - left ) / 2 ; int n = numLessThanTarget ( matrix , mid ); if ( k > n ) { left = mid + 1 ; } else { right = mid ; } } return left ; } };","title":"378. kth smallest element in a sorted matrix"},{"location":"_problems/_leetcode/384/","text":"\u7ed9\u5b9a\u65e0\u91cd\u590d\u5143\u7d20\u7684\u6570\u7ec4 nums \uff0cshuffle \u5b83\u3002\u5177\u4f53\u4e3a\u5b9e\u73b0\u7c7b Solution : Solution(int[] nums) \u521d\u59cb\u5316\u5bf9\u8c61 int[] reset() \u91cd\u8bbe\u6570\u7ec4\u5230\u5b83\u7684\u521d\u59cb\u5316\u72b6\u6001\u5e76\u8fd4\u56de int[] shuffle() \u8fd4\u56de\u6570\u7ec4\u968f\u673a\u6253\u4e71\u540e\u7684\u7ed3\u679c Example: \u8f93\u5165 [\"Solution\", \"shuffle\", \"reset\", \"shuffle\"] [[[1, 2, 3]], [], [], []] \u8f93\u51fa [null, [3, 1, 2], [1, 2, 3], [1, 3, 2]] \u89e3\u91ca Solution solution = new Solution([1, 2, 3]); solution.shuffle(); // \u6253\u4e71\u6570\u7ec4 [1,2,3] \u5e76\u8fd4\u56de\u7ed3\u679c\u3002\u4efb\u4f55 [1,2,3]\u7684\u6392\u5217\u8fd4\u56de\u7684\u6982\u7387\u5e94\u8be5 // \u76f8\u540c\u3002\u4f8b\u5982\uff0c\u8fd4\u56de [3, 1, 2] solution.reset(); // \u91cd\u8bbe\u6570\u7ec4\u5230\u5b83\u7684\u521d\u59cb\u72b6\u6001 [1, 2, 3] \u3002\u8fd4\u56de [1, 2, 3] solution.shuffle(); // \u968f\u673a\u8fd4\u56de\u6570\u7ec4 [1, 2, 3] \u6253\u4e71\u540e\u7684\u7ed3\u679c\u3002\u4f8b\u5982\uff0c\u8fd4\u56de [1, 3, 2] Note: 1 <= nums.length <= 200 \u6700\u591a\u53ef\u4ee5\u8c03\u7528 5x10^4 \u6b21 reset \u548c shuffle (Medium) C++ \u4f7f\u7528\u968f\u673a\u6570 \ud83e\uddd0 <cstdlib> \u4e2d\u7684 int rand(void) \u548c void srand(unsigned int seed) \uff0c rand() \u5185\u90e8\u4f7f\u7528\u7ebf\u6027\u540c\u4f59\u5b9e\u73b0 #include <cstdlib> #include <ctime> srand (( unsigne ) time ( nullptr )); int r = ( rand () % ( b - a )) + a ; // [a, b) Solution \ud83e\uddd0 \u9996\u5148\u8003\u8651\u6700 naive \u7684\u65b9\u6cd5: \u4ece\u5f53\u524d\u6570\u7ec4\u968f\u673a\u9009\u62e9\u4e00\u4e2a\u52a0\u5165\u65b0\u6570\u7ec4 \u5728\u5f53\u524d\u6570\u7ec4\u4e2d\u5220\u9664\u88ab\u9009\u62e9\u7684\u5143\u7d20\uff0c\u518d\u968f\u673a\u9009\u62e9\uff0c\u5982\u6b64\u5faa\u73af \u8fd9\u6837\u9700\u8981\u65f6\u95f4 $O(n^2)$ \u548c\u989d\u5916\u7684 $O(n)$ \u7a7a\u95f4\u3002\u6d17\u724c\u7b97\u6cd5 (Fisher-Yates) \u662f\u5bf9\u5b83\u7684\u6539\u8fdb: \u4ece nums[i...end) \u4e2d\u968f\u673a\u9009\u62e9\u4e00\u4e2a\u5143\u7d20 nums[j] (j >= i) \uff0c\u7136\u540e swap(nums[i], nums[j]) \u6539\u8fdb\u540e\u65f6\u95f4 $O(n)$ \u7a7a\u95f4 $O(n)$ ( original \u6570\u7ec4)\u3002\u9a8c\u8bc1\u7ed3\u679c\u7684\u968f\u673a\u6027\u53ef\u4ee5\u901a\u8fc7\u4ece\u539f\u59cb\u7684 nums \u4e2d\u9009\u62e9\u4e00\u4e2a\u5143\u7d20\uff0c\u7136\u540e\u8fdb\u884c\u5927\u91cf\u7684 shuffle() \u7edf\u8ba1\u8be5\u5143\u7d20\u5728\u4e0d\u540c\u4f4d\u7f6e\u51fa\u73b0\u7684\u6b21\u6570\u662f\u5426\u63a5\u8fd1\u3002 solutions naive class Solution { public : Solution ( vector < int >& nums ) : original ( nums ), current ( nums ) { } vector < int > reset () { current = original ; return original ; } vector < int > shuffle () { vector < int > last = current ; for ( int i = 0 ; i < current . size (); ++ i ) { int rmv_idx = rand () % last . size (); current [ i ] = last [ rmv_idx ]; last . erase ( last . begin () + rmv_idx ); } return current ; } private : vector < int > original ; vector < int > current ; }; fisher-yates class Solution { public : Solution ( vector < int >& nums ) : original ( nums ), current ( nums ) { } vector < int > reset () { current = original ; return original ; } vector < int > shuffle () { for ( int i = 0 ; i < current . size (); ++ i ) { int swap_idx = ( rand () % ( current . size () - i )) + i ; swap ( current [ i ], current [ swap_idx ]); } return current ; } private : vector < int > original ; vector < int > current ; };","title":"384. shuffle an array"},{"location":"_problems/_leetcode/384/#c","text":"<cstdlib> \u4e2d\u7684 int rand(void) \u548c void srand(unsigned int seed) \uff0c rand() \u5185\u90e8\u4f7f\u7528\u7ebf\u6027\u540c\u4f59\u5b9e\u73b0 #include <cstdlib> #include <ctime> srand (( unsigne ) time ( nullptr )); int r = ( rand () % ( b - a )) + a ; // [a, b)","title":"C++ \u4f7f\u7528\u968f\u673a\u6570"},{"location":"_problems/_leetcode/384/#solution","text":"\u9996\u5148\u8003\u8651\u6700 naive \u7684\u65b9\u6cd5: \u4ece\u5f53\u524d\u6570\u7ec4\u968f\u673a\u9009\u62e9\u4e00\u4e2a\u52a0\u5165\u65b0\u6570\u7ec4 \u5728\u5f53\u524d\u6570\u7ec4\u4e2d\u5220\u9664\u88ab\u9009\u62e9\u7684\u5143\u7d20\uff0c\u518d\u968f\u673a\u9009\u62e9\uff0c\u5982\u6b64\u5faa\u73af \u8fd9\u6837\u9700\u8981\u65f6\u95f4 $O(n^2)$ \u548c\u989d\u5916\u7684 $O(n)$ \u7a7a\u95f4\u3002\u6d17\u724c\u7b97\u6cd5 (Fisher-Yates) \u662f\u5bf9\u5b83\u7684\u6539\u8fdb: \u4ece nums[i...end) \u4e2d\u968f\u673a\u9009\u62e9\u4e00\u4e2a\u5143\u7d20 nums[j] (j >= i) \uff0c\u7136\u540e swap(nums[i], nums[j]) \u6539\u8fdb\u540e\u65f6\u95f4 $O(n)$ \u7a7a\u95f4 $O(n)$ ( original \u6570\u7ec4)\u3002\u9a8c\u8bc1\u7ed3\u679c\u7684\u968f\u673a\u6027\u53ef\u4ee5\u901a\u8fc7\u4ece\u539f\u59cb\u7684 nums \u4e2d\u9009\u62e9\u4e00\u4e2a\u5143\u7d20\uff0c\u7136\u540e\u8fdb\u884c\u5927\u91cf\u7684 shuffle() \u7edf\u8ba1\u8be5\u5143\u7d20\u5728\u4e0d\u540c\u4f4d\u7f6e\u51fa\u73b0\u7684\u6b21\u6570\u662f\u5426\u63a5\u8fd1\u3002 solutions naive class Solution { public : Solution ( vector < int >& nums ) : original ( nums ), current ( nums ) { } vector < int > reset () { current = original ; return original ; } vector < int > shuffle () { vector < int > last = current ; for ( int i = 0 ; i < current . size (); ++ i ) { int rmv_idx = rand () % last . size (); current [ i ] = last [ rmv_idx ]; last . erase ( last . begin () + rmv_idx ); } return current ; } private : vector < int > original ; vector < int > current ; }; fisher-yates class Solution { public : Solution ( vector < int >& nums ) : original ( nums ), current ( nums ) { } vector < int > reset () { current = original ; return original ; } vector < int > shuffle () { for ( int i = 0 ; i < current . size (); ++ i ) { int swap_idx = ( rand () % ( current . size () - i )) + i ; swap ( current [ i ], current [ swap_idx ]); } return current ; } private : vector < int > original ; vector < int > current ; };","title":"Solution"},{"location":"_problems/_leetcode/386/","text":"\u7ed9\u5b9a\u6574\u6570 n \uff0c\u6309\u5b57\u5178\u5e8f\u8fd4\u56de [1, n] \u5185\u6240\u6709\u6574\u6570 Example: \u8f93\u5165\uff1an = 13 \u8f93\u51fa\uff1a[1,10,11,12,13,2,3,4,5,6,7,8,9] Note: 1 <= n <= 5x10^4 (Medium) \u5b57\u5178\u5e8f\u7684\u5b9a\u4e49: \u4e24\u5b57\u7b26\u4e32\u4ece\u5de6\u5230\u53f3\u9010\u4e2a\u5b57\u7b26\u6bd4\u8f83\uff0c\u76f4\u5230\u9700\u8981\u4e00\u4e2a\u6bd4\u53e6\u4e00\u4e2a\u5927 a < ab \u5b57\u5178\u6811\u7684\u524d\u5e8f\u904d\u5386\u5373\u662f\u5b57\u5178\u5e8f\u3002\u7531\u4e8e\u5b50\u7ed3\u70b9\u90fd\u662f\u786e\u5b9a\u7684\uff0c\u5e76\u4e0d\u9700\u8981\u5b9e\u9645\u5efa trie solution class Solution { public : vector < int > lexicalOrder ( int n ) { vector < int > res ( n ); for ( int i = 1 ; i < 10 ; ++ i ) { traverse ( i , n , res ); } return res ; } void traverse ( int n , int maxN , vector < int >& res ) { if ( n > maxN ) return ; res [ cnt ++ ] = n ; n *= 10 ; if ( n > maxN ) // \u52a0\u901f return ; for ( int i = 0 ; i < 10 ; ++ i ) { traverse ( n + i , maxN , res ); } } private : int cnt = 0 ; };","title":"386. lexicographical numbers"},{"location":"_problems/_leetcode/39/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u65e0\u91cd\u590d\u5143\u7d20\u7684\u6b63\u6574\u6570\u6570\u7ec4 candidates \u548c\u4e00\u4e2a\u6b63\u6574\u6570 target \uff0c\u627e\u51fa candidates \u4e2d\u6240\u6709\u53ef\u4ee5\u4f7f\u6570\u5b57\u548c\u4e3a\u76ee\u6807\u6570 target \u7684\u552f\u4e00\u7ec4\u5408\u3002 candidates \u4e2d\u7684\u6570\u5b57\u53ef\u4ee5\u88ab\u65e0\u9650\u91cd\u590d\u9009\u53d6\uff0c\u5982\u679c\u81f3\u5c11\u4e00\u4e2a\u6240\u9009\u6570\u5b57\u6570\u91cf\u4e0d\u540c\uff0c\u5219\u4e24\u79cd\u7ec4\u5408\u662f\u552f\u4e00\u7684\u3002 Example: \u8f93\u5165: candidates = [2,3,5], target = 8 \u8f93\u51fa: [[2,2,2,2],[2,3,3],[3,5]] Note: 1 <= candiates.length <= 30 1 <= candidates[i] <= 200 candidates \u4e2d\u65e0\u91cd\u590d\u5143\u7d20 (Medium) \u683c\u5f0f\u7c7b\u4f3c\u4e8e\u5b8c\u5168\u80cc\u5305\u95ee\u9898\uff0c\u4ee4 <target, i> \u8868\u793a\u8303\u56f4\u5185\u7684\u6240\u6709\u89e3\uff0c\u5e76\u53c2\u8003\u5176\u72b6\u6001\u7a7a\u95f4\u5212\u5206 <target, i> = <target, i+1> + <target-candidates[i], i> \u76f4\u63a5\u4ece dfs \u51fa\u53d1\u5217\u4e3e\u9012\u5f52\u6811\u7684\u8bdd\uff0c\u8981\u60f3\u907f\u514d\u91cd\u590d\u89e3\uff0c\u5148\u7a77\u4e3e\u6bcf\u4e2a\u5143\u7d20\uff0c\u548c\u8fd9\u79cd\u4e5f\u662f\u7b49\u4ef7\u7684 \u5177\u4f53\u5230\u4ee3\u7801\uff0c\u6784\u5efa\u89e3\u7684\u65b9\u5f0f: \u5b8c\u5168\u9075\u5faa \u300c <t, i> \u7684\u89e3\u7b49\u4e8e <..> \u7684\u89e3\u52a0\u4e0a\u9009\u51e0\u4e2a\u5f53\u524d\u5143\u7d20\u300d,\u5219\u4f7f\u7528\u8fd4\u56de\u503c\u6784\u5efa\u89e3\uff0c\u9012\u5f52\u6811\u4e2d\u6bcf\u4e2a\u8282\u70b9\u90fd\u9700\u8981\u5efa\u4e00\u4e2a vector \uff0c\u8fd8\u8981\u6269\u5bb9\u5b50\u7ed3\u70b9\u7684 vector \uff0c\u6d6a\u8d39 \u5229\u7528\u4f20\u53c2\u53ea\u4f7f\u7528\u4e24\u4e2a vector \uff0c\u6ce8\u610f\u66f4\u65b0\u72b6\u6001 \u65f6\u95f4\u4e3a $O(S)$\uff0c$S$ \u8868\u793a\u6240\u6709\u53ef\u884c\u89e3\u7684\u957f\u5ea6\u4e4b\u548c\uff0c\u7a7a\u95f4\u53d6\u51b3\u4e8e\u7b54\u6848\u6570\u7ec4\u548c\u9012\u5f52\u6808 solution class Solution { public : vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { vector < vector < int >> res ; vector < int > comb ; choose ( candidates , target , 0 , res , comb ); return res ; } void choose ( vector < int >& candidates , int target , int idx , vector < vector < int >> & res , vector < int > & comb ) { if ( target == 0 ) { res . push_back ( comb ); return ; } if ( idx == candidates . size ()) { return ; } choose ( candidates , target , idx + 1 , res , comb ); if ( target - candidates [ idx ] >= 0 ) { comb . push_back ( candidates [ idx ]); choose ( candidates , target - candidates [ idx ], idx , res , comb ); comb . pop_back (); } } };","title":"39. combination sum"},{"location":"_problems/_leetcode/394/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u7ecf\u8fc7\u7f16\u7801\u7684\u5b57\u7b26\u4e32\uff0c\u8fd4\u56de\u89e3\u7801\u540e\u7684\u5b57\u7b26\u4e32\uff0c\u7f16\u7801\u89c4\u5219\u4e3a k[encode_string] Example: \u8f93\u5165\uff1as = \"3[a2[c]]\" \u8f93\u51fa: \"accaccacc\" Note: \u539f\u59cb\u6570\u636e\u4e0d\u5305\u542b\u6570\u5b57\uff0c\u4f8b\u5982\u4e0d\u4f1a\u51fa\u73b0\u5f62\u5982 3a \u6216 2[4] \u7684\u8f93\u5165 s \u4e2d\u7684\u6574\u6570\u5728 [0, 300] \u5185 (Medium) \u7528\u6808\u6a21\u62df\u9012\u5f52\uff0c\u9012\u5f52\u7684\u5f62\u5f0f: func ( s ) : for ( char c : s ) { res = str1 + func ([ ci1 ... cj1 ]) + str2 + func ([ ci2 ... cj2 ]) + ... } \u56e0\u6b64\u601d\u8def\u4e3a: \u7ef4\u62a4\u5f53\u524d\u5b57\u7b26\u4e32\uff0c\u9047\u5230 [ \u5c06\u6570\u5b57\u548c\u5b57\u7b26\u4e32\u5165\u6808\uff0c\u7ef4\u62a4\u65b0\u7684\u5f53\u524d\u5b57\u7b26\u4e32\uff1b\u9047\u5230 ] \u5c06\u5f53\u524d\u5b57\u7b26\u4e32\u4f5c\u4e3a\u7ed3\u679c\u8fd4\u56de\uff0c\u5e76\u4f9d\u6808\u9876\u5143\u7d20\u5904\u7406 solution class Solution { public : string decodeString ( string s ) { stack < int > intStack ; stack < string > stringStack ; string currString ; int val = 0 ; for ( char c : s ) { if ( islower ( c )) { currString . push_back ( c ); } else if ( isdigit ( c )) { val = val * 10 + c - '0' ; } else if ( c == '[' ) { intStack . push ( val ); val = 0 ; stringStack . push ( currString ); currString = \"\" ; } else if ( c == ']' ) { string org = currString ; for ( int i = 0 ; i < intStack . top () - 1 ; ++ i ) { currString += org ; } intStack . pop (); currString = stringStack . top () + currString ; stringStack . pop (); } } return currString ; } };","title":"394. decode string"},{"location":"_problems/_leetcode/40/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 candidates \u548c\u4e00\u4e2a\u6570 target \uff0c\u627e\u51fa candidates \u4e2d\u6240\u6709\u53ef\u4ee5\u4f7f\u6570\u5b57\u548c\u4e3a\u76ee\u6807\u6570 target \u7684\u552f\u4e00\u7ec4\u5408\u3002 candidates \u53ef\u80fd\u6709\u91cd\u590d\u5143\u7d20\uff0c\u4f46\u6bcf\u4e2a\u5143\u7d20\u5728\u6bcf\u4e2a\u7ec4\u5408\u4e2d\u53ea\u80fd\u51fa\u73b0\u4e00\u6b21\u3002 Example: \u8f93\u5165: candidates = [10,1,2,7,6,1,5], target = 8, \u8f93\u51fa: [[1,1,6],[1,2,5],[1,7],[2,6]] Note: 1 <= candiates.length <= 100 1 <= candidates[i] <= 50 (Medium) \u548c 39. \u7ec4\u5408\u603b\u6570 \u7c7b\u4f3c\uff0c\u533a\u522b\u5728\u4e8e: \u672c\u9898\u7c7b\u4f3c\u4e8e 01 \u80cc\u5305 \u9700\u8981\u5904\u7406\u91cd\u590d\u5143\u7d20 \u5b9e\u73b0\u65f6\u6ce8\u610f: \u4f7f\u7528 map \uff0c\u9700\u8981\u4f7f\u7528\u8fed\u4ee3\u5668\uff0c\u4e0d\u592a\u65b9\u4fbf \u4f7f\u7528 sort + vector<pair> \uff0cmap \u4f7f\u7528\u65b9\u4fbf\uff0c\u8fd8\u6b63\u597d\u7528\u6392\u5e8f\u526a\u679d \u5173\u4e8e\u6392\u5e8f\u526a\u679d: \uff1f\uff1f \u590d\u6742\u5ea6: \u6700\u574f\u60c5\u51b5\u4e0b\uff0c\u5047\u8bbe target \u5927\u4e8e\u6240\u6709\u5143\u7d20\u7684\u548c\uff0c\u4e14 candidates \u5185\u6240\u6709\u5143\u7d20\u4e0d\u76f8\u7b49\uff0c\u5219\u65f6\u95f4\u8dd1\u6ee1 $O(2^n \\cdot n)$\uff0c\u5b9e\u9645\u7684\u590d\u6742\u5ea6\u4ee5\u5b9e\u9645\u7ed3\u679c\u4e3a\u51c6 solution best class Solution { public : vector < vector < int >> combinationSum2 ( vector < int > & candidates , int target ) { vector < vector < int >> res ; vector < int > comb ; vector < pair < int , int >> candidatesFreq ; sort ( candidates . begin (), candidates . end ()); for ( int candidate : candidates ) { if ( candidatesFreq . empty () || candidate != candidatesFreq . back (). first ) { candidatesFreq . push_back ({ candidate , 1 }); } else { candidatesFreq . back (). second += 1 ; } } choose ( candidatesFreq , target , 0 , comb , res ); return res ; } void choose ( vector < pair < int , int >> & candidatesFreq , int target , int idx , vector < int > & comb , vector < vector < int >> & res ) { if ( target == 0 ) { res . push_back ( comb ); return ; } if ( idx == candidatesFreq . size ()) { return ; } choose ( candidatesFreq , target , idx + 1 , comb , res ); if ( target >= candidatesFreq [ idx ]. first && candidatesFreq [ idx ]. second > 0 ) { comb . push_back ( candidatesFreq [ idx ]. first ); candidatesFreq [ idx ]. second -= 1 ; choose ( candidatesFreq , target - candidatesFreq [ idx ]. first , idx , comb , res ); candidatesFreq [ idx ]. second += 1 ; comb . pop_back (); } } }; map iterator class Solution { public : vector < vector < int >> combinationSum2 ( vector < int > & candidates , int target ) { vector < vector < int >> res ; vector < int > comb ; unordered_map < int , int > candidatesMap ; for ( int candidate : candidates ) { candidatesMap [ candidate ] ++ ; } choose ( candidatesMap , candidatesMap . begin (), target , comb , res ); return res ; } void choose ( unordered_map < int , int > & candidatesMap , unordered_map < int , int >:: iterator it , int target , vector < int > & comb , vector < vector < int >> & res ) { if ( target == 0 ) { res . push_back ( comb ); return ; } if ( it == candidatesMap . end ()) { return ; } auto nextIt = it ; ++ nextIt ; choose ( candidatesMap , nextIt , target , comb , res ); if ( target >= it -> first && it -> second > 0 ) { comb . push_back ( it -> first ); it -> second -= 1 ; choose ( candidatesMap , it , target - it -> first , comb , res ); it -> second += 1 ; comb . pop_back (); } } };","title":"40. combination sum ii"},{"location":"_problems/_leetcode/41/","text":"\u7ed9\u5b9a\u672a\u6392\u5e8f\u6574\u6570\u6570\u7ec4 nums \uff0c\u627e\u51fa\u5176\u4e2d\u6ca1\u6709\u51fa\u73b0\u7684\u6700\u5c0f\u6b63\u6574\u6570\u3002\u8981\u6c42\u65f6\u95f4 $O(n)$ \u7a7a\u95f4 $O(1)$ Example1: \u8f93\u5165\uff1anums = [1,2,0] \u8f93\u51fa\uff1a3 \u8f93\u5165\uff1anums = [3,4,-1,1] \u8f93\u51fa\uff1a2 \u8f93\u5165\uff1anums = [7,8,9,11,12] \u8f93\u51fa\uff1a1 Note: 1 <= nums.length <= 5x10^5 (Hard) \u666e\u901a\u65b9\u6cd5\u662f\u4e24\u6b21\u904d\u5386\uff0c\u7528 hashset \u8f85\u52a9\uff0c\u4f46\u4e0d\u6ee1\u8db3\u7a7a\u95f4 $O(1)$ \u7684\u9650\u5236\uff0c\u6545\u9700\u8981\u5728\u539f\u6570\u7ec4\u4e0a\u5b9e\u73b0 hash \u8bbe N = arr.length \uff0c\u5219\u7b54\u6848\u9650\u5236\u5728 [1, N+1] \u4e4b\u95f4 \u901a\u8fc7 swap \u5728\u539f\u6570\u7ec4\u5b9e\u73b0 hash\uff0c\u6ce8\u610f\u8003\u8651\u6570\u5b57\u76f8\u540c\u7684\u7279\u6b8a\u60c5\u51b5 solution class Solution { public : int firstMissingPositive ( vector < int > & nums ) { int N = nums . size (); for ( int i = 0 ; i < N ; ++ i ) { while ( nums [ i ] >= 1 && nums [ i ] <= N && nums [ i ] - 1 != i && nums [ i ] != nums [ nums [ i ] - 1 ]) { swap ( nums [ i ], nums [ nums [ i ] - 1 ]); } } for ( int i = 0 ; i < N ; ++ i ) { if ( nums [ i ] != i + 1 ) { return i + 1 ; } } return N + 1 ; } };","title":"41. first missing positive"},{"location":"_problems/_leetcode/410/","text":"\u7ed9\u5b9a\u975e\u8d1f\u6574\u6570\u6570\u7ec4 nums \u548c\u4e00\u4e2a\u6574\u6570 m \uff0c\u5c06\u8fd9\u4e2a\u6570\u7ec4\u5206\u6210 m \u4e2a\u8fde\u7eed\u7684\u975e\u7a7a\u5b50\u6570\u7ec4\u3002\u8bbe\u8ba1\u4e00\u4e2a\u7b97\u6cd5\u4f7f\u5f97 m \u4e2a\u5b50\u6570\u7ec4\u5404\u81ea\u7684\u548c\u7684\u6700\u5927\u503c\u6700\u5c0f\uff0c\u8fd4\u56de\u8fd9\u4e2a\u6700\u5c0f\u503c\u3002 Example: \u8f93\u5165\uff1anums = [7,2,5,10,8], m = 2 \u8f93\u51fa\uff1a18 Note: 1 <= m <= min(50, nums.length) 0 <= nums[i] <= 10^6 (Hard) \u5f88\u5bb9\u6613\u5212\u5206\u641c\u7d22\u72b6\u6001\uff0c\u5148\u5c1d\u8bd5\u52a8\u6001\u89c4\u5212 (\u4ece\u4e00\u7ef4\u5f00\u59cb): dp[i][j] \u8868\u793a\u5bf9 nums[0...j] \u505a i \u6b21\u5212\u5206\u5f97\u5230\u7684\u6700\u5c0f dp[i][j] = min{ max(dp[i-1][k], sum) } \u65f6\u95f4 $O(mn^2)$\uff0c\u7a7a\u95f4 $O(mn)$\uff0c\u65f6\u95f4\u4e0a\u53ef\u4ee5\u63d0\u524d break\uff0c\u7a7a\u95f4\u53ef\u4ee5\u7701\u6389\u4e00\u7ef4 \u7ed9\u5b9a\u4e00\u4e2a\u76ee\u6807\u503c x \uff0c\u53ef\u4ee5\u6c42\u5f97\u5728\u5212\u5206\u7684\u6bcf\u4e2a\u7ec4\u90fd\u4e0d\u8d85\u8fc7 x \u7684\u60c5\u51b5\u4e0b\uff0c\u81f3\u5c11\u80fd\u5212\u5206\u51e0\u7ec4\u3002\u636e\u6b64\u53ef\u76f4\u63a5\u5bf9\u76ee\u6807\u503c\u8fdb\u884c\u4e8c\u5206\u641c\u7d22: \u521d\u59cb\u641c\u7d22\u8303\u56f4 $[\\mathsf{left,\\ right}] = [\\max_i\\lbrace\\mathsf{nums[i]}\\rbrace,\\ \\mathrm{sum}(\\sf nums)]$ \u5982\u679c\u5212\u5206\u6570\u592a\u5c11 splitNum(mid) < m \uff0c\u5411\u5de6\u8df3\u8f6c right = mid \uff0c\u5426\u5219\u5411\u53f3 \u5212\u5206\u6570 \u591a -- -- -- -- \u5c11 \u76ee\u6807\u503c left -- left+1 -- ... mid -- ... -- right \u65f6\u95f4 $O(n\\log (\\mathrm{sum}-\\mathrm{max\\ element}))$\uff0c\u7a7a\u95f4 $O(1)$ \u4e8c\u5206\u641c\u7d22\u7684\u7ec6\u8282: \u76ee\u6807\u72b6\u6001: \u76ee\u6807\u503c\u4e00\u5b9a\u5b58\u5728\uff0c\u4fdd\u6301\u76ee\u6807\u503c\u5728 [left, right] \u5185\u4e14\u6700\u7ec8\u4f7f\u5f97 left = right \u8df3\u8f6c\u4fdd\u6301\u76ee\u6807\u72b6\u6001: \u6b63\u5e38\u60c5\u51b5\u4e0b\u53ef\u4ee5\u4fdd\u6301\uff1b\u7279\u6b8a\u60c5\u51b5\u4e0b\uff0c\u53ef\u80fd\u5b58\u5728\u591a\u4e2a\u503c\u6ee1\u8db3\u76ee\u6807\u503c\u7684\u5212\u5206\u6570\uff0c\u76ee\u6807\u503c\u662f\u8fd9\u4e9b\u6570\u4e2d\u6700\u5c0f\u7684\u90a3\u4e2a\uff0c\u56e0\u6b64\u5f53 splitNum(mid) = m \u65f6\uff0c\u4ee4 right = mid \uff0c\u4e00\u5b9a\u53ef\u4ee5\u4fdd\u6301\u76ee\u6807\u72b6\u6001 \u5212\u5206\u6570 N -- N -- N -- ... \u76ee\u6807\u503c dest -- dest+1 -- dest+2 -- ... \u533a\u95f4\u5212\u5206\u7684\u8fb9\u754c\u60c5\u51b5: \u7565 solution \u2003 dp \u2003 class Solution { public : int splitArray ( vector < int >& nums , int m ) { vector < vector < int >> dp ( m , vector < int > ( nums . size ())); dp [ 0 ][ 0 ] = nums [ 0 ]; for ( int j = 1 ; j < nums . size (); ++ j ) { dp [ 0 ][ j ] = nums [ j ] + dp [ 0 ][ j - 1 ]; } for ( int i = 1 ; i < m ; ++ i ) { for ( int j = i ; j < nums . size (); ++ j ) { int sum = 0 ; dp [ i ][ j ] = INT32_MAX ; for ( int k = j - 1 ; k >= i - 1 ; -- k ) { sum += nums [ k + 1 ]; if ( sum > dp [ i - 1 ][ k ]) { // sum \u9012\u589e\uff0cdp[i-1][k] \u9012\u51cf dp [ i ][ j ] = std :: min ( dp [ i ][ j ], sum ); break ; } else { dp [ i ][ j ] = std :: min ( dp [ i ][ j ], dp [ i - 1 ][ k ]); } } } } return dp [ m - 1 ]. back (); } }; binary search class Solution { public : int splitArray ( vector < int >& nums , int m ) { int left = 0 , right = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { left = std :: max ( left , nums [ i ]); right += nums [ i ]; } while ( left < right ) { // interval: [left, right] int mid = left + ( right - left ) / 2 ; if ( splitNums ( nums , mid , m ) <= m ) { right = mid ; } else { left = mid + 1 ; } } return left ; } int splitNums ( vector < int >& nums , int val , int m ) { int sum = 0 , cnt = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { sum += nums [ i ]; if ( sum > val ) { sum = nums [ i ]; ++ cnt ; } } return cnt + 1 ; } };","title":"410. split array largest sum"},{"location":"_problems/_leetcode/413/","text":"\u5b9a\u4e49: \u5982\u679c\u4e00\u4e2a\u6570\u7ec4\u81f3\u5c11\u6709\u4e09\u4e2a\u5143\u7d20\uff0c\u4e14\u4efb\u610f\u76f8\u90bb\u4e24\u6570\u4e4b\u5dee\u76f8\u540c\uff0c\u79f0\u4e3a\u7b49\u5dee\u6570\u5217 \u7ed9\u5b9a\u6574\u6570\u6570\u7ec4 nums \uff0c\u8fd4\u56de\u6240\u6709\u7b49\u5dee\u5b50\u6570\u7ec4\u7684\u4e2a\u6570\uff0c\u5b50\u6570\u7ec4\u662f\u6570\u7ec4\u4e2d\u7684\u4e00\u4e2a\u8fde\u7eed\u5b50\u5e8f\u5217 Example: \u8f93\u5165\uff1anums = [1,2,3,4] \u8f93\u51fa\uff1a3 \u89e3\u91ca\uff1anums \u4e2d\u6709\u4e09\u4e2a\u5b50\u7b49\u5dee\u6570\u7ec4\uff1a[1, 2, 3]\u3001[2, 3, 4] \u548c [1,2,3,4] \u81ea\u8eab\u3002 Note: 1 <= nums.length <= 5000 -1000 <= nums[i] <= 1000 (Medium) \u53ea\u9700\u8981\u627e\u51fa\u8fde\u7eed\u7684\u7b49\u5dee\u5b50\u5e8f\u5217\uff0c\u4e00\u6b21\u904d\u5386\u80af\u5b9a\u53ef\u4ee5\uff0c\u9996\u5148\u8003\u8651\u57fa\u672c case: [1,2,3,4,10,16,22] [1,2,3,4,10,18,26] \u90a3\u4e48\u80af\u5b9a\u8981\u4ece i=2 \u5f00\u59cb\uff0c\u5224\u65ad\u5f53\u524d\u7684\u5dee\u662f\u5426\u548c\u4e4b\u524d\u7684\u5dee\u76f8\u7b49\uff0c\u4e0d\u76f8\u7b49\u5c31\u65ad\u6389\u5e76\u8ba1\u7b97\u6392\u5217\u4e2a\u6570 \u7b49\u5dee\u5e8f\u5217\u957f\u5ea6\u6bcf\u52a0\u4e00\uff0c\u4e3a\u7ed3\u679c\u8d21\u732e len-2 \uff0c\u5229\u7528\u8fd9\u4e2a\u7279\u70b9\u5b9e\u73b0\u4f1a\u66f4\u52a0\u7b80\u6d01 solution naive class Solution { public : int numberOfArithmeticSlices ( vector < int >& nums ) { if ( nums . size () < 3 ) return 0 ; int res = 0 ; int len = 2 , diff = nums [ 1 ] - nums [ 0 ]; for ( int i = 2 ; i < nums . size (); ++ i ) { int tmp_diff = nums [ i ] - nums [ i - 1 ]; if ( tmp_diff == diff ) { len ++ ; continue ; } res += calArithSubArrSum ( len ); len = 2 ; diff = tmp_diff ; } return res + calArithSubArrSum ( len ); } private : int calArithSubArrSum ( int len ) { return ( len - 1 ) * ( len - 2 ) * 0.5 ; } }; good class Solution { public : int numberOfArithmeticSlices ( vector < int >& nums ) { if ( nums . size () < 3 ) return 0 ; int res = 0 ; int len = 0 , diff = nums [ 1 ] - nums [ 0 ]; for ( int i = 2 ; i < nums . size (); ++ i ) { int tmp_diff = nums [ i ] - nums [ i - 1 ]; if ( tmp_diff == diff ) { len ++ ; } else { len = 0 ; diff = tmp_diff ; } res += len ; } return res ; } };","title":"413. arithmetic slices"},{"location":"_problems/_leetcode/416_partition_equal_subset_sum/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u53ea\u5305\u542b\u6b63\u6574\u6570\u7684\u975e\u7a7a\u6570\u7ec4\u3002\u662f\u5426\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u6570\u7ec4\u5206\u5272\u6210\u4e24\u4e2a\u5b50\u96c6\uff0c\u4f7f\u5f97\u4e24\u4e2a\u5b50\u96c6\u7684\u5143\u7d20\u548c\u76f8\u7b49\u3002 Example: \u8f93\u5165: [1, 5, 11, 5] \u8f93\u51fa: true \u89e3\u91ca: \u6570\u7ec4\u53ef\u4ee5\u5206\u5272\u6210 [1, 5, 5] \u548c [11]. Note: 1 <= nums.length <= 200 1 <= nums[i] <= 100 01 \u80cc\u5305\uff0c\u5224\u65ad\u65b9\u6848\u662f\u5426\u5b58\u5728\u5373\u53ef\uff0c\u6c42\u65b9\u6848\u6570\u4f1a\u5bfc\u81f4\u6ea2\u51fa partition equal subset sum public boolean canPartition ( int [] nums ) { int sum = 0 ; for ( int n : nums ) sum += n ; if ( sum % 2 == 1 ) return false ; sum /= 2 ; boolean [] dp = new boolean [ sum + 1 ] ; dp [ 0 ] = true ; if ( nums [ 0 ] <= sum ) dp [ nums [ 0 ]] = true ; for ( int i = 1 ; i < nums . length ; ++ i ) { for ( int c = sum ; c >= 0 ; -- c ) { if ( c - nums [ i ] >= 0 ) dp [ c ] |= dp [ c - nums [ i ]] ; } } return dp [ sum ] ; }","title":"416. partition equal subset sum"},{"location":"_problems/_leetcode/42/","text":"\u7ed9\u5b9a n \u4e2a\u975e\u8d1f\u6574\u6570\u8868\u793a\u5bbd\u5ea6\u4e3a 1 \u7684\u67f1\u5b50\u9ad8\u5ea6\u56fe\uff0c\u8ba1\u7b97\u6309\u6b64\u6392\u5217\u7684\u67f1\u5b50\u80fd\u63a5\u7eb3\u591a\u5c11\u96e8\u6c34\u3002 Example: \u8f93\u5165\uff1aheight = [0,1,0,2,1,0,1,3,2,1,2,1] \u8f93\u51fa\uff1a6 \u89e3\u91ca\uff1a \u2b1c\u2b1c\u2b1c\u2b1c\u2b1c\u2b1c\u2b1c\u2b1b\ufe0f\u2b1c\u2b1c\u2b1c\u2b1c \u2b1c\u2b1c\u2b1c\u2b1b\ufe0f\ud83d\udfe6\ud83d\udfe6\ud83d\udfe6\u2b1b\ufe0f\u2b1b\ufe0f\ud83d\udfe6\u2b1b\ufe0f\u2b1c \u2b1c\u2b1b\ufe0f\ud83d\udfe6\u2b1b\ufe0f\u2b1b\ufe0f\ud83d\udfe6\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f Note: 1 <= height.length < 2x10^4 0 <= height[i] <= 10^5 (Hard) \u5355\u8c03\u6808 \ud83e\uddd0 \u5355\u8c03\u6808\u7684\u601d\u8def: \u5355\u8c03\u6808\u6309\u964d\u5e8f\u4fdd\u5b58\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u5176\u542b\u4e49\u5982 (1) \u6240\u793a\uff0c\u4e3a\u8ba1\u7b97\u96e8\u6c34\u91cf\uff0c\u7b49\u9ad8\u7684\u67f1\u5b50\u4fdd\u5b58\u6700\u8fd1\u7684\u7d22\u5f15 \u6bcf\u9047\u5230\u4e00\u4e2a\u67f1\u5b50\uff0c\u5148\u8003\u8651\u96e8\u6c34\u586b\u5145\uff0c\u5982 (2) \u6240\u793a\u9700\u8981\u586b\u5145\u4e24\u6b21\uff1b\u518d\u66f4\u65b0\u5355\u8c03\u6808\u7684\u72b6\u6001\uff0c\u5982 (3) \u6240\u793a example (1). stack=[4(3), 2(6)], i=8 (2). stack=[4(3), 2(6)], i=9 (3). stack=[4(1), 2(6)], i=9 \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1c\u2b1c\u2b1c\u2b1c\u2b1c \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1c\u2b1c\u2b1c\u2b1c\u2b1c\u2b1c \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1c\u2b1c\u2b1c\u2b1c\u2b1c\u2b1c \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1c\u2b1c\u2b1c\u2b1c\u2b1c \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1c\u2b1c\u2b1c\u2b1c\u2b1c\u2b1b\ufe0f \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1c\u2b1c \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1c\u2b1c\u2b1b\ufe0f \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1c\u2b1c \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1c\u2b1c\u2b1b\ufe0f \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f solution class Solution { public : int trap ( vector < int >& height ) { int res = 0 ; stack < int > stack ; for ( int i = 0 ; i < height . size (); ++ i ) { if ( height [ i ] == 0 ) { continue ; } if ( stack . empty ()) { stack . push ( i ); continue ; } // \u9047\u5230\u4e00\u4e2a\u67f1\u5b50\uff0c\u4e14\u5355\u8c03\u6808\u975e\u7a7a int lastH = 0 ; while ( ! stack . empty ()) { int h = std :: min ( height [ stack . top ()], height [ i ]); res += ( i - stack . top () - 1 ) * ( h - lastH ); lastH = h ; if ( height [ stack . top ()] > height [ i ]) { // \u5355\u8c03\u6808\u91cc\u6bd4\u5f53\u524d\u9ad8\u7684\u67f1\u5b50 stack . push ( i ); break ; } stack . pop (); } if ( stack . empty ()) { // \u5f53\u524d\u67f1\u5b50\u6bd4\u5355\u8c03\u6808\u91cc\u6240\u6709\u7684\u90fd\u9ad8 stack . push ( i ); } } return res ; } }; \u65f6\u95f4 $O(n)$ \u7a7a\u95f4 $O(n)$ \u52a8\u6001\u89c4\u5212 \ud83e\uddd0 \u6bcf\u4e2a\u4f4d\u7f6e\u586b\u5145\u7684\u96e8\u6c34\u91cf = min(\u5de6\u4fa7\u6700\u9ad8\u67f1\u5b50\uff0c\u53f3\u4fa7\u6700\u9ad8\u67f1\u5b50) - \u8be5\u67f1\u5b50\u9ad8\u5ea6 leftMax[i] : \u2002 [0, i] \u4e2d\u7684\u6700\u5927\u503c rightMax[i] : \u2002 [i, end] \u4e2d\u7684\u6700\u5927\u503c value[i] = min{leftMax[i], rightMax[i]} - height[i] solution class Solution { public : int trap ( vector < int >& height ) { int res = 0 ; vector < int > leftMax ( height . size ()); vector < int > rightMax ( height . size ()); leftMax [ 0 ] = height [ 0 ]; for ( int i = 1 ; i < height . size (); ++ i ) { leftMax [ i ] = std :: max ( leftMax [ i - 1 ], height [ i ]); } rightMax [ height . size () - 1 ] = height [ height . size () - 1 ]; for ( int i = height . size () - 2 ; i >= 0 ; -- i ) { rightMax [ i ] = std :: max ( rightMax [ i + 1 ], height [ i ]); } for ( int i = 1 ; i < height . size () - 1 ; ++ i ) { res += std :: min ( leftMax [ i ], rightMax [ i ]) - height [ i ]; } return res ; } }; \u65f6\u95f4 $O(n)$ \u7a7a\u95f4 $O(n)$ \u53cc\u6307\u9488 \ud83e\uddd0 \u82e5 leftMax[i] < rightMax[j] (\u2200j > i) \uff0c\u5219 leftMax[i] < rightMax[i] \uff0c\u636e\u6b64\uff0c\u52a8\u6001\u89c4\u5212\u7684\u601d\u8def\u53ef\u7b80\u5316\u4e3a\u53cc\u6307\u9488\u5b9e\u73b0 \u521d\u59cb i=0, j=N-1, leftMax=height[i], rightMax=height[j] \u5de6\u6307\u9488 i \u4e0d\u65ad\u53f3\u79fb\uff0c\u76f4\u5230\u6ee1\u8db3 height[i] > height[j] \u53f3\u79fb\u7684\u8fc7\u7a0b\u7b49\u4ef7\u4e8e\u5bfb\u627e\u300c\u6ee1\u8db3 leftMax[i] \u5927\u4e8e rightMax[j] \u7684 i \u300d \u627e\u5230\u8fd9\u6837\u7684 i \u540e\uff0c height[i] \u5fc5\u5b9a\u7b49\u4e8e leftMax[i] \u8be5\u8fc7\u7a0b\u7684\u6240\u6709 leftMax[i'] < rightMax[j] \uff0c\u5219 leftMax[i'] < rightMax[i'] \u53f3\u6307\u9488 j \u4e0d\u65ad\u5de6\u79fb\uff0c\u76f4\u5230\u6ee1\u8db3 height[i] <= height[j] (\u540c\u7406) \u7ec8\u6b62\u6761\u4ef6\u5e94\u4e3a i < j : i == j \u65f6\uff0c\u5047\u8bbe i \u5148\u5230\u8fbe\uff0c height[i] \u5de6\u4fa7\u6700\u9ad8\uff1b j \u5411\u5b83\u9760\u8fd1\uff0c\u5b83\u4e5f\u4e3a\u53f3\u4fa7\u6700\u9ad8\uff0c\u5373 ij \u843d\u5728\u6700\u9ad8\u7684\u67f1\u5b50 \u8fb9\u754c case height=[1] solution class Solution { public : int trap ( vector < int >& height ) { int res = 0 ; int i = 0 , j = height . size () - 1 ; int leftMax = height [ i ], rightMax = height [ j ]; // leftMax[i] & rightMax[j] while ( i < j ) { if ( height [ i ] < height [ j ]) { res += leftMax - height [ i ]; // leftMax[i] < rightMax[i] ++ i ; leftMax = std :: max ( leftMax , height [ i ]); } else { res += rightMax - height [ j ]; // rightMax[j] < leftMax[j] -- j ; rightMax = std :: max ( rightMax , height [ j ]); } } return res ; } }; \u65f6\u95f4 $O(n)$ \u7a7a\u95f4 $O(1)$","title":"42. trapping rain water"},{"location":"_problems/_leetcode/42/#_1","text":"\u5355\u8c03\u6808\u7684\u601d\u8def: \u5355\u8c03\u6808\u6309\u964d\u5e8f\u4fdd\u5b58\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u5176\u542b\u4e49\u5982 (1) \u6240\u793a\uff0c\u4e3a\u8ba1\u7b97\u96e8\u6c34\u91cf\uff0c\u7b49\u9ad8\u7684\u67f1\u5b50\u4fdd\u5b58\u6700\u8fd1\u7684\u7d22\u5f15 \u6bcf\u9047\u5230\u4e00\u4e2a\u67f1\u5b50\uff0c\u5148\u8003\u8651\u96e8\u6c34\u586b\u5145\uff0c\u5982 (2) \u6240\u793a\u9700\u8981\u586b\u5145\u4e24\u6b21\uff1b\u518d\u66f4\u65b0\u5355\u8c03\u6808\u7684\u72b6\u6001\uff0c\u5982 (3) \u6240\u793a example (1). stack=[4(3), 2(6)], i=8 (2). stack=[4(3), 2(6)], i=9 (3). stack=[4(1), 2(6)], i=9 \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1c\u2b1c\u2b1c\u2b1c\u2b1c \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1c\u2b1c\u2b1c\u2b1c\u2b1c\u2b1c \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1c\u2b1c\u2b1c\u2b1c\u2b1c\u2b1c \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1c\u2b1c\u2b1c\u2b1c\u2b1c \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1c\u2b1c\u2b1c\u2b1c\u2b1c\u2b1b\ufe0f \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1c\u2b1c \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1c\u2b1c\u2b1b\ufe0f \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1c\u2b1c \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1c\u2b1c\u2b1b\ufe0f \u2b1c\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f\u2b1b\ufe0f solution class Solution { public : int trap ( vector < int >& height ) { int res = 0 ; stack < int > stack ; for ( int i = 0 ; i < height . size (); ++ i ) { if ( height [ i ] == 0 ) { continue ; } if ( stack . empty ()) { stack . push ( i ); continue ; } // \u9047\u5230\u4e00\u4e2a\u67f1\u5b50\uff0c\u4e14\u5355\u8c03\u6808\u975e\u7a7a int lastH = 0 ; while ( ! stack . empty ()) { int h = std :: min ( height [ stack . top ()], height [ i ]); res += ( i - stack . top () - 1 ) * ( h - lastH ); lastH = h ; if ( height [ stack . top ()] > height [ i ]) { // \u5355\u8c03\u6808\u91cc\u6bd4\u5f53\u524d\u9ad8\u7684\u67f1\u5b50 stack . push ( i ); break ; } stack . pop (); } if ( stack . empty ()) { // \u5f53\u524d\u67f1\u5b50\u6bd4\u5355\u8c03\u6808\u91cc\u6240\u6709\u7684\u90fd\u9ad8 stack . push ( i ); } } return res ; } }; \u65f6\u95f4 $O(n)$ \u7a7a\u95f4 $O(n)$","title":"\u5355\u8c03\u6808"},{"location":"_problems/_leetcode/42/#_2","text":"\u6bcf\u4e2a\u4f4d\u7f6e\u586b\u5145\u7684\u96e8\u6c34\u91cf = min(\u5de6\u4fa7\u6700\u9ad8\u67f1\u5b50\uff0c\u53f3\u4fa7\u6700\u9ad8\u67f1\u5b50) - \u8be5\u67f1\u5b50\u9ad8\u5ea6 leftMax[i] : \u2002 [0, i] \u4e2d\u7684\u6700\u5927\u503c rightMax[i] : \u2002 [i, end] \u4e2d\u7684\u6700\u5927\u503c value[i] = min{leftMax[i], rightMax[i]} - height[i] solution class Solution { public : int trap ( vector < int >& height ) { int res = 0 ; vector < int > leftMax ( height . size ()); vector < int > rightMax ( height . size ()); leftMax [ 0 ] = height [ 0 ]; for ( int i = 1 ; i < height . size (); ++ i ) { leftMax [ i ] = std :: max ( leftMax [ i - 1 ], height [ i ]); } rightMax [ height . size () - 1 ] = height [ height . size () - 1 ]; for ( int i = height . size () - 2 ; i >= 0 ; -- i ) { rightMax [ i ] = std :: max ( rightMax [ i + 1 ], height [ i ]); } for ( int i = 1 ; i < height . size () - 1 ; ++ i ) { res += std :: min ( leftMax [ i ], rightMax [ i ]) - height [ i ]; } return res ; } }; \u65f6\u95f4 $O(n)$ \u7a7a\u95f4 $O(n)$","title":"\u52a8\u6001\u89c4\u5212"},{"location":"_problems/_leetcode/42/#_3","text":"\u82e5 leftMax[i] < rightMax[j] (\u2200j > i) \uff0c\u5219 leftMax[i] < rightMax[i] \uff0c\u636e\u6b64\uff0c\u52a8\u6001\u89c4\u5212\u7684\u601d\u8def\u53ef\u7b80\u5316\u4e3a\u53cc\u6307\u9488\u5b9e\u73b0 \u521d\u59cb i=0, j=N-1, leftMax=height[i], rightMax=height[j] \u5de6\u6307\u9488 i \u4e0d\u65ad\u53f3\u79fb\uff0c\u76f4\u5230\u6ee1\u8db3 height[i] > height[j] \u53f3\u79fb\u7684\u8fc7\u7a0b\u7b49\u4ef7\u4e8e\u5bfb\u627e\u300c\u6ee1\u8db3 leftMax[i] \u5927\u4e8e rightMax[j] \u7684 i \u300d \u627e\u5230\u8fd9\u6837\u7684 i \u540e\uff0c height[i] \u5fc5\u5b9a\u7b49\u4e8e leftMax[i] \u8be5\u8fc7\u7a0b\u7684\u6240\u6709 leftMax[i'] < rightMax[j] \uff0c\u5219 leftMax[i'] < rightMax[i'] \u53f3\u6307\u9488 j \u4e0d\u65ad\u5de6\u79fb\uff0c\u76f4\u5230\u6ee1\u8db3 height[i] <= height[j] (\u540c\u7406) \u7ec8\u6b62\u6761\u4ef6\u5e94\u4e3a i < j : i == j \u65f6\uff0c\u5047\u8bbe i \u5148\u5230\u8fbe\uff0c height[i] \u5de6\u4fa7\u6700\u9ad8\uff1b j \u5411\u5b83\u9760\u8fd1\uff0c\u5b83\u4e5f\u4e3a\u53f3\u4fa7\u6700\u9ad8\uff0c\u5373 ij \u843d\u5728\u6700\u9ad8\u7684\u67f1\u5b50 \u8fb9\u754c case height=[1] solution class Solution { public : int trap ( vector < int >& height ) { int res = 0 ; int i = 0 , j = height . size () - 1 ; int leftMax = height [ i ], rightMax = height [ j ]; // leftMax[i] & rightMax[j] while ( i < j ) { if ( height [ i ] < height [ j ]) { res += leftMax - height [ i ]; // leftMax[i] < rightMax[i] ++ i ; leftMax = std :: max ( leftMax , height [ i ]); } else { res += rightMax - height [ j ]; // rightMax[j] < leftMax[j] -- j ; rightMax = std :: max ( rightMax , height [ j ]); } } return res ; } }; \u65f6\u95f4 $O(n)$ \u7a7a\u95f4 $O(1)$","title":"\u53cc\u6307\u9488"},{"location":"_problems/_leetcode/437/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u4e8c\u53c9\u6811\u7684\u6839\u8282\u70b9 root \uff0c\u548c\u4e00\u4e2a\u6574\u6570 targetSum \uff0c\u6c42\u8be5\u4e8c\u53c9\u6811\u91cc\u8282\u70b9\u503c\u4e4b\u548c\u7b49\u4e8e targetSum \u7684 \u8def\u5f84 \u7684\u6570\u76ee \u8def\u5f84\u4e0d\u9700\u8981\u4ece\u6839\u7ed3\u70b9\u5f00\u59cb\uff0c\u4e5f\u4e0d\u9700\u8981\u5728\u53f6\u8282\u70b9\u7ed3\u675f\uff0c\u4f46\u5fc5\u987b\u662f\u5411\u4e0b\u7684 (\u4ece\u7236\u7ed3\u70b9\u5230\u5b50\u7ed3\u70b9)\u3002 Example: \u8f93\u5165\uff1aroot = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8 \u8f93\u51fa\uff1a3 \u89e3\u91ca\uff1a\u548c\u7b49\u4e8e 8 \u7684\u8def\u5f84\u6709 3 \u6761\uff0c\u5982\u56fe\u6240\u793a \u2003 Note: \u6811\u4e2d\u8282\u70b9\u603b\u6570\u5728\u8303\u56f4 [0, 1000] \u5185 -1000 <= targetSum <= 1000 -10^9 <= Node.val <= 10^9 \u6811\u7684\u904d\u5386 + \u524d\u7f00\u548c\u8ba1\u7b97: \u5148\u5e8f\u65f6\u673a\u53ef\u5f97\u524d\u7f00\u548c\uff0c\u5e76\u8ba1\u7b97\u4ee5\u8be5\u7ed3\u70b9\u7ed3\u5c3e\u7684\u76ee\u6807\u548c\u8def\u5f84\u6811 \u540e\u5e8f\u65f6\u673a\u66f4\u65b0\u524d\u7f00\u548c\u548c\u8def\u5f84\u4fe1\u606f solution class Solution { public : int pathSum ( TreeNode * root , int target_sum ) { traverse ( root , target_sum ); return path_sum ; } private : void traverse ( TreeNode * root , int target_sum ) { if ( ! root ) return ; cur_prefix_sum += root -> val ; auto dst_iter = prefix_sum_map . find ( cur_prefix_sum - target_sum ); if ( dst_iter != prefix_sum_map . end ()) path_sum += dst_iter -> second ; prefix_sum_map [ cur_prefix_sum ] ++ ; traverse ( root -> left , target_sum ); traverse ( root -> right , target_sum ); prefix_sum_map [ cur_prefix_sum ] -- ; cur_prefix_sum -= root -> val ; } unordered_map < int , int > prefix_sum_map {{ 0 , 1 }, }; int cur_prefix_sum = 0 ; int path_sum = 0 ; };","title":"437. path sum iii"},{"location":"_problems/_leetcode/440/","text":"\u7ed9\u5b9a\u6574\u6570 n \u548c k \uff0c\u627e\u5230 1 \u5230 n \u4e2d\u5b57\u5178\u5e8f\u7b2c k \u5c0f\u7684\u6570\u5b57\u3002 Example: \u8f93\u5165: n: 13 k: 2 \u8f93\u51fa: 10 \u89e3\u91ca: \u5b57\u5178\u5e8f\u7684\u6392\u5217\u662f [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]\uff0c\u6240\u4ee5\u7b2c\u4e8c\u5c0f\u7684\u6570\u5b57\u662f 10\u3002 Note: 1 <= k <= n <= 10^9 (Hard) naive \u65b9\u6cd5\u662f\u524d\u5e8f\u904d\u5386 trie (\u65f6\u95f4 $O(k)$)\uff0c\u4f46\u6bcf\u4e2a\u7ed3\u70b9\u7684\u5b50\u7ed3\u70b9\u4e2a\u6570\u53ef\u6c42\uff0c count(int prefix, int n) : \u7ed9\u5b9a\u6570\u5b57\u524d\u7f00 (\u5bf9\u5e94 trie \u7684\u67d0\u4e2a\u7ed3\u70b9) \u548c\u6700\u5927\u8303\u56f4 n \uff0c\u6c42\u8be5\u7ed3\u70b9\u6709\u591a\u5c11\u5b50\u7ed3\u70b9 (\u901a\u8fc7\u533a\u95f4\u5b9e\u73b0) \u6839\u636e count \u7684\u7ed3\u679c\u9009\u62e9\u8fdb\u5165\u4e0b\u4e00\u4e2a\u90bb\u5c45\u8fd8\u662f\u5b50\u7ed3 \u65f6\u95f4 $O(10\\times \\log n \\times \\log n)$\uff0c\u7a7a\u95f4 $O(1)$\uff0c$\\log n$ \u7ea6\u4e3a 0 \u7684\u4e2a\u6570 solution class Solution { public : int findKthNumber ( int n , int k ) { int curNum = 1 , curOrder = 1 ; while ( curOrder != k ) { int cnt = prefixNumberCount ( curNum , n ); if ( k < curOrder + cnt ) { // \u8fdb\u5165\u5b50\u6811\u7b2c\u4e00\u4e2a\u8282\u70b9 curOrder += 1 ; curNum *= 10 ; } else { // \u8fdb\u5165\u4e0b\u4e00\u4e2a\u90bb\u5c45 curOrder += cnt ; curNum ++ ; } } return curNum ; } int prefixNumberCount ( int prefix , int n ) { long first = prefix , last = prefix + 1 ; // interval [first, last) int res = 0 ; while ( first <= n ) { res += std :: min ( last , ( long ) n + 1 ) - first ; first *= 10 ; last *= 10 ; } return res ; } };","title":"440. kth smallest in lexicographical order"},{"location":"_problems/_leetcode/446/","text":"\u7ed9\u5b9a\u6574\u6570\u6570\u7ec4 nums \uff0c\u8fd4\u56de nums \u4e2d\u6240\u6709\u7b49\u5dee\u5b50\u5e8f\u5217\u7684\u6570\u76ee\uff0c\u7ed3\u679c\u4fdd\u8bc1\u662f\u4e00\u4e2a 32-bit \u6574\u6570 \u7ed9\u5b9a A \uff0c\u8fd4\u56de\u5b83\u7684\u6b63\u65b9\u5f62\u6392\u5217\u7684\u6570\u76ee\u3002\u4e24\u4e2a\u6392\u5217 A1 \u548c A2 \u4e0d\u540c\u7684\u5145\u8981\u6761\u4ef6\u662f\u5b58\u5728\u67d0\u4e2a i \uff0c\u4f7f\u5f97 A1[i] != A2[i] Example: \u8f93\u5165\uff1anums = [7,7,7,7,7] \u8f93\u51fa\uff1a16 Note: 1 <= num.length <= 1000 -2^31 <= nums[i] <= 2^31 - 1 (Hard) \u9700\u8981 index \u548c\u516c\u5dee\u4fe1\u606f\u7684\u52a8\u6001\u89c4\u5212 dp[i][d] \u8868\u793a nums[0...i-1] \u4e4b\u95f4\u4ee5 dp[i] \u7ed3\u5c3e\u516c\u5dee\u4e3a d \u7684\u6700\u957f\u7b49\u5dee\u5b50\u5e8f\u5217\u7684\u957f\u5ea6 \u8bd5\u56fe\u6cbf\u7528 413.\u7b49\u5dee\u6570\u5217\u5212\u5206 \u7684\u300c\u5e8f\u5217\u957f\u5ea6\u6bcf\u52a0\u4e00\u5bf9\u7ed3\u679c\u8d21\u732e len-2 \u300d\u7684\u7ed3\u8bba\uff0c\u4f46\u5bf9\u4e8e\u516c\u5dee\u4e3a 0 \u7684\u7b49\u5dee\u5e8f\u5217\u8be5\u7ed3\u8bba\u4e0d\u9002\u7528\uff0c\u9700\u8981\u8ba1\u7b97 $2^n$ \u5f88\u9ebb\u70e6 \u4f8b\u5982\uff0c\u7531 [7,7,7,7] \u589e\u52a0\u4e00\u4e2a 7 \uff0c\u5b50\u5e8f\u5217\u6570\u76ee\u589e\u52a0 $C_n^2+...+C_n^n=2^n-n-1=11$ dp[i][d] \u8868\u793a nums[0...i-1] \u4e4b\u95f4\u4ee5 dp[i] \u7ed3\u5c3e\u516c\u5dee\u4e3a d \u7684\u7b49\u5dee\u5b50\u5e8f\u5217\u6570\u76ee (\u957f\u4e3a 2 \u4e5f\u7b97) \u9700\u8981\u7edf\u8ba1\u957f\u4e3a 2 \u7684\u6570\u76ee\uff0c\u4fdd\u8bc1\u67d0\u4e2a dp[i+?][d] \u53ef\u4ee5\u6b63\u786e\u7edf\u8ba1\u957f\u4e3a 3 \u7684\u7b49\u5dee\u5b50\u5e8f\u5217\u6570\u76ee\uff0c\u4f46 dp[i][d] \u4e2d\u53ea\u6709\u957f\u4e0d\u4e3a 2 \u7684\u90a3\u90e8\u5206\u53ef\u4ee5\u52a0\u5230\u7ed3\u679c\u4e0a solution class Solution { public : int numberOfArithmeticSlices ( vector < int >& nums ) { vector < unordered_map < long , int >> dp ( nums . size ()); int res = 0 ; for ( int i = 1 ; i < nums . size (); ++ i ) { for ( int j = i - 1 ; j >= 0 ; -- j ) { long diff = ( long ) nums [ i ] - nums [ j ]; dp [ i ][ diff ] ++ ; // len=2 auto iter = dp [ j ]. find ( diff ); if ( iter != dp [ j ]. end ()) { dp [ i ][ diff ] += iter -> second ; // len >= 3 res += iter -> second ; } } } return res ; } };","title":"446. arithmetic slices ii subsequence"},{"location":"_problems/_leetcode/447/","text":"\u7ed9\u5b9a\u5e73\u9762\u4e0a n \u4e2a\u70b9\uff0c\u5176\u4e2d points[i]={xi,yi} \uff0c\u56de\u65cb\u9556\u662f\u7531 (i,j,k) \u8868\u793a\u7684\u5143\u7ec4: dist(ponits[i], points[j]) = dist(points[i], points[k]) (\u8981\u8003\u8651\u987a\u5e8f)\uff0c\u6c42\u5e73\u9762\u4e0a\u7684\u56de\u65cb\u9556\u6570\u91cf Example: \u8f93\u5165\uff1apoints = [[0,0],[1,0],[2,0]] \u8f93\u51fa\uff1a2 \u89e3\u91ca\uff1a\u4e24\u4e2a\u56de\u65cb\u9556\u4e3a [[1,0],[0,0],[2,0]] \u548c [[1,0],[2,0],[0,0]] Note: 1 <= points.length <= 500 \u5e73\u9762\u4e0a\u7684\u70b9\u4e92\u4e0d\u76f8\u540c (Medium) \u4f7f\u7528 hashmap \u5bfb\u627e\u548c\u67d0\u4e2a\u70b9\u76f8\u7b49\u7684\u6240\u6709\u70b9\uff0c$C_n^2\\times 2=n\\times (n-1)$ solution class Solution { public : int numberOfBoomerangs ( vector < vector < int >> & points ) { int ans = 0 ; for ( auto & p : points ) { unordered_map < int , int > cnt ; for ( auto & q : points ) { int dis = ( p [ 0 ] - q [ 0 ]) * ( p [ 0 ] - q [ 0 ]) + ( p [ 1 ] - q [ 1 ]) * ( p [ 1 ] - q [ 1 ]); ++ cnt [ dis ]; } for ( auto & [ _ , m ] : cnt ) { ans += m * ( m - 1 ); } } return ans ; } };","title":"447. number of boomerangs"},{"location":"_problems/_leetcode/44_wildcard_matching/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32 s \u548c\u4e00\u4e2a\u5b57\u7b26\u6a21\u5f0f p \uff0c\u5b9e\u73b0\u4e00\u4e2a\u652f\u6301 ? \u548c * \u7684\u901a\u914d\u7b26\u5339\u914d: ? \u53ef\u4ee5\u5339\u914d\u4efb\u4f55\u5355\u4e2a\u5b57\u7b26 * \u53ef\u4ee5\u5339\u914d\u4efb\u610f\u5b57\u7b26\u4e32\uff08\u5305\u62ec\u7a7a\u5b57\u7b26\u4e32 Example1: \u8f93\u5165: s = \"aa\" p = \"*\" \u8f93\u51fa: true Example2: s = \"adceb\" p = \"*a*b\" \u8f93\u51fa: true Note: s \u53ef\u80fd\u4e3a\u7a7a\uff0c\u4e14\u53ea\u5305\u542b\u4ece a-z \u7684\u5c0f\u5199\u5b57\u6bcd p \u53ef\u80fd\u4e3a\u7a7a\uff0c\u4e14\u53ea\u5305\u542b\u4ece a-z \u7684\u5c0f\u5199\u5b57\u6bcd\uff0c\u4ee5\u53ca\u5b57\u7b26 ? \u548c * 1. dp \ud83e\uddd0 \u76f8\u5f53\u4e8e 10. \u6b63\u5219\u5339\u914d \u7684\u7b80\u5316\u7248 $$ dp[i][j] = \\begin{cases} dp[i-1][j-1] \\ \\mathrm{\\ and\\ } \\ (s[i-1] \\mathrm{\\ equals\\ } p[j-1]) & \\mathrm{if}\\ p[j-1] \\ne * \\\\ dp[i][j-1] \\ \\mathrm{\\ or\\ } \\ dp[i-1][j] \\ \\mathrm{\\ or\\ } \\ dp[i-1][j-1] & \\mathrm{else} \\end{cases} $$ wildcard matching public boolean isMatch ( String s , String p ) { int M = s . length (), N = p . length (); boolean [][] dp = new boolean [ M + 1 ][ N + 1 ] ; dp [ 0 ][ 0 ] = true ; for ( int j = 1 ; j < N + 1 ; ++ j ) dp [ 0 ][ j ] = dp [ 0 ][ j - 1 ] && p . charAt ( j - 1 ) == '*' ; for ( int i = 1 ; i < M + 1 ; ++ i ) { for ( int j = 1 ; j < N + 1 ; ++ j ) { if ( p . charAt ( j - 1 ) != '*' ) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] && ( s . charAt ( i - 1 ) == p . charAt ( j - 1 ) || p . charAt ( j - 1 ) == '?' ); else dp [ i ][ j ] = dp [ i ][ j - 1 ] || dp [ i - 1 ][ j ] || dp [ i - 1 ][ j - 1 ] ; } } return dp [ M ][ N ] ; } 2. \u8d2a\u5fc3 \ud83e\uddd0 \u6309\u7167 $*$ \u628a $p$ split \u6210\u591a\u4e2a\u5b50\u4e32\uff0c\u8003\u8651\u67d0\u4e2a\u5b50\u4e32\u4f4d\u4e8e\u4e24\u4e2a $*$ \u4e4b\u95f4\u7684\u60c5\u51b5 $$ \\begin{aligned} p' = p[i-1:] &=\\enspace *\\ p[i:j)\\ *\\ p[j+1:k)\\ *\\ ... \\\\ s' = s[m:] &=\\enspace s[m]\\ s[m+1]\\ ... s[k]\\ ...\\ s[k+j-i]\\ ... \\end{aligned} $$ \u7b80\u5355\u8bc1\u660e\u8be5\u60c5\u51b5\u4e0b\u7684\u8d2a\u5fc3\u9009\u62e9\u6027: \u5047\u8bbe $p[i:j)$ matches $s[k:k+j-i)$ \u662f\u6b63\u5411\u641c\u7d22 $s[m:]$ \u65f6\u7684\u7b2c\u4e00\u4e2a\u6ee1\u8db3\u6761\u4ef6\u7684\u5339\u914d\uff0c\u5982\u679c $s'$ \u5339\u914d $p'$ \u7684\u8bdd\uff0c\u5219\u5b58\u5728\u4e00\u79cd\u5339\u914d\u65b9\u6848\uff0c\u4f7f\u5f97 $*\\ p[i:j)$ matches $s[m:k+j-i)$ \u5047\u8bbe\u6ca1\u6709\u5339\u914d\u65b9\u6848\u5141\u8bb8 $*\\ p[i:j)$ matches $s[m:k+j-i)$\uff0c\u800c\u6709\u65b9\u6848\u5141\u8bb8 $p[i:j)$ matches $s[k':k'+j-i)$\uff0c\u5176\u4e2d $k'\\geq k+1$\uff0c\u8fd9\u8bf4\u660e $*\\ p[j+1:]$ matches $s[k'+j-1:]$ \u6210\u7acb\uff0c\u90a3\u4e48 $*\\ p[j+1:]$ matches $s[k+j-1:]$ \u4e5f\u6210\u7acb\uff0c\u8be5\u65b9\u6848\u4e5f\u5141\u8bb8 $*\\ p[i:j)$ matches $s[m:k+j-i)$ \u4f4d\u4e8e $p$ \u9996\u5c3e\u7684\u5b50\u4e32\u6bd4\u8f83\u7279\u6b8a\uff0c\u4e5f\u5fc5\u987b\u8d34\u7740 $s$ \u7684\u9996\u5c3e\u5339\u914d\uff0c\u56e0\u6b64\u53ef\u4ee5\u5728 $s$ \u548c $p$ \u7684\u9996\u5c3e\u6dfb\u52a0\u76f8\u540c\u7684\u7279\u6b8a\u5b57\u7b26\uff0c\u65e2\u4fdd\u8bc1\u8fd9\u70b9\uff0c\u4e5f\u4fdd\u8bc1 $p$ \u4e0d\u4f1a\u4ee5 $*$ \u5f00\u5934\u6216\u7ed3\u5c3e\u3002\u5982\u679c\u6709\u591a\u4e2a $*$ \u8fde\u7eed\u6392\u5217\uff0c\u6309\u7167\u4e00\u4e2a $*$ \u5904\u7406\u5373\u53ef wildcard matching public boolean isMatch ( String s , String p ) { s = \"S\" + s + \"E\" ; p = \"S\" + p + \"E\" ; String [] subPats = p . split ( \"\\\\*\" ); int sPtr = 0 , j = 0 ; while ( j < subPats . length ) { if ( p . length () == 0 ) { // multiple '*' j += 1 ; continue ; } boolean lose = true ; String subPat = subPats [ j ] ; for ( int i = sPtr ; i <= s . length () - subPat . length (); ++ i ) { if ( naiveMatch ( s , subPat , i )) { sPtr = i + subPat . length (); j += 1 ; lose = false ; break ; } } if ( lose ) return false ; } return sPtr == s . length (); } public boolean naiveMatch ( String s , String p , int si ) { for ( int j = 0 ; j < p . length (); ++ j , ++ si ) if ( p . charAt ( j ) != s . charAt ( si ) && p . charAt ( j ) != '?' ) return false ; return true ; }","title":"44. wildcard matching"},{"location":"_problems/_leetcode/44_wildcard_matching/#1-dp","text":"\u76f8\u5f53\u4e8e 10. \u6b63\u5219\u5339\u914d \u7684\u7b80\u5316\u7248 $$ dp[i][j] = \\begin{cases} dp[i-1][j-1] \\ \\mathrm{\\ and\\ } \\ (s[i-1] \\mathrm{\\ equals\\ } p[j-1]) & \\mathrm{if}\\ p[j-1] \\ne * \\\\ dp[i][j-1] \\ \\mathrm{\\ or\\ } \\ dp[i-1][j] \\ \\mathrm{\\ or\\ } \\ dp[i-1][j-1] & \\mathrm{else} \\end{cases} $$ wildcard matching public boolean isMatch ( String s , String p ) { int M = s . length (), N = p . length (); boolean [][] dp = new boolean [ M + 1 ][ N + 1 ] ; dp [ 0 ][ 0 ] = true ; for ( int j = 1 ; j < N + 1 ; ++ j ) dp [ 0 ][ j ] = dp [ 0 ][ j - 1 ] && p . charAt ( j - 1 ) == '*' ; for ( int i = 1 ; i < M + 1 ; ++ i ) { for ( int j = 1 ; j < N + 1 ; ++ j ) { if ( p . charAt ( j - 1 ) != '*' ) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] && ( s . charAt ( i - 1 ) == p . charAt ( j - 1 ) || p . charAt ( j - 1 ) == '?' ); else dp [ i ][ j ] = dp [ i ][ j - 1 ] || dp [ i - 1 ][ j ] || dp [ i - 1 ][ j - 1 ] ; } } return dp [ M ][ N ] ; }","title":"1. dp"},{"location":"_problems/_leetcode/44_wildcard_matching/#2","text":"\u6309\u7167 $*$ \u628a $p$ split \u6210\u591a\u4e2a\u5b50\u4e32\uff0c\u8003\u8651\u67d0\u4e2a\u5b50\u4e32\u4f4d\u4e8e\u4e24\u4e2a $*$ \u4e4b\u95f4\u7684\u60c5\u51b5 $$ \\begin{aligned} p' = p[i-1:] &=\\enspace *\\ p[i:j)\\ *\\ p[j+1:k)\\ *\\ ... \\\\ s' = s[m:] &=\\enspace s[m]\\ s[m+1]\\ ... s[k]\\ ...\\ s[k+j-i]\\ ... \\end{aligned} $$ \u7b80\u5355\u8bc1\u660e\u8be5\u60c5\u51b5\u4e0b\u7684\u8d2a\u5fc3\u9009\u62e9\u6027: \u5047\u8bbe $p[i:j)$ matches $s[k:k+j-i)$ \u662f\u6b63\u5411\u641c\u7d22 $s[m:]$ \u65f6\u7684\u7b2c\u4e00\u4e2a\u6ee1\u8db3\u6761\u4ef6\u7684\u5339\u914d\uff0c\u5982\u679c $s'$ \u5339\u914d $p'$ \u7684\u8bdd\uff0c\u5219\u5b58\u5728\u4e00\u79cd\u5339\u914d\u65b9\u6848\uff0c\u4f7f\u5f97 $*\\ p[i:j)$ matches $s[m:k+j-i)$ \u5047\u8bbe\u6ca1\u6709\u5339\u914d\u65b9\u6848\u5141\u8bb8 $*\\ p[i:j)$ matches $s[m:k+j-i)$\uff0c\u800c\u6709\u65b9\u6848\u5141\u8bb8 $p[i:j)$ matches $s[k':k'+j-i)$\uff0c\u5176\u4e2d $k'\\geq k+1$\uff0c\u8fd9\u8bf4\u660e $*\\ p[j+1:]$ matches $s[k'+j-1:]$ \u6210\u7acb\uff0c\u90a3\u4e48 $*\\ p[j+1:]$ matches $s[k+j-1:]$ \u4e5f\u6210\u7acb\uff0c\u8be5\u65b9\u6848\u4e5f\u5141\u8bb8 $*\\ p[i:j)$ matches $s[m:k+j-i)$ \u4f4d\u4e8e $p$ \u9996\u5c3e\u7684\u5b50\u4e32\u6bd4\u8f83\u7279\u6b8a\uff0c\u4e5f\u5fc5\u987b\u8d34\u7740 $s$ \u7684\u9996\u5c3e\u5339\u914d\uff0c\u56e0\u6b64\u53ef\u4ee5\u5728 $s$ \u548c $p$ \u7684\u9996\u5c3e\u6dfb\u52a0\u76f8\u540c\u7684\u7279\u6b8a\u5b57\u7b26\uff0c\u65e2\u4fdd\u8bc1\u8fd9\u70b9\uff0c\u4e5f\u4fdd\u8bc1 $p$ \u4e0d\u4f1a\u4ee5 $*$ \u5f00\u5934\u6216\u7ed3\u5c3e\u3002\u5982\u679c\u6709\u591a\u4e2a $*$ \u8fde\u7eed\u6392\u5217\uff0c\u6309\u7167\u4e00\u4e2a $*$ \u5904\u7406\u5373\u53ef wildcard matching public boolean isMatch ( String s , String p ) { s = \"S\" + s + \"E\" ; p = \"S\" + p + \"E\" ; String [] subPats = p . split ( \"\\\\*\" ); int sPtr = 0 , j = 0 ; while ( j < subPats . length ) { if ( p . length () == 0 ) { // multiple '*' j += 1 ; continue ; } boolean lose = true ; String subPat = subPats [ j ] ; for ( int i = sPtr ; i <= s . length () - subPat . length (); ++ i ) { if ( naiveMatch ( s , subPat , i )) { sPtr = i + subPat . length (); j += 1 ; lose = false ; break ; } } if ( lose ) return false ; } return sPtr == s . length (); } public boolean naiveMatch ( String s , String p , int si ) { for ( int j = 0 ; j < p . length (); ++ j , ++ si ) if ( p . charAt ( j ) != s . charAt ( si ) && p . charAt ( j ) != '?' ) return false ; return true ; }","title":"2. \u8d2a\u5fc3"},{"location":"_problems/_leetcode/45/","text":"\u7ed9\u5b9a\u975e\u8d1f\u6574\u6570\u6570\u7ec4 nums \uff0c\u5f00\u59cb\u4f4d\u4e8e\u6570\u7ec4\u7684\u7b2c\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u6570\u7ec4\u4e2d\u6bcf\u4e2a\u5143\u7d20\u4ee3\u8868\u5728\u8be5\u4f4d\u7f6e\u53ef\u4ee5\u8df3\u8dc3\u7684\u6700\u5927\u957f\u5ea6\uff0c\u6c42\u8df3\u5230\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u7684\u6700\u5c11\u8df3\u8dc3\u6b21\u6570 (\u5047\u8bbe\u603b\u662f\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e) Example: \u8f93\u5165: nums = [2,3,1,1,4] \u8f93\u51fa: 2 \u89e3\u91ca: \u8df3\u5230\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u7684\u6700\u5c0f\u8df3\u8dc3\u6570\u662f 2\u3002 \u4ece\u4e0b\u6807\u4e3a 0 \u8df3\u5230\u4e0b\u6807\u4e3a 1 \u7684\u4f4d\u7f6e\uff0c\u8df3 1 \u6b65\uff0c\u7136\u540e\u8df3 3 \u6b65\u5230\u8fbe\u6570\u7ec4\u7684\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u3002 Note: 1 <= nums.length <= 10^4 0 <= nums[i] <= 1000 (Medium) \u6700\u5bb9\u6613\u60f3\u5230\u7684\u662f\u52a8\u6001\u89c4\u5212: dp[i] \u8868\u793a\u4ece nums[0] \u8df3\u5230\u6700\u540e\u6240\u9700\u7684\u6700\u5c11\u6b21\u6570\uff0c\u4f46\u53d1\u73b0 \u5bf9 i < j \uff0c\u6709 dp[i] <= dp[j] \u4ece dp[i] \u5411\u540e\u9009\u4ece\u54ea\u4e2a\u4f4d\u7f6e\u8df3\u8fc7\u6765\uff0c\u9009\u6700\u8fdc\u7684\u90a3\u4e2a\u4e00\u5b9a\u5bf9\uff0c\u5373\u8d2a\u5fc3\u9009\u62e9\u6027 \u4f46\u5411\u540e\u627e\u6700\u8fdc\u7684\u9009\u62e9\u662f\u4ecd\u9700\u8981 $O(n)$\uff0c\u603b\u65f6\u95f4\u4ecd\u4e3a $O(n^2)$\u3002\u672c\u60f3\u524d\u5411\u8003\u8651\u7a7a\u95f4\u6362\u65f6\u95f4\uff0c\u4f46\u5f97\u5230\u66f4\u597d\u7684\u89e3\u6cd5 \u7ef4\u62a4\u4e00\u4e2a\u533a\u95f4 $\\rm [left, right)$\uff0c\u521d\u59cb $\\rm [left, right)=[0, 1)$\uff0c\u533a\u95f4\u5185\u8df3\u6570\u4e3a 0 \u4ece $\\rm [left, right)$ \u5185\u627e\u5230\u80fd\u8df3\u5230\u6700\u8fdc\u7684\u4f4d\u7f6e\uff0c\u83b7\u5f97\u4e0b\u4e00\u4e2a\u533a\u95f4 $\\rm [right, next)$ \u5982\u679c $\\rm next\\leq right$\uff0c\u8bf4\u660e $\\rm [next, end)$ \u5185\u8df3\u6570\u5168\u4e3a 0\uff0c\u8868\u793a\u8df3\u4e0d\u5230\u6700\u540e\u53bb \u65f6\u95f4 $O(n)$\uff0c\u7a7a\u95f4 $O(1)$ solution class Solution { public : int jump ( vector < int >& nums ) { int step = 0 ; int left = 0 , right = 1 ; while ( right < nums . size ()) { int next = 0 ; for ( int i = left ; i < right ; ++ i ) { next = std :: max ( next , nums [ i ] + i ); } ++ step ; left = right ; right = next + 1 ; } return step ; } };","title":"45. jump game ii"},{"location":"_problems/_leetcode/46/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u4e0d\u542b\u91cd\u590d\u6570\u5b57\u7684\u6570\u7ec4 nums \uff0c\u8fd4\u56de\u5176 \u6240\u6709\u53ef\u80fd\u7684\u5168\u6392\u5217 \u3002\u4f60\u53ef\u4ee5 \u6309\u4efb\u610f\u987a\u5e8f \u8fd4\u56de\u7b54\u6848\u3002 Example: \u8f93\u5165\uff1anums = [1,2,3] \u8f93\u51fa\uff1a[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Note: 1 <= nums.length <= 6 nums \u4e2d\u6240\u6709\u6574\u6570\u4e92\u4e0d\u76f8\u540c (Medium) \u9012\u5f52 / DFS: \u9009\u5b9a\u4e00\u4e2a\u6570 + \u751f\u6210\u5269\u4e0b\u7684\u6570\u7684\u5168\u6392\u5217 solution class Solution { public : vector < vector < int >> permute ( vector < int >& nums ) { vector < bool > visited ( nums . size ()); for ( int i = 0 ; i < nums . size (); ++ i ) { genPermutations ( i , nums , visited ); } return res ; } private : void genPermutations ( int num_idx , vector < int >& nums , vector < bool >& visited ) { path . push_back ( nums [ num_idx ]); visited [ num_idx ] = true ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( ! visited [ i ]) { genPermutations ( i , nums , visited ); } } if ( path . size () == nums . size ()) res . push_back ( path ); path . pop_back (); visited [ num_idx ] = false ; } vector < vector < int >> res ; vector < int > path ; }; \u5171 $n!$ \u4e2a\u6392\u5217\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\cdot n!)$\uff0c\u7a7a\u95f4\u4e0a\u9700\u8981\u6807\u8bb0\u6570\u7ec4\u548c\u9012\u5f52\u6df1\u5ea6 $n$\uff0c\u9700\u8981\u7a7a\u95f4 $O(n)$","title":"46. permutations"},{"location":"_problems/_leetcode/47/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u53ef\u5305\u542b\u91cd\u590d\u6570\u5b57\u7684\u5e8f\u5217 nums \uff0c\u6309\u4efb\u610f\u987a\u5e8f \u8fd4\u56de\u6240\u6709\u4e0d\u91cd\u590d\u7684\u5168\u6392\u5217\u3002 Example: \u8f93\u5165\uff1anums = [1,1,2] \u8f93\u51fa\uff1a[[1,1,2], [1,2,1], [2,1,1]] Note: 1 <= nums.length <= 8 -10 <= nums[i] <= 10 (Medium) \u6cbf\u7528 46. permutation \u7684\u9012\u5f52\uff0c\u4f1a\u5bfc\u81f4\u91cd\u590d\u6392\u5217\u5982 {1, 2, 1} \uff0c\u539f\u56e0\u5728\u4e8e\u9012\u5f52\u5230\u67d0\u4e2a\u4f4d\u7f6e\u65f6\u4e24\u4e2a 1 \u88ab\u89c6\u4e3a\u4e0d\u540c\u5355\u4f4d \u89e3\u51b3\u65b9\u6848\u5c31\u662f\u540c\u4e00\u4e2a\u4f4d\u7f6e\u4e0d\u4f1a\u88ab\u76f8\u540c\u7684\u6570\u5360\u636e\u591a\u6b21 \u4e00\u4e2a\u6bd4\u8f83\u597d\u7684\u5b9e\u73b0\u65b9\u5f0f: \u5c06\u6807\u8bb0\u6570\u7ec4\u6539\u9020\u4e3a map<num, count> \u8bb0\u5f55\u6bcf\u4e2a\u6570\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u904d\u5386 map \u8fdb\u884c\u9012\u5f52\uff0c count \u4e3a 0 \u8868\u793a\u6807\u8bb0\u6d88\u5931 solution class Solution { public : vector < vector < int >> permuteUnique ( vector < int >& nums ) { unordered_map < int , int > num2count ; for ( int num : nums ) num2count [ num ] ++ ; for ( auto iter = num2count . cbegin (); iter != num2count . cend (); ++ iter ) { genPermutation ( iter -> first , num2count , nums . size ()); } return res ; } private : void genPermutation ( int num , unordered_map < int , int >& num2count , int size ) { num2count [ num ] -- ; path . push_back ( num ); for ( auto iter = num2count . cbegin (); iter != num2count . cend (); ++ iter ) { if ( iter -> second != 0 ) { genPermutation ( iter -> first , num2count , size ); } } if ( path . size () == size ) res . push_back ( path ); path . pop_back (); num2count [ num ] ++ ; } vector < vector < int >> res ; vector < int > path ; }; \u65f6\u95f4 $O(n\\cdot n!)$\uff0c\u7a7a\u95f4 $O(n)$","title":"47. permutations ii"},{"location":"_problems/_leetcode/474_ones_and_zeroes/","text":"\u7ed9\u4f60\u4e00\u4e2a\u4e8c\u8fdb\u5236\u5b57\u7b26\u4e32\u6570\u7ec4 strs \u548c\u4e24\u4e2a\u6574\u6570 m \u548c n \u3002\u8bf7\u4f60\u627e\u51fa\u5e76\u8fd4\u56de strs \u7684\u6700\u5927\u5b50\u96c6\u7684\u5927\u5c0f\uff0c\u8be5\u5b50\u96c6\u4e2d \u6700\u591a \u6709 m \u4e2a 0 \u548c n \u4e2a 1. \u5982\u679c x \u7684\u6240\u6709\u5143\u7d20\u4e5f\u662f y \u7684\u5143\u7d20\uff0c\u96c6\u5408 x \u662f\u96c6\u5408 y \u7684 \u5b50\u96c6 Example: \u8f93\u5165\uff1astrs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"], m = 5, n = 3 \u8f93\u51fa\uff1a4 \u89e3\u91ca\uff1a\u6700\u591a\u6709 5 \u4e2a 0 \u548c 3 \u4e2a 1 \u7684\u6700\u5927\u5b50\u96c6\u662f {\"10\",\"0001\",\"1\",\"0\"} \uff0c\u56e0\u6b64\u7b54\u6848\u662f 4 \u3002 \u5176\u4ed6\u6ee1\u8db3\u9898\u610f\u4f46\u8f83\u5c0f\u7684\u5b50\u96c6\u5305\u62ec {\"0001\",\"1\"} \u548c {\"10\",\"1\",\"0\"} \u3002 {\"111001\"} \u4e0d\u6ee1\u8db3\u9898\u610f\uff0c\u56e0\u4e3a\u5b83\u542b 4 \u4e2a 1 \uff0c\u5927\u4e8e n \u7684\u503c 3 \u3002 Note: 1 <= strs.length <= 600, \u2002 1 <= strs[i].length <= 100 strs[i] \u4ec5\u7531 '0' \u548c '1' \u7ec4\u6210 1 <= m, n <= 100 \u4e8c\u7ef4 01 \u80cc\u5305\uff0c dp[i][C1][C2] = max{dp[i - 1][C1][C2], dp[i - 1][C1 - nZeros][C2 - nOnes] + 1} ones and zeros public int findMaxForm ( String [] strs , int m , int n ) { int [][] dp = new int [ m + 1 ][ n + 1 ] ; int nZeros0 = getZerosNum ( strs [ 0 ] ); int nOnes0 = strs [ 0 ] . length () - nZeros0 ; for ( int i = 0 ; i < m + 1 ; ++ i ) for ( int j = 0 ; j < n + 1 ; ++ j ) if ( i >= nZeros0 && j >= nOnes0 ) dp [ i ][ j ] = 1 ; for ( int l = 1 ; l < strs . length ; ++ l ) { String str = strs [ l ] ; int nZeros = getZerosNum ( str ); int nOnes = str . length () - nZeros ; for ( int i = m ; i >= 0 ; -- i ) { for ( int j = n ; j >= 0 ; -- j ) { if ( i - nZeros >= 0 && j - nOnes >= 0 ) dp [ i ][ j ] = max ( dp [ i ][ j ] , dp [ i - nZeros ][ j - nOnes ] + 1 ); } } } return dp [ m ][ n ] ; }","title":"474. ones and zeroes"},{"location":"_problems/_leetcode/494_target_sum/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\u6570\u7ec4\uff0ca1, a2, ..., an, \u548c\u4e00\u4e2a\u76ee\u6807\u6570\uff0cS\u3002\u73b0\u5728\u4f60\u6709\u4e24\u4e2a\u7b26\u53f7 + \u548c -\u3002\u5bf9\u4e8e\u6570\u7ec4\u4e2d\u7684\u4efb\u610f\u4e00\u4e2a\u6574\u6570\uff0c\u4f60\u90fd\u53ef\u4ee5\u4ece + \u6216 -\u4e2d\u9009\u62e9\u4e00\u4e2a\u7b26\u53f7\u6dfb\u52a0\u5728\u524d\u9762\u3002 \u8fd4\u56de\u53ef\u4ee5\u4f7f\u6700\u7ec8\u6570\u7ec4\u548c\u4e3a\u76ee\u6807\u6570 S \u7684\u6240\u6709\u6dfb\u52a0\u7b26\u53f7\u7684\u65b9\u6cd5\u6570 Example: \u8f93\u5165\uff1anums: [1, 1, 1, 1, 1], S: 3 \u8f93\u51fa\uff1a5 \u89e3\u91ca\uff1a -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3 Note: \u6570\u7ec4\u975e\u7a7a\uff0c\u4e14\u957f\u5ea6\u4e0d\u4f1a\u8d85\u8fc7 20 \u521d\u59cb\u7684\u6570\u7ec4\u7684\u548c\u4e0d\u4f1a\u8d85\u8fc7 1000 \u4fdd\u8bc1\u8fd4\u56de\u7684\u6700\u7ec8\u7ed3\u679c\u80fd\u88ab 32 \u4f4d\u6574\u6570\u5b58\u4e0b \u7c7b\u4f3c\u4e8e 01 \u80cc\u5305\uff0c \u6570\u7ec4\u548c\u4e0d\u4f1a\u8d85\u8fc7 1000\uff0ci.e. \u7b49\u5f0f\u53d6\u503c\u5728 [-1000, 1000] \u8303\u56f4\u5185\uff0c\u7531\u4e8e\u53d6\u503c\u4f5c\u4e3a\u6570\u7ec4\u7d22\u5f15\u5fc5\u987b\u4e3a\u6b63\uff0c\u53ef\u4ee5\u5047\u8bbe\u4e24\u4fa7\u540c\u52a0 1000 \u7528 dp[i][c] \u8868\u793a [x0,...,xi] \u5185\u548c\u4e3a c \u7684\u65b9\u6848\u6570\uff0c\u5219 dp[i][c] = dp[i - 1][c + nums[i]] + dp[i - 1][c - nums[i]] \u6ce8\u610f nums[0] \u53ef\u80fd\u4e3a 0 target sum public int findTargetSumWays ( int [] nums , int target ) { int MAX = 2001 ; int [] last = new int [ MAX ] ; int [] curr = new int [ MAX ] ; last [ 1000 + nums [ 0 ]] += 1 ; last [ 1000 - nums [ 0 ]] += 1 ; int [] tmp = last ; for ( int i = 1 ; i < nums . length ; ++ i ) { int val = nums [ i ] ; for ( int c = 0 ; c < last . length ; ++ c ) { int last1 = ( c + val > 2000 ) ? 0 : last [ c + val ] ; int last2 = ( c - val < 0 ) ? 0 : last [ c - val ] ; curr [ c ] = last1 + last2 ; } tmp = curr ; curr = last ; last = tmp ; } return tmp [ 1000 + target ] ; }","title":"494. target sum"},{"location":"_problems/_leetcode/498/","text":"\u7ed9\u5b9a\u5927\u5c0f mxn \u7684\u77e9\u9635 mat \uff0c\u4ee5\u5bf9\u89d2\u7ebf\u6b21\u5e8f\uff0c\u8fd4\u56de\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20 Example: \u8f93\u5165\uff1amat = [[1,2,3],[4,5,6],[7,8,9]] \u8f93\u51fa\uff1a[1,2,4,7,5,3,6,8,9] Note: 1 <= m, n <= 10^4 (Medium) \u8003\u8651\u4ece\u54ea\u6761\u8fb9\u51fa\u754c solution class Solution { public : vector < int > findDiagonalOrder ( vector < vector < int >>& mat ) { const int M = mat . size (), N = mat [ 0 ]. size (); vector < int > res ( M * N ); int i = 0 , j = 0 , n = 0 ; while ( i < M || j < N ) { for ( ; i >= 0 && j < N ; -- i , ++ j , ++ n ) res [ n ] = mat [ i ][ j ]; if ( i == M - 2 && j == N ) break ; next ( i , j , M , N ); for ( ; i < M && j >= 0 ; ++ i , -- j , ++ n ) res [ n ] = mat [ i ][ j ]; if ( i == M && j == N - 2 ) break ; next ( i , j , M , N ); } return res ; } void next ( int & i , int & j , int M , int N ) { if ( j == N ) { i += 2 ; j = N - 1 ; } else if ( i == -1 ) { i = 0 ; } else if ( i == M ) { i = M - 1 ; j += 2 ; } else if ( j == -1 ) { j = 0 ; } } };","title":"498. diagonal traverse"},{"location":"_problems/_leetcode/503/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5faa\u73af\u6570\u7ec4\uff0c\u8f93\u51fa\u6bcf\u4e2a\u5143\u7d20\u7684\u4e0b\u4e00\u4e2a\u66f4\u5927\u5143\u7d20\u3002\u5982\u679c\u4e0d\u5b58\u5728\u8f93\u51fa -1 \u3002 Example: \u8f93\u5165: [1,2,1] \u8f93\u51fa: [2,-1,2] Note: 1 <= nums.length <= 10^4 -10^9 <= nums[i] <= 10^9 (Medium) \u5355\u8c03\u6808\uff0c\u5e76\u5c06\u6570\u7ec4\u5c55\u5f00\u4e3a [0...2n-2] \uff0c\u786e\u4fdd\u4efb\u610f nums[i] \u90fd\u80fd\u8fdb\u884c\u4e00\u4e2a\u5468\u671f \u5982\u679c nums[0] \u5728 [0...n-1] \u4e2d\u627e\u5230\u7b2c\u4e00\u4e2a\u5927\u4e8e\u5b83\u7684\u503c\uff0c\u90a3\u4e48 nums[n % N] \u5165\u6808\u7ed3\u679c\u4e00\u6837 \u5982\u679c res[0]=-1 \uff0c\u4e5f\u4e0d\u5f71\u54cd \u6545\u5c55\u5f00\u53ea\u662f\u4f1a\u9020\u6210\u91cd\u590d\uff0c\u4e0d\u5f71\u54cd\u7ed3\u679c\u3002\u65f6\u95f4 $O(n)$ \u7a7a\u95f4 $O(n)$ solution class Solution { public : vector < int > nextGreaterElements ( vector < int >& nums ) { const int N = nums . size (); stack < int > monoStack ; vector < int > res ( N , -1 ); for ( int i = 0 ; i <= 2 * N - 2 ; ++ i ) { while ( ! monoStack . empty () && nums [ monoStack . top ()] < nums [ i % N ]) { res [ monoStack . top ()] = nums [ i % N ]; monoStack . pop (); } monoStack . push ( i % N ); } return res ; } };","title":"503"},{"location":"_problems/_leetcode/518_coin_change_2/","text":"\u7ed9\u5b9a\u4e0d\u540c\u9762\u989d\u7684\u786c\u5e01\u548c\u4e00\u4e2a\u603b\u91d1\u989d\u3002\u5199\u51fa\u51fd\u6570\u6765\u8ba1\u7b97\u53ef\u4ee5\u51d1\u6210\u603b\u91d1\u989d\u7684\u786c\u5e01\u7ec4\u5408\u6570\u3002\u5047\u8bbe\u6bcf\u4e00\u79cd\u9762\u989d\u7684\u786c\u5e01\u6709\u65e0\u9650\u4e2a\u3002 Example1: \u8f93\u5165: amount = 5, coins = [1, 2, 5] \u8f93\u51fa: 4 Example2: \u8f93\u5165: amount = 3, coins = [2] \u8f93\u51fa: 0 Note: 0 <= amount <= 5000, 1 <= coin <= 5000 \u786c\u5e01\u79cd\u7c7b <= 500, \u7ed3\u679c\u7b26\u5408\u6709\u7b26\u53f7 int \u5b8c\u5168\u80cc\u5305 + \u6c42\u65b9\u6848\u6570 + \u6070\u597d\u88c5\u6ee1: dp[i][c] = dp[i-1][c] + dp[i][c - coins[i]] dp[0][0] = 1 , dp[0][1...] = 0 i \u4ece 0 \u5f00\u59cb\u8ba1\u7b97\uff0c dp \u6570\u7ec4\u6b63\u5411\u904d\u5386 coin change 2 public int change ( int amount , int [] coins ) { int [] dp = new int [ amount + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < coins . length ; ++ i ) { for ( int c = 0 ; c < amount + 1 ; ++ c ) { if ( c - coins [ i ] >= 0 ) dp [ c ] += dp [ c - coins [ i ]] ; } } return dp [ amount ] ; }","title":"518. coin change 2"},{"location":"_problems/_leetcode/526/","text":"\u7ed9\u5b9a\u4ece 1 \u5230 N \u7684 N \u4e2a\u6574\u6570\uff0c\u6784\u9020\u4e00\u4e2a\u6570\u7ec4\uff0c\u82e5\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6\u4e4b\u4e00\uff0c\u5219\u79f0\u4e3a\u4f18\u7f8e\u6392\u5217: \u7b2c i \u4f4d\u7684\u6570\u5b57\u80fd\u88ab i \u6574\u9664 i \u80fd\u88ab\u7b2c i \u4f4d\u4e0a\u7684\u6570\u5b57\u6574\u9664 \u73b0\u7ed9\u5b9a N \uff0c\u6c42\u4f18\u7f8e\u6392\u5217\u7684\u4e2a\u6570 Note: 1 <= N <= 15 (Medium) \u6392\u5217 DFS\uff0c\u7531\u4e8e N <= 15 \uff0c\u53ef\u4ee5\u8bb0\u5fc6\u641c\u7d22\u72b6\u6001 memo[00101010] \u8868\u793a\u300c\u524d\u4e09\u4f4d\u7531 246 \u968f\u610f\u6392\u5217\uff0c\u5269\u4e0b\u968f\u610f\u300d\u7684\u4f18\u7f8e\u6392\u5217\u6570 \u81ea\u9876\u5411\u4e0b\u7684\u641c\u7d22\u5bf9\u5e94\u4e00\u4e2a\u81ea\u5e95\u5411\u4e0a\u52a8\u6001\u89c4\u5212 dp[00101010] \u8868\u793a \u300c\u524d\u4e09\u4f4d\u7531 246 \u968f\u610f\u6392\u5217\uff0c\u4e14\u4ec5\u770b\u524d\u4e09\u4f4d\u300d\u7684\u4f18\u7f8e\u6392\u5217\u6570\uff0c\u548c memo \u7684\u8868\u793a\u6b63\u76f8\u53cd \u8fd9\u6837\u8868\u793a\u66f4\u65b9\u4fbf\uff0c\u76f4\u63a5\u9012\u589e mask \u5373\u53ef \u7528\u5230\u4e86 gcc \u81ea\u5e26\u7684 __builtin_popcount \u51fd\u6570\uff0c\u8fd9\u91cc\u77e5\u9053\u5b83\u81f3\u5c11\u6709 $O(n)$ \u5373\u53ef\uff0c\u5b9e\u9645\u4e0a\u5185\u90e8\u7528\u4e86\u67e5\u8868\u5e94\u8be5\u66f4\u5feb\u3002C++20 \u5f15\u5165\u4e86 std::popcount \uff0c\u73b0\u4ee3\u5904\u7406\u5668\u90fd\u6709 POPCNT \u6307\u4ee4 solution DFS (\u672a\u4f18\u5316 match) class Solution { public : int countArrangement ( int n ) { vector < int > visited_val ( n ); int res = 0 ; for ( int v = 1 ; v <= n ; ++ v ) { if ( match ( 1 , v )) { res += count ( 1 , v , visited_val , n ); } } return res ; } private : bool match ( int a , int b ) { return ( a % b == 0 ) || ( b % a == 0 ); } int count ( int loc , int val , vector < int >& visited_val , int n ) { if ( loc == n ) return 1 ; visited_val [ val - 1 ] = 1 ; int res = 0 ; for ( int next_val = 1 ; next_val <= n ; ++ next_val ) { if ( visited_val [ next_val - 1 ] == 0 && match ( loc + 1 , next_val )) { res += count ( loc + 1 , next_val , visited_val , n ); } } visited_val [ val - 1 ] = 0 ; return res ; } }; \u72b6\u6001\u538b\u7f29 - \u8bb0\u5fc6\u5316\u641c\u7d22 class Solution { public : int countArrangement ( int n ) { bitset < 16 > visited_val ; vector < int > memo ( 1 << n , -1 ); int res = 0 ; for ( int v = 1 ; v <= n ; ++ v ) { if ( match ( 1 , v )) { res += count ( 1 , v , visited_val , memo , n ); } } return res ; } private : bool match ( int a , int b ) { return ( a % b == 0 ) || ( b % a == 0 ); } int count ( int loc , int val , bitset < 16 >& visited_val , vector < int >& memo , int n ) { if ( loc == n ) return 1 ; visited_val . set ( val - 1 ); int memo_val = memo [ visited_val . to_ulong ()]; if ( memo_val != -1 ) { visited_val . reset ( val - 1 ); return memo_val ; } int res = 0 ; for ( int next_val = 1 ; next_val <= n ; ++ next_val ) { if ( ! visited_val . test ( next_val - 1 ) && match ( loc + 1 , next_val )) { res += count ( loc + 1 , next_val , visited_val , memo , n ); } } memo [ visited_val . to_ulong ()] = res ; visited_val . reset ( val - 1 ); return res ; } }; \u52a8\u6001\u89c4\u5212 class Solution { public : int countArrangement ( int n ) { vector < int > dp ( 1 << n ); dp [ 0 ] = 1 ; for ( int mask = 1 ; mask < ( 1 << n ); ++ mask ) { int loc = __builtin_popcount ( mask ); for ( int i = 0 ; i < n ; ++ i ) { int val = i + 1 ; if ( mask & ( 1 << i ) && ( loc % val == 0 || val % loc == 0 )) { dp [ mask ] += dp [ mask - ( 1 << i )]; } } } return dp [( 1 << n ) - 1 ]; } }; \u590d\u6742\u5ea6: \u666e\u901a DFS: \u2002 \u65f6\u95f4 $O(n!)$\uff0c\u7a7a\u95f4 $O(n)$\uff0c\u82e5\u4f18\u5316 match \u5219\u4e3a $O(n^2)$ \u72b6\u6001\u538b\u7f29: \u2002 \u672c\u8d28\u4e3a\u586b\u8868\uff0c\u6bcf\u6b21\u586b\u8868\u9700\u8981\u5411\u4e0b\u9012\u5f52 $O(n)$ \u6b21\uff0c\u65f6\u95f4 $O(n\\cdot 2^n)$\uff0c\u7a7a\u95f4 $O(2^n)$ DP: \u2002 \u65f6\u95f4 $O(n\\cdot 2^n)$\uff0c\u7a7a\u95f4 $O(2^n)$","title":"526. beautiful arrangement"},{"location":"_problems/_leetcode/53_maximum_subarray/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 nums \uff0c\u627e\u5230\u4e00\u4e2a\u5177\u6709\u6700\u5927\u548c\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\uff08\u5b50\u6570\u7ec4\u6700\u5c11\u5305\u542b\u4e00\u4e2a\u5143\u7d20\uff09\uff0c\u8fd4\u56de\u5176\u6700\u5927\u548c\u3002 Example1: \u8f93\u5165\uff1anums = [-2,1,-3,4,-1,2,1,-5,4] \u8f93\u51fa\uff1a6 \u89e3\u91ca\uff1a\u8fde\u7eed\u5b50\u6570\u7ec4 [4,-1,2,1] \u7684\u548c\u6700\u5927\uff0c\u4e3a 6 \u3002 Note: 1 <= nums.length <= 3 * 10^4 -10^5 <= nums[i] <= 10^5 DP \ud83e\uddd0 \u4ee4 $dp[i]$ \u8868\u793a\u4ee5 $\\mathrm{nums}[i]$ \u7ed3\u5c3e\u7684\u6700\u5927\u5b50\u6570\u7ec4\u7684\u548c\uff0c\u5219: $$ dp[i] = \\max\\lbrace \\ dp[i-1]+\\mathrm{nums}[i],\\enspace \\mathrm{nums}[i] \\ \\rbrace $$ solution public int maxSubArray ( int [] nums ) { int sum = nums [ 0 ] ; int maxSum = sum ; for ( int i = 1 ; i < nums . length ; ++ i ) { sum = Math . max ( sum + nums [ i ] , nums [ i ] ); maxSum = Math . max ( sum , maxSum ); } return maxSum ; }","title":"53. maximum subarray"},{"location":"_problems/_leetcode/53_maximum_subarray/#dp","text":"\u4ee4 $dp[i]$ \u8868\u793a\u4ee5 $\\mathrm{nums}[i]$ \u7ed3\u5c3e\u7684\u6700\u5927\u5b50\u6570\u7ec4\u7684\u548c\uff0c\u5219: $$ dp[i] = \\max\\lbrace \\ dp[i-1]+\\mathrm{nums}[i],\\enspace \\mathrm{nums}[i] \\ \\rbrace $$ solution public int maxSubArray ( int [] nums ) { int sum = nums [ 0 ] ; int maxSum = sum ; for ( int i = 1 ; i < nums . length ; ++ i ) { sum = Math . max ( sum + nums [ i ] , nums [ i ] ); maxSum = Math . max ( sum , maxSum ); } return maxSum ; }","title":"DP"},{"location":"_problems/_leetcode/543/","text":"\u4e8c\u53c9\u6811\u7684\u76f4\u5f84: \u2002 \u4efb\u610f\u4e24\u4e2a\u7ed3\u70b9\u4e4b\u95f4\u7684\u8def\u5f84\u957f\u5ea6\u7684\u6700\u5927\u503c\u3002 Example: \u8f93\u5165\uff1a 1 / \\ 2 3 / \\ 4 5 \u8f93\u51fa\uff1a3 \u89e3\u91ca\uff1a[4,2,1,3] or [5,2,1,3] Note: 1 <= n <= 10^4 -100 <= node.val <= 100 (Medium) \u7ecf\u5178\u6811\u578b dp: dp[x]: \u2002 \u6700\u5927\u6df1\u5ea6\uff0c dp[x] = max{dp[x->left], dp[x->right]} + 1 max[x] = max{x->val + dp[x->left] + dp[x->right], max[x]} solution class Solution { public : int diameterOfBinaryTree ( TreeNode * root ) { traverse ( root ); return diameter - 1 ; } int traverse ( TreeNode * root ) { if ( root == nullptr ) return 0 ; int lSum = traverse ( root -> left ); int rSum = traverse ( root -> right ); diameter = max ( lSum + rSum + 1 , diameter ); return max ( lSum , rSum ) + 1 ; } private : int diameter = 1 ; };","title":"543. diameter of binary tree"},{"location":"_problems/_leetcode/55/","text":"\u7ed9\u5b9a\u975e\u8d1f\u6574\u6570\u6570\u7ec4 nums \uff0c\u5f00\u59cb\u4f4d\u4e8e\u6570\u7ec4\u7684\u7b2c\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u6570\u7ec4\u4e2d\u6bcf\u4e2a\u5143\u7d20\u4ee3\u8868\u5728\u8be5\u4f4d\u7f6e\u53ef\u4ee5\u8df3\u8dc3\u7684\u6700\u5927\u957f\u5ea6\uff0c\u5224\u65ad\u80fd\u5426\u8df3\u5230\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e Example1: \u8f93\u5165\uff1anums = [2,3,1,1,4] \u8f93\u51fa\uff1atrue Example2: \u8f93\u5165\uff1anums = [3,2,1,0,4] \u8f93\u51fa\uff1afalse Note: 1 <= nums.length <= 3x10^4 0 <= nums[i] <= 10^5 (Medium) \u5982\u679c nums \u5168\u4e3a\u6b63\u6570\uff0c\u5c31\u4e00\u5b9a\u53ef\u4ee5\u8df3\u5230\u6700\u540e\uff0c\u8df3\u4e0d\u5230\u6700\u540e\u7684\u539f\u56e0\u5728\u4e8e nums \u67d0\u5904\u6709 0 \u7ef4\u62a4\u533a\u95f4 $\\rm [i+1, end]$\uff0c\u53ea\u8981\u80fd\u8df3\u5230\u8be5\u533a\u95f4\u5185\uff0c\u5c31\u80fd\u8df3\u5230\u6700\u540e\uff0c\u521d\u59cb $\\rm i=end-1$ \u9012\u51cf $\\rm i$ \u76f4\u5230\u9047\u5230 0\uff0c\u5c31\u4ece $\\rm i-1$ \u5f00\u59cb\u5bfb\u627e\u662f\u5426\u80fd\u4ece\u67d0\u4e2a\u4f4d\u7f6e\u8df3\u5230 $\\rm [i+1, end]$ \u65f6\u95f4 $O(n)$\uff0c\u7a7a\u95f4 $O(1)$\u3002\u7528 \u8df3\u8dc3\u6e38\u620f ii \u7684\u65b9\u6cd5\u4e5f\u80fd\u5224\u65ad\u8df3\u4e0d\u8fc7\u6765\u7684\u60c5\u51b5 solution class Solution { public : bool canJump ( vector < int >& nums ) { for ( int i = nums . size () - 2 ; i >= 0 ; ) { if ( nums [ i ] > 0 ) { -- i ; } else { int j = i - 1 ; for (; j >= 0 ; -- j ) { if ( nums [ j ] + j > i ) { break ; } } if ( j == -1 ) { return false ; } i = j - 1 ; } } return true ; } };","title":"55. jump game"},{"location":"_problems/_leetcode/554/","text":"\u7ed9\u5b9a\u77e9\u5f62\u7684\u7531 n \u884c\u7816\u5757\u7ec4\u6210\u7684\u5899\uff0c\u7816\u5757\u9ad8\u5ea6\u76f8\u540c\uff0c\u5bbd\u5ea6\u4e0d\u540c\uff0c\u4f46\u6bcf\u4e00\u884c\u7816\u5757\u5bbd\u5ea6\u4e4b\u548c\u76f8\u7b49\u3002 \u73b0\u9700\u8981\u753b\u4e00\u6761\u81ea\u9876\u5411\u4e0b\u7684\u7ebf\uff0c\u8981\u6c42\u7a7f\u8fc7\u6700\u5c11\u7816\u5757\uff0c\u7a7f\u8fc7\u7816\u7f1d\u4e0d\u89c6\u4e3a\u7a7f\u8fc7\u7816\u5757\uff0c\u7ebf\u4e0d\u80fd\u753b\u5728\u4e24\u8fb9\u3002 Example1: \u8f93\u5165\uff1awall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]] \u8f93\u51fa\uff1a2 \u8f93\u5165\uff1awall = [[1],[1],[1]] \u8f93\u51fa\uff1a3 Note: (Medium) \u904d\u5386\u4e00\u904d\u5e76\u8bb0\u5f55 solution class Solution { public : int leastBricks ( vector < vector < int >> & wall ) { const int M = wall . size (); int brickNum = M ; unordered_map < int , int > colMap ; for ( int i = 0 ; i < wall . size (); ++ i ) { int sum = 0 ; for ( int j = 0 ; j < wall [ i ]. size () - 1 ; ++ j ) { sum += wall [ i ][ j ]; colMap [ sum ] += 1 ; brickNum = min ( brickNum , M - colMap [ sum ]); } } return brickNum ; } };","title":"554. brick wall"},{"location":"_problems/_leetcode/556/","text":"\u7ed9\u5b9a\u6b63\u6574\u6570 n \uff0c\u627e\u51fa\u7b26\u5408\u6761\u4ef6\u7684\u6700\u5c0f\u6574\u6570\uff0c\u7531 n \u7684\u6570\u5b57\u91cd\u6392\u7ec4\u6210\u4e14\u503c\u5927\u4e8e n \uff0c\u82e5\u4e0d\u5b58\u5728\u5219\u8fd4\u56de -1 \u3002 \u5982\u679c\u5b58\u5728\u7b26\u5408\u8981\u6c42\u7684\u7b54\u6848\uff0c\u4f46\u4e0d\u662f 32 \u4f4d\u6574\u6570\uff0c\u540c\u6837\u8fd4\u56de -1 \u3002 Example: \u8f93\u5165\uff1an = 12 \u8f93\u51fa\uff1a21 Note: 1 <= n <= 2^31-1 (Medium) \u548c 31. next permutation \u4e00\u6837\u3002\u641c\u7d22\u65f6\u53ef\u7528\u4e8c\u5206\u641c\u7d22\uff0c\u4f46\u4ecd\u9700\u8981\u65f6\u95f4 $O(n)$\uff0c\u65e0\u592a\u5927\u610f\u4e49 solution class Solution { public : int nextGreaterElement ( int n ) { string nStr = to_string ( n ); for ( int i = nStr . size () - 2 ; i >= 0 ; -- i ) { if ( nStr [ i ] >= nStr [ i + 1 ]) continue ; for ( int j = nStr . size () - 1 ; j >= i + 1 ; -- j ) { if ( nStr [ j ] > nStr [ i ]) { swap ( nStr [ i ], nStr [ j ]); break ; } } std :: reverse ( nStr . begin () + i + 1 , nStr . end ()); long res = std :: stol ( nStr ); if ( res > INT32_MAX ) { break ; } return ( int ) res ; } return -1 ; } };","title":"556. next greater element iii"},{"location":"_problems/_leetcode/560/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\u6570\u7ec4\u548c\u4e00\u4e2a\u6574\u6570 k \uff0c\u4f60\u9700\u8981\u627e\u5230\u8be5\u6570\u7ec4\u4e2d\u548c\u4e3a k \u7684\u8fde\u7eed\u7684\u5b50\u6570\u7ec4\u7684\u4e2a\u6570 Example: \u8f93\u5165:nums = [1,1,1], k = 2 \u8f93\u51fa: 2 , [1,1] \u4e0e [1,1] \u4e3a\u4e24\u79cd\u4e0d\u540c\u7684\u60c5\u51b5\u3002 Note: 1 < nums.length <= 2 * 10^4 -1000 <= nums[i] <= 1000 -10^7 <= k <= 10^7 (Medium) solution: naive \u601d\u8def: \u76f4\u63a5\u4e24\u5c42\u904d\u5386\uff0c\u65f6\u95f4 $O(n^2)$ \u7a7a\u95f4 $O(1)$ \u8bb0\u5f55\u5404\u4e2a\u4f4d\u7f6e\u7684\u524d\u7f00\u548c\uff0c\u4e24\u4e2a\u4f4d\u7f6e\u7684\u524d\u7f00\u548c\u4e4b\u5dee\u5bf9\u5e94\u4e00\u6bb5\u5b50\u533a\u95f4\u7684\u548c\uff0c\u56e0\u6b64\u53ef\u4ee5\u5f15\u5165 hashmap \u6362\u65f6\u95f4 \u6ce8\u610f\u9700\u8981\u5047\u5b9a\u6570\u7ec4\u524d\u6709\u4e00\u4e2a\u4e3a 0 \u7684\u524d\u7f00\u548c\uff0c\u53ef\u4ee5\u53d6\u5230\u4ece nums[0] \u5f00\u59cb\u7684\u533a\u95f4 solution class Solution { public : int subarraySum ( vector < int >& nums , int k ) { unordered_map < int , int > prefix_sum_map ; int prefix_sum = 0 , cont_sum = 0 ; prefix_sum_map [ 0 ] ++ ; for ( int i = 0 ; i < nums . size (); ++ i ) { prefix_sum += nums [ i ]; auto dst_iter = prefix_sum_map . find ( prefix_sum - k ); if ( dst_iter != prefix_sum_map . end ()) { cont_sum += dst_iter -> second ; } prefix_sum_map [ prefix_sum ] ++ ; } return cont_sum ; } }; \u65f6\u95f4 $O(n)$ \u7a7a\u95f4 $O(n)$","title":"560. subarrray sum equals k"},{"location":"_problems/_leetcode/57/","text":"\u7ed9\u5b9a\u65e0\u91cd\u53e0\u7684\u3001\u6309\u533a\u95f4\u8d77\u59cb\u7aef\u70b9\u6392\u5217\u7684\u5217\u8868\uff0c\u5728\u5217\u8868\u4e2d\u63d2\u5165\u7ed9\u5b9a\u7684\u65b0\u533a\u95f4\uff0c\u9700\u8981\u786e\u4fdd\u6709\u5e8f\u4e0d\u91cd\u53e0 (\u53ef\u80fd\u53d1\u751f\u5408\u5e76) Example1: \u8f93\u5165\uff1aintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] \u8f93\u51fa\uff1a[[1,2],[3,10],[12,16]] \u89e3\u91ca\uff1a\u8fd9\u662f\u56e0\u4e3a\u65b0\u7684\u533a\u95f4 [4,8] \u4e0e [3,5],[6,7],[8,10] \u91cd\u53e0\u3002 Example2: \u8f93\u5165\uff1aintervals = [], newInterval = [5,7] \u8f93\u51fa\uff1a[[5,7]] Note: 0 <= intervals.length <= 10000 (Medium) \u6a21\u62df\u9898\uff0c\u6ce8\u610f\u8003\u8651\u5404\u79cd test case: \u5728\u672b\u5c3e\u76f4\u63a5\u63d2\u5165\u3001\u8986\u76d6\u533a\u95f4\u7684\u6700\u540e\u4e00\u9879\u5728\u672b\u5c3e... solution class Solution { public : vector < vector < int >> insert ( vector < vector < int >>& intervals , vector < int >& newInterval ) { vector < vector < int >> res ; int i ; for ( i = 0 ; i < intervals . size (); ++ i ) { if ( intervals [ i ][ 1 ] < newInterval [ 0 ]) // less than res . push_back ( intervals [ i ]); else break ; } if ( i == intervals . size ()) { res . push_back ( newInterval ); return res ; } int j = i ; if ( intervals [ i ][ 0 ] > newInterval [ 1 ]) { // more than res . push_back ( newInterval ); res . push_back ( intervals [ i ]); } else { for (; j < intervals . size (); ++ j ) { if ( j == intervals . size () - 1 || intervals [ j + 1 ][ 0 ] > newInterval [ 1 ]) { break ; } } // intervals[i...j]: \u548c newInterval \u6709\u4ea4\u96c6\u7684\u96c6\u5408\u4eec res . push_back ({ min ( intervals [ i ][ 0 ], newInterval [ 0 ]), max ( intervals [ j ][ 1 ], newInterval [ 1 ])}); } for ( int k = j + 1 ; k < intervals . size (); ++ k ) { res . push_back ( intervals [ k ]); } return res ; } };","title":"57. insert interval"},{"location":"_problems/_leetcode/576/","text":"\u7ed9\u5b9a\u5927\u5c0f\u4e3a mxn \u7684\u7f51\u683c\u548c\u7403\u7684\u8d77\u59cb\u5750\u6807 [startRow, startColumn] \uff0c\u6700\u591a\u53ef\u4ee5\u79fb\u52a8 maxMove \u6b21\u7403\uff0c\u6c42\u53ef\u4ee5\u5c06\u7403\u79fb\u51fa\u8fb9\u754c\u7684\u8def\u5f84\u6570\u3002(\u8fd4\u56de\u5bf9 10^9 + 7 \u53d6\u4f59\u540e\u7684\u7ed3\u679c) \u2003\u2003 Note: 1 <= m, n <= 50 0 <= maxMove <= 50 (Medium) \u601d\u8def\u6bd4\u8f83\u5bb9\u6613\u60f3\u5230: dp[i][j][k] \u8868\u793a\u4ece grid[startRow][startColumn] \u5230 grid[i][j] \u957f\u4e3a k \u7684\u8def\u5f84\u6570 dp[i][j][k] = dp[i-1][j][k-1] + dp[i+1][j][k-1] + dp[i][j-1][k-1] + dp[i][j+1][k] init: \u2002 dp[startRow][startColumn][0] = 1 , dp[..][..][0] = 0 \u4e0d\u8981 fanchun: \u5728\u56db\u5468\u52a0\u683c\u5b50\u4e0d\u884c\uff0c\u4f1a\u591a\u51fa\u4e0d\u5b58\u5728\u7684\u8def\u5f84 \u7edf\u8ba1\u7ed3\u679c\u65f6\u6570\u8fb9\u800c\u4e0d\u662f\u6570\u683c\u5b50 loop [1, maxMove - 1] : { cal dp; add res; } \uff0c\u5f88\u660e\u663e 0 \u4f5c\u4e3a\u7279\u6b8a\u60c5\u51b5 \u8be5\u5728\u4f55\u5904 % MOD solution class Solution { public : using LL = long long ; int findPaths ( int m , int n , int max_move , int start_row , int start_column ) { if ( max_move == 0 ) return 0 ; vector < vector < LL >> dp_curr ( m , vector < LL > ( n )); vector < vector < LL >> dp_last ( m , vector < LL > ( n )); dp_last [ start_row ][ start_column ] = 1 ; long res = calPathSum ( dp_last ); for ( int mv = 1 ; mv < max_move ; ++ mv ) { for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { dp_curr [ i ][ j ] = 0 ; for ( int * dir : DIRECTIONS ) { int ni = i + dir [ 0 ], nj = j + dir [ 1 ]; if ( inArea ( ni , nj , dp_curr )) { dp_curr [ i ][ j ] += dp_last [ ni ][ nj ] % ( 1000000000 + 7 ); } } } } res += calPathSum ( dp_curr ); swap ( dp_curr , dp_last ); } return res % ( 1000000000 + 7 ); } private : long calPathSum ( vector < vector < LL >>& dp ) { long res = 0 , m = dp . size (), n = dp [ 0 ]. size (); for ( int j = 0 ; j < n ; ++ j ) { res += ( dp [ 0 ][ j ] + dp [ m - 1 ][ j ]) % ( 1000000000 + 7 ); } for ( int i = 0 ; i < m ; ++ i ) { res += ( dp [ i ][ 0 ] + dp [ i ][ n - 1 ]) % ( 1000000000 + 7 ); } return res ; } int inArea ( int x , int y , vector < vector < LL >>& dp ) { return x >= 0 && x < dp . size () && y >= 0 && y < dp [ 0 ]. size (); } int DIRECTIONS [ 4 ][ 2 ] = {{ 0 , 1 }, { 0 , -1 }, { 1 , 0 }, { -1 , 0 }}; }; \u65f6\u95f4 $O(m\\times n\\times \\mathit{max\\_move})$\uff0c\u7a7a\u95f4 $O(mn)$","title":"576. out of boundary paths"},{"location":"_problems/_leetcode/6/","text":"","title":"6"},{"location":"_problems/_leetcode/60/","text":"\u7ed9\u5b9a\u96c6\u5408 [1,2,...,n] \uff0c\u627e\u51fa\u5b83\u7684\u5b57\u5178\u5e8f\u7684\u7b2c k \u4e2a\u724c\u7c7b Example: \u8f93\u5165\uff1an = 3, k = 3 \u8f93\u51fa\uff1a\"213\" 123 132 213 231 312 321 Note: 1 <= n <= 9 1 <= k <= n! (Hard) \u6bcf\u4e2a\u6392\u5217\u6309\u7167\u9996\u6570\u5b57\u5206\u5757\u3001\u5b9a\u4f4d\uff0c\u4e00\u8f6e\u8fed\u4ee3\u5373\u53ef\uff0c\u9632\u6b62\u5199\u7684\u65f6\u5019\u6655: arr = [1, 2, 3] n!=3x2x1 \u6c42\u7b2c k \u5927\u7684\u6392\u5217 ITER1: segment_num = 3 segment_size = 2x1 permutations: <1> a b <2> a b <3> a b index: 1 2 3 4 5 6 pseu_index: 0 1 2 3 4 5 segment_ith = (k - 1) / segment_size + 1 next_k = (k - 1) % segment_size + 1 k = next_k ITER2: ... \u597d\u597d\u8d77\u53d8\u91cf\u540d + \u5199\u6ce8\u91ca solution class Solution { public : string getPermutation ( int n , int k ) { unordered_set < int > found ; string res ; int seg_size = calFatorial ( n ); for ( int i = 1 ; i <= n ; ++ i ) { int seg_num = n - i + 1 ; seg_size /= seg_num ; int seg_i = ( k - 1 ) / seg_size + 1 ; k = ( k - 1 ) % seg_size + 1 ; int r = findKth ( seg_i , n , found ); found . insert ( r ); res . append ( to_string ( r )); } return res ; } private : int calFatorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; ++ i ) res *= i ; return res ; } int findKth ( int k , int n , unordered_set < int >& found ) { int i = 1 , nk = 1 ; while ( i <= n ) { if ( found . count ( i ) == 0 ) { if ( k == nk ) return i ; nk ++ ; } i ++ ; } return 0 ; } }; \u65f6\u95f4 $O(n^2)$\uff0c\u627e\u6709\u5e8f\u5e8f\u5217\u7b2c $k$ \u5927\u7684\u6570\u65f6\u9700\u8981\u6807\u8bb0\u6570\u7ec4\uff0c\u7a7a\u95f4 $O(n)$","title":"60. permutation sequence"},{"location":"_problems/_leetcode/600/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6574\u6570 n \uff0c\u627e\u51fa\u5c0f\u4e8e\u7b49\u4e8e n \u7684\u975e\u8d1f\u6574\u6570\u4e2d\uff0c\u5176\u4e8c\u8fdb\u5236\u8868\u793a\u4e0d\u5305\u542b\u7684\u8fde\u7eed\u76841\u7684\u4e2a\u6570\u3002 Example: \u8f93\u5165: 5 \u8f93\u51fa: 5 \u89e3\u91ca: x <= 5\uff1a 0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 Note: 1 <= n <= 10^9 (Hard) naive \u65b9\u6cd5: \u9010\u4e2a\u6c42\uff0c\u590d\u6742\u5ea6 $O(n)$ naive int findIntegers ( int n ) { int res = 0 ; for ( int i = 0 ; i <= n ; ++ i ) { if (( i & ( i >> 1 )) == 0 ) res += 1 ; } return res ; } \u52a8\u6001\u89c4\u5212 1 \ud83e\uddd0 \u89c2\u5bdf\u53ef\u5f97\u601d\u8def 1001 0011 n=1000 0010 0111 0001 0100 0000 dp[i]: \u5728 [0, i] \u4e2d\u4e0d\u5305\u542b\u8fde\u7eed\u7684 1 \u7684\u6570\u7684\u4e2a\u6570 dp[i].a: \u6ee1\u8db3 dp[i] \u7684\u6761\u4ef6\uff0c\u4e14\u4ee5 0 \u7ed3\u5c3e\uff0c\u5219 dp[i].a = dp[i>>1].a + dp[i>>1].b dp[i].b: \u6ee1\u8db3 dp[i] \u7684\u6761\u4ef6\uff0c\u4e14\u4ee5 1 \u7ed3\u5c3e\uff0c\u5219 dp[i].b = dp[i>>1].b (-1) \u9700\u8981\u6ce8\u610f\uff0c\u4ee5 $\\sf\\underline{\\sf 100}0$ \u4e3a\u4f8b\uff0c dp[i>>1].b \u7684\u542b\u4e49\u662f [0, i>>1] \u4e2d\u6ee1\u8db3\u65e0\u8fde\u7eed 1 \u4e14\u5c3e 0 \u5c31\u53ef\u4ee5\u5728\u7ed3\u5c3e\u6dfb\u52a0 1\uff0c\u4f46\u5f53 n \u662f\u5076\u6570\u4e14 i>>1 \u672c\u8eab\u4e5f\u6ee1\u8db3\u6761\u4ef6\u7684\u65f6\u5019\uff0c\u7ed3\u679c\u591a\u7b97\u4e86 1 \u65f6\u95f4: $T(b)=T(b-1)+O(b)$\uff0c$T(b)=O(b^2)$\uff0c b \u662f n \u6240\u5360\u6bd4\u7279\u6570 solution class Solution { public : int findIntegers ( int n ) { auto pair = dp ( n ); return pair . first + pair . second ; } pair < int , int > dp ( int n ) { if ( n == 0 ) return make_pair ( 1 , 0 ); auto vals = dp ( n >> 1 ); int a = vals . first + vals . second ; int b = vals . first ; if (( n & 0b11 ) == 0 && ! hasContOnes ( n >> 1 )) { b -= 1 ; } return make_pair ( a , b ); } bool hasContOnes ( int n ) { bool last = false ; int mask = 1 , i = 0 ; while ( i < 31 ) { bool isOne = ( n & mask ) != 0 ; if ( last && isOne ) return true ; last = isOne ; mask = mask << 1 ; ++ i ; } return false ; } }; \u8fd8\u9700\u8981\u6ce8\u610f: \u4e00\u5f00\u59cb\u8003\u8651\u7684\u662f dp[i] \u8868\u793a\u5305\u542b\u8fde\u7eed\u7684 1 \u7684\u4e2a\u6570\uff0c\u4f46\u5728\u9012\u63a8\u65f6\u8003\u8651\u7684\u6761\u4ef6\u8fc7\u591a\uff0c\u56e0\u6b64\u7406\u5e94\u53cd\u8fc7\u6765\u5c1d\u8bd5\u4e00\u4e0b \u4e0d\u5199\u6ce8\u91ca\u5bb9\u6613\u6655 \u76f4\u63a5\u4ee4 dp[i] \u8868\u793a\u4e0d\u5305\u542b\u8fde\u7eed 1 \u7684\u4e2a\u6570\uff0c\u4e0d\u7528 ab \uff0c\u8003\u8651\u5bf9 dp[i>>1] \u4e2d\u4ee5 0 \u7ed3\u5c3e\u7684\u6570\u7684\u4e2a\u6570\u7b49\u4e8e dp[i>>2] \uff0c\u56e0\u6b64 dp[i] = dp[i>>1] + dp[i>>2] \uff0c$T(b)=T(b-1)+T(b-2)+C$ \u662f\u6590\u6ce2\u90a3\u5951\u9012\u63a8\u5f0f\uff0c\u590d\u6742\u5ea6\u4e3a\u6307\u6570\u7ea7 $O(v^b)$ \u52a8\u6001\u89c4\u5212 2 \ud83e\uddd0 \u9996\u5148\uff0c\u4ee4 dp[i] \u8868\u793a\u5728 i \u4e2a bit \u80fd\u8868\u793a\u7684\u6240\u6709\u6570\u4e2d\uff0c\u4e0d\u5305\u542b\u8fde\u7eed 1 \u7684\u4e2a\u6570 dp[i] = dp[i - 1] + dp[i - 2] \u4ee5 0b1001101 \u4e3a\u4f8b\uff0c\u53ef\u6839\u636e dp \u8fdb\u884c\u5982\u4e0b\u8ba1\u7b97 1. Count[0000000, 1001101) = Count[0000000, 0111111] + Count[1000000, 1001101) = dp[6] + Count([1000000, 1001101)) 2. Count[1000000, 1001101) = Count[0000, 1101) = Count[0000, 0111] + Count[1000, 1101) = dp[3] + Count[1000, 1101) 3. Count[1000, 1101) = Count[1000, 1011] + Count[1100, 1101) = Count[000, 011] + 0 = dp[2] + 0 \u8fd9\u8bf4\u660e\u53ea\u8981\u6709 1 \u5c31\u52a0\u4e0a dp[i-1] \uff0c\u4f46\u9047\u5230\u8fde\u7eed\u7684 1 \u9700\u8981 break \u5e76\u51cf\u53bb\u672c\u8eab\u4e0d\u7b26\u5408\u6761\u4ef6\u7684 1\u3002\u7136\u540e\u8003\u8651\u8fb9\u754c\u60c5\u51b5: Count[0000, 1001) = dp[3] + Count[0, 1) Count[0000, 1011) = dp[3] + dp[1] + Count[0, 1) \u53ef\u4ee5\u8bbe\u54e8\u5175\u503c dp[0] = Count[0, 1) = 1 solution class Solution { public : int findIntegers ( int n ) { array < int , 32 > bit2Count ; bit2Count [ 0 ] = 1 ; bit2Count [ 1 ] = 2 ; for ( int i = 2 ; i < bit2Count . size (); ++ i ) { bit2Count [ i ] = bit2Count [ i - 1 ] + bit2Count [ i - 2 ]; } int mask = 1 << 30 , i = 31 ; int prevBit = 0 , res = 1 ; while ( mask != 0 ) { if (( mask & n ) != 0 ) { res += bit2Count [ i - 1 ]; if ( prevBit == 1 ) { res -= 1 ; break ; } prevBit = 1 ; } else { prevBit = 0 ; } -- i ; mask >>= 1 ; } return res ; } }; \u65f6\u95f4 $O(32)$","title":"600. non-negative integers without consective 1s"},{"location":"_problems/_leetcode/600/#1","text":"\u89c2\u5bdf\u53ef\u5f97\u601d\u8def 1001 0011 n=1000 0010 0111 0001 0100 0000 dp[i]: \u5728 [0, i] \u4e2d\u4e0d\u5305\u542b\u8fde\u7eed\u7684 1 \u7684\u6570\u7684\u4e2a\u6570 dp[i].a: \u6ee1\u8db3 dp[i] \u7684\u6761\u4ef6\uff0c\u4e14\u4ee5 0 \u7ed3\u5c3e\uff0c\u5219 dp[i].a = dp[i>>1].a + dp[i>>1].b dp[i].b: \u6ee1\u8db3 dp[i] \u7684\u6761\u4ef6\uff0c\u4e14\u4ee5 1 \u7ed3\u5c3e\uff0c\u5219 dp[i].b = dp[i>>1].b (-1) \u9700\u8981\u6ce8\u610f\uff0c\u4ee5 $\\sf\\underline{\\sf 100}0$ \u4e3a\u4f8b\uff0c dp[i>>1].b \u7684\u542b\u4e49\u662f [0, i>>1] \u4e2d\u6ee1\u8db3\u65e0\u8fde\u7eed 1 \u4e14\u5c3e 0 \u5c31\u53ef\u4ee5\u5728\u7ed3\u5c3e\u6dfb\u52a0 1\uff0c\u4f46\u5f53 n \u662f\u5076\u6570\u4e14 i>>1 \u672c\u8eab\u4e5f\u6ee1\u8db3\u6761\u4ef6\u7684\u65f6\u5019\uff0c\u7ed3\u679c\u591a\u7b97\u4e86 1 \u65f6\u95f4: $T(b)=T(b-1)+O(b)$\uff0c$T(b)=O(b^2)$\uff0c b \u662f n \u6240\u5360\u6bd4\u7279\u6570 solution class Solution { public : int findIntegers ( int n ) { auto pair = dp ( n ); return pair . first + pair . second ; } pair < int , int > dp ( int n ) { if ( n == 0 ) return make_pair ( 1 , 0 ); auto vals = dp ( n >> 1 ); int a = vals . first + vals . second ; int b = vals . first ; if (( n & 0b11 ) == 0 && ! hasContOnes ( n >> 1 )) { b -= 1 ; } return make_pair ( a , b ); } bool hasContOnes ( int n ) { bool last = false ; int mask = 1 , i = 0 ; while ( i < 31 ) { bool isOne = ( n & mask ) != 0 ; if ( last && isOne ) return true ; last = isOne ; mask = mask << 1 ; ++ i ; } return false ; } }; \u8fd8\u9700\u8981\u6ce8\u610f: \u4e00\u5f00\u59cb\u8003\u8651\u7684\u662f dp[i] \u8868\u793a\u5305\u542b\u8fde\u7eed\u7684 1 \u7684\u4e2a\u6570\uff0c\u4f46\u5728\u9012\u63a8\u65f6\u8003\u8651\u7684\u6761\u4ef6\u8fc7\u591a\uff0c\u56e0\u6b64\u7406\u5e94\u53cd\u8fc7\u6765\u5c1d\u8bd5\u4e00\u4e0b \u4e0d\u5199\u6ce8\u91ca\u5bb9\u6613\u6655 \u76f4\u63a5\u4ee4 dp[i] \u8868\u793a\u4e0d\u5305\u542b\u8fde\u7eed 1 \u7684\u4e2a\u6570\uff0c\u4e0d\u7528 ab \uff0c\u8003\u8651\u5bf9 dp[i>>1] \u4e2d\u4ee5 0 \u7ed3\u5c3e\u7684\u6570\u7684\u4e2a\u6570\u7b49\u4e8e dp[i>>2] \uff0c\u56e0\u6b64 dp[i] = dp[i>>1] + dp[i>>2] \uff0c$T(b)=T(b-1)+T(b-2)+C$ \u662f\u6590\u6ce2\u90a3\u5951\u9012\u63a8\u5f0f\uff0c\u590d\u6742\u5ea6\u4e3a\u6307\u6570\u7ea7 $O(v^b)$","title":"\u52a8\u6001\u89c4\u5212 1"},{"location":"_problems/_leetcode/600/#2","text":"\u9996\u5148\uff0c\u4ee4 dp[i] \u8868\u793a\u5728 i \u4e2a bit \u80fd\u8868\u793a\u7684\u6240\u6709\u6570\u4e2d\uff0c\u4e0d\u5305\u542b\u8fde\u7eed 1 \u7684\u4e2a\u6570 dp[i] = dp[i - 1] + dp[i - 2] \u4ee5 0b1001101 \u4e3a\u4f8b\uff0c\u53ef\u6839\u636e dp \u8fdb\u884c\u5982\u4e0b\u8ba1\u7b97 1. Count[0000000, 1001101) = Count[0000000, 0111111] + Count[1000000, 1001101) = dp[6] + Count([1000000, 1001101)) 2. Count[1000000, 1001101) = Count[0000, 1101) = Count[0000, 0111] + Count[1000, 1101) = dp[3] + Count[1000, 1101) 3. Count[1000, 1101) = Count[1000, 1011] + Count[1100, 1101) = Count[000, 011] + 0 = dp[2] + 0 \u8fd9\u8bf4\u660e\u53ea\u8981\u6709 1 \u5c31\u52a0\u4e0a dp[i-1] \uff0c\u4f46\u9047\u5230\u8fde\u7eed\u7684 1 \u9700\u8981 break \u5e76\u51cf\u53bb\u672c\u8eab\u4e0d\u7b26\u5408\u6761\u4ef6\u7684 1\u3002\u7136\u540e\u8003\u8651\u8fb9\u754c\u60c5\u51b5: Count[0000, 1001) = dp[3] + Count[0, 1) Count[0000, 1011) = dp[3] + dp[1] + Count[0, 1) \u53ef\u4ee5\u8bbe\u54e8\u5175\u503c dp[0] = Count[0, 1) = 1 solution class Solution { public : int findIntegers ( int n ) { array < int , 32 > bit2Count ; bit2Count [ 0 ] = 1 ; bit2Count [ 1 ] = 2 ; for ( int i = 2 ; i < bit2Count . size (); ++ i ) { bit2Count [ i ] = bit2Count [ i - 1 ] + bit2Count [ i - 2 ]; } int mask = 1 << 30 , i = 31 ; int prevBit = 0 , res = 1 ; while ( mask != 0 ) { if (( mask & n ) != 0 ) { res += bit2Count [ i - 1 ]; if ( prevBit == 1 ) { res -= 1 ; break ; } prevBit = 1 ; } else { prevBit = 0 ; } -- i ; mask >>= 1 ; } return res ; } }; \u65f6\u95f4 $O(32)$","title":"\u52a8\u6001\u89c4\u5212 2"},{"location":"_problems/_leetcode/621/","text":"tasks \u4efb\u52a1\u5217\u8868\uff0c\u4efb\u52a1\u53ef\u4ee5\u4efb\u610f\u987a\u5e8f\u6267\u884c\uff0c\u6bcf\u4e2a\u4efb\u52a1\u5360\u4e00\u4e2a\u5355\u4f4d\u65f6\u95f4\uff1b\u5bf9\u6bcf\u4e2a\u5355\u4f4d\u65f6\u95f4\uff0cCPU \u53ef\u4ee5\u9009\u62e9\u6267\u884c\u4efb\u52a1\u6216\u5904\u4e8e\u5f85\u547d\u72b6\u6001\uff0c\u4f46\u4e24\u4e2a\u76f8\u540c \u79cd\u7c7b\u7684\u4efb\u52a1\u5fc5\u987b\u6709\u957f\u4e3a n \u7684\u51b7\u5374\u65f6\u95f4\u3002\u8ba1\u7b97\u5b8c\u6210\u6240\u6709\u4efb\u52a1\u6240\u9700\u7684\u6700\u77ed\u65f6\u95f4\u3002 Example: \u8f93\u5165\uff1atasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2 \u8f93\u51fa\uff1a8 \u89e3\u91ca\uff1aA -> B -> (\u5f85\u547d) -> A -> B -> (\u5f85\u547d) -> A -> B Note: 1 <= task.length <= 10^4, 0 <= n <= 100 (Medium) \u9700\u8981\u6ce8\u610f: \u5fc5\u987b\u6709\u957f\u4e3a n \u7684\u51b7\u5374 $\\Longrightarrow$ \u95f4\u9694 \u81f3\u5c11\u4e3a n example: tasks = ['A'x6, 'B'x6, \u2019C'x2, 'D'x5, 'F'x5], n=3 ____ ____ ____ |AB | |ABD | |ABDF|F |AB | |ABD | |ABDF|F 1. set A,B,C: |AB | 2. set D: |ABD | 3. set F: |ABDF| |ABC | |ABCD| |ABCD| |ABC | |ABCD| |ABCD| |AB AB AB \u5173\u952e\u5728\u4e8e\u7406\u89e3\u6ca1\u51fa\u754c\u65f6 (step2) \u548c\u51fa\u754c\u65f6 (step3) \u5c3d\u53ef\u80fd\u653e\u6ee1\u7684\u65b9\u5f0f\uff0c\u56e0\u6b64\u8ba1\u7b97\u8fc7\u7a0b\u4e3a \u627e\u51fa\u6700\u957f\u7684\u4efb\u52a1\uff0c\u5176\u957f\u5ea6\u4e3a M \uff0c\u6700\u957f\u7684\u4efb\u52a1\u5171\u6709 C \u4e2a \u8ba1\u7b97 res = (M - 1) * (n + 1) + C return max(res, tasks.size()) solution class Solution { public : int leastInterval ( vector < char >& tasks , int n ) { array < int , 26 > taskCount {}; for ( auto & task : tasks ) { ++ taskCount [ task - 'A' ]; } const int M = * max_element ( taskCount . begin (), taskCount . end ()); size_t res = ( M - 1 ) * ( n + 1 ) + count ( taskCount . begin (), taskCount . end (), M ); return max ( tasks . size (), res ); } };","title":"621. task scheduler"},{"location":"_problems/_leetcode/633/","text":"\u7ed9\u5b9a\u975e\u8d1f\u6574\u6570 $c$\uff0c\u5224\u65ad\u662f\u5426\u5b58\u5728\u4e24\u4e2a\u6574\u6570 $a$ \u548c $b$\uff0c\u4f7f\u5f97 $a^2 + b^2 = c$ Example: \u8f93\u5165\uff1ac = 5 \u8f93\u51fa\uff1atrue \u89e3\u91ca\uff1a1 * 1 + 2 * 2 = 5 Note: 0 <= c <= 2^31-1 (Medium) \u53ef\u4ee5\u679a\u4e3e $a$ \u548c $b$ \u65f6\u95f4 $O(\\sqrt n \\cdot \\mathrm{sqrt})$ \u53ef\u4ee5\u53cc\u6307\u9488 \u65f6\u95f4 $O(\\sqrt n)$ solution sqrt class Solution { public : bool judgeSquareSum ( int c ) { for ( long x = 0 ; x * x <= c ; ++ x ) { long r = c - x * x ; long y = ( long ) ( sqrt ( r ) + 0.5 ); if ( y * y == r ) return true ; } return false ; } }; \u53cc\u6307\u9488 class Solution { public : bool judgeSquareSum ( int c ) { long i = 0 , j = ( long ) ( sqrt ( c ) + 0.5 ); while ( i <= j ) { long sum = i * i + j * j ; if ( sum == c ) return true ; else if ( sum < c ) ++ i ; else -- j ; } return false ; } };","title":"633. sum of square numbers"},{"location":"_problems/_leetcode/664/","text":"\u6709\u53f0\u5947\u602a\u7684\u6253\u5370\u673a\u6709\u4ee5\u4e0b\u4e24\u4e2a\u7279\u6b8a\u8981\u6c42: \u6bcf\u6b21\u53ea\u80fd\u6253\u5370\u7531\u540c\u4e00\u4e2a\u5b57\u7b26\u7ec4\u6210\u7684\u5e8f\u5217 \u6bcf\u6b21\u53ef\u4ee5\u5728\u4efb\u610f\u4f4d\u7f6e\u5f00\u59cb\u6253\u5370\uff0c\u4e14\u8986\u76d6\u539f\u6709\u5b57\u7b26 \u7ed9\u5b9a\u5b57\u7b26\u4e32 s \uff0c\u6c42\u6253\u5370\u5b83\u9700\u8981\u7684\u6700\u5c11\u6b21\u6570 Example: \u8f93\u5165\uff1as = \"aba\" \u8f93\u51fa\uff1a2 \u89e3\u91ca\uff1a\u9996\u5148\u6253\u5370 \"aaa\" \u7136\u540e\u5728\u7b2c\u4e8c\u4e2a\u4f4d\u7f6e\u6253\u5370 \"b\" \u8986\u76d6\u6389\u539f\u6765\u7684\u5b57\u7b26 'a'\u3002 Note: 1 <= s.length <= 100 (Hard) Ex1: s = \"baddcbcaab\" (len=10), res = 5 b ccc dd aaaaaaaa bbbbbbbbbb \u9996\u5148\u53ef\u4ee5\u786e\u5b9a\uff0c\u4ee5 dp[i][j] \u754c\u5b9a: \u82e5 s[i] == s[j] \uff0c\u5fc5\u7136\u8981\u8fde\u7eed\u6253\u5370 s[i] \u82e5 s[i] != s[j] \uff0c\u4e0d\u5b58\u5728\u4ece i \u5230 j \u7684\u8fde\u7eed\u6253\u5370\uff0c\u7ed3\u679c\u4e00\u5b9a\u53ef\u4ee5\u8868\u793a\u4e3a\u4e24\u4e2a\u5b57\u4e32\u7684\u6253\u5370\u6570\u4e4b\u548c \u8003\u8651 s[i] == s[j] \uff0c\u4ee5 s' = \"aaa[substr1]a[substr2]aa\" \u4e3a\u4f8b\uff0c\u8981\u6ce8\u610f: dp(s') = dp(substr1) + dp(substr2) + 1 \u4e0d\u4e00\u5b9a\u6210\u7acb \u56e0\u6b64\u65e0\u6cd5\u4ee5\u8fd9\u79cd\u65b9\u5f0f\u628a\u4e00\u4e2a\u8fde\u7eed\u6253\u5370\u7eb3\u5165\u89e3\u5e8f\u5217\uff0c\u56e0\u4e3a\u6ca1\u529e\u6cd5\u5411\u4e0b\u5212\u5206\u5b50\u95ee\u9898\u3002\u53ef\u4ee5\u5c1d\u8bd5\u4e00\u4e0b\u8ba9\u5b50\u7a7a\u95f4\u66f4\u201c\u7b3c\u7edf\u201d\u4e00\u70b9\uff0c\u76f4\u63a5\u8003\u8651 dp(i, j-1) \uff0c\u6709: dp[i][j] = dp[i][j-1], if s[i] = s[j] \u8fd9\u662f\u56e0\u4e3a\u5728 dp[i][j-1] \u4e2d\uff0c\u4e00\u5b9a\u53ef\u4ee5\u7b2c\u4e00\u6b65\u5c31\u6253\u5370 s[i] \uff0c\u5c31\u4e5f\u80fd\u987a\u5e26\u6253\u5370 s[j] \u3002 $$ dp[i][j]= \\begin{cases} dp[i][j-1] &\\text{if }s[i]=s[j] \\\\ \\min\\lbrace dp[i][k]+dp[k+1][j]\\rbrace &\\text{else} \\end{cases} $$ \u672c\u9898\u542f\u793a\u4e00\u6839\u7b4b\u6784\u9020\u89e3\u4e5f\u5e76\u4e0d\u53ef\u53d6\u3002 solution class Solution { public : int strangePrinter ( string s ) { vector < vector < int >> dp ( s . size (), vector < int > ( s . size ())); for ( int i = s . size () - 1 ; i >= 0 ; -- i ) { dp [ i ][ i ] = 1 ; for ( int j = i + 1 ; j < s . size (); ++ j ) { if ( s [ i ] == s [ j ]) { dp [ i ][ j ] = dp [ i ][ j - 1 ]; } else { int v = INT32_MAX ; for ( int k = i ; k < j ; ++ k ) { if ( k != j - 1 && s [ k ] == s [ k + 1 ]) continue ; v = std :: min ( v , dp [ i ][ k ] + dp [ k + 1 ][ j ]); } dp [ i ][ j ] = v ; } } } return dp [ 0 ]. back (); } }; ??? Example: i j [a,a,a,b,b,b,c,d,d,e,f] ^ ^ ^ ^ ^ Note: j >= 1 Code: int k = i , lastI = i ; while ( lastI <= j ) { while ( k <= j && s [ k ] == s [ lastI ]) ++ k ; cout << lastI << k - 1 << end ; lastI = k ; }","title":"664. strange printer"},{"location":"_problems/_leetcode/670/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u975e\u8d1f\u6574\u6570\uff0c\u81f3\u591a\u4ea4\u6362\u4e00\u6b21\u5176\u4e2d\u7684\u4e24\u4e2a\u6570\u5b57\uff0c\u8fd4\u56de\u80fd\u5f97\u5230\u7684\u6700\u5927\u503c\u3002 Example: \u8f93\u5165: 2736 \u8f93\u51fa: 7236 \u8f93\u5165: 9973 \u8f93\u51fa: 9973 Note: 0 <= num <= 10^8 (Medium) \u76f4\u767d\u7684\u8d2a\u5fc3\uff0c\u4f46\u9700\u8981\u4ed4\u7ec6\u8003\u8651\u7279\u4f8b: \u9009\u5b9a\u4e00\u4e2a\u4f4d\u7f6e i \uff0c\u5224\u65ad [i, end] \u5185\u7684\u6700\u5927\u503c\u7684\u6700\u540e\u4e00\u4e2a\u7d22\u5f15 j \u5728\u54ea i == j \u4e0d\u9700\u8981\u4ea4\u6362 i != j \uff0c\u4f46 nums[i] = nums[j] \uff0c\u4e5f\u4e0d\u9700\u8981\u4ea4\u6362 i != j \uff0c\u4e14 nums[i] != nums[j] \uff0c\u4ea4\u6362\u5b8c\u6210 \u76f4\u63a5\u7684\u65b9\u6cd5\u9700\u8981\u65f6\u95f4 $O(n^2)$ ($n$ \u4e3a\u6570\u5b57\u7684\u4f4d\u6570)\uff0c\u53ef\u4ee5\u7528\u7a7a\u95f4\u6362\u5230 $O(n)$ solution class Solution { public : int maximumSwap ( int num ) { string numStr = to_string ( num ); array < int , 10 > dig2idx {}; for ( int i = 0 ; i < numStr . size (); ++ i ) { dig2idx [ numStr [ i ] - '0' ] = i + 1 ; } int i = 1 ; for ( char c = '9' ; c >= '0' ; ) { if ( dig2idx [ c - '0' ] == 0 ) { -- c ; } else if ( dig2idx [ c - '0' ] == i ) { ++ i ; -- c ; continue ; } else if ( numStr [ dig2idx [ c - '0' ] - 1 ] == numStr [ i - 1 ]) { ++ i ; continue ; } else { swap ( numStr [ i - 1 ], numStr [ dig2idx [ c - '0' ] - 1 ]); break ; } } return stoi ( numStr ); } };","title":"670. maximum swap"},{"location":"_problems/_leetcode/671/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u975e\u7a7a\u7279\u6b8a\u7684\u4e8c\u53c9\u6811\uff0c\u6bcf\u4e2a\u8282\u70b9\u90fd\u662f\u6b63\u6570\uff0c\u5e76\u4e14\u6bcf\u4e2a\u8282\u70b9\u7684\u5b50\u8282\u70b9\u6570\u91cf\u53ea\u80fd\u4e3a 2 \u6216 0\u3002\u5982\u679c\u4e00\u4e2a\u8282\u70b9\u6709\u4e24\u4e2a\u5b50\u8282\u70b9\u7684\u8bdd\uff0c\u90a3\u4e48\u8be5\u8282\u70b9\u7684\u503c\u7b49\u4e8e\u4e24\u4e2a\u5b50\u8282\u70b9\u4e2d\u8f83\u5c0f\u7684\u4e00\u4e2a\u3002 \u66f4\u6b63\u5f0f\u5730\u8bf4\uff0c root.val = min(root.left.val, root.right.val) \u603b\u6210\u7acb\u3002 \u7ed9\u51fa\u8fd9\u6837\u7684\u4e00\u4e2a\u4e8c\u53c9\u6811\uff0c\u4f60\u9700\u8981\u8f93\u51fa\u6240\u6709\u8282\u70b9\u4e2d\u7684\u7b2c\u4e8c\u5c0f\u7684\u503c\u3002\u5982\u679c\u7b2c\u4e8c\u5c0f\u7684\u503c\u4e0d\u5b58\u5728\u7684\u8bdd\uff0c\u8f93\u51fa -1 \u3002 Example1: \u8f93\u5165\uff1a\u8f93\u5165\uff1aroot = [2,2,5,null,null,5,7] // level order \u8f93\u51fa\uff1a5 \u89e3\u91ca\uff1a\u6700\u5c0f\u7684\u503c\u662f 2 \uff0c\u7b2c\u4e8c\u5c0f\u7684\u503c\u662f 5 \u3002 Example2: \u8f93\u5165\uff1aroot = [2,2,2] \u8f93\u51fa\uff1a-1 \u89e3\u91ca\uff1a\u6700\u5c0f\u7684\u503c\u662f 2, \u4f46\u662f\u4e0d\u5b58\u5728\u7b2c\u4e8c\u5c0f\u7684\u503c\u3002 Note: \u6811\u4e2d\u8282\u70b9\u6570\u76ee\u5728\u8303\u56f4 [1, 25] \u5185 \u5bf9\u4e8e\u6811\u4e2d\u6bcf\u4e2a\u8282\u70b9 root.val == min(root.left.val, root.right.val) 1 <= Node.val <= 2^31 - 1 (Easy) \u7279\u6b8a\u6761\u4ef6\u5728\u4e8e root.val == min(root.left.val, root.right.val) : \u76f8\u5f53\u4e8e\u7236\u7ed3\u70b9\u5411\u4e0b\u589e\u52a0\u4e00\u4e2a\u65b0\u503c\u8282\u70b9 \u6240\u6709\u53f6\u8282\u70b9\u6784\u6210\u4e86\u6811\u7684\u8282\u70b9\u96c6\u5408 (\u4e0d\u8003\u8651\u6811\u6839\u5411\u4e0b\u589e\u52a0\u7684\u60c5\u51b5) \u9898\u76ee\u6c42\u7b2c\u4e8c\u5c0f\u7684\u503c\uff0c\u5982\u679c\u5b58\u5728\u5c31\u4e00\u5b9a\u76f8\u5bf9\u4e8e\u6839\u7ed3\u70b9\u53ea\u52a0\u503c\u4e86\u4e00\u6b21\uff0c\u56e0\u6b64\u53ea\u6cbf\u7740\u6839\u7ed3\u70b9\u672a\u52a0\u503c\u7684\u8def\u904d\u5386\u5373\u53ef Solution class Solution { public int findSecondMinimumValue ( TreeNode root ) { Queue < TreeNode > queue = new LinkedList < TreeNode > (); int minValue = Integer . MAX_VALUE ; boolean flag = false ; queue . offer ( root ); while ( ! queue . isEmpty ()) { TreeNode cur = queue . poll (); if ( cur . left != null ) { if ( cur . left . val == root . val ) { queue . offer ( cur . left ); } else { minValue = Math . min ( minValue , cur . left . val ); flag = true ; } } if ( cur . right != null ) { if ( cur . right . val == root . val ) { queue . offer ( cur . right ); } else { minValue = Math . min ( minValue , cur . right . val ); flag = true ; } } } if ( ! flag ) return - 1 ; return minValue ; } }","title":"671. second minimum node in a binary tree"},{"location":"_problems/_leetcode/71/","text":"\u7ed9\u5b9a Unix \u98ce\u683c\u7684\u7edd\u5bf9\u8def\u5f84: \u4ee5 / \u5f00\u5934\uff0c\u8868\u793a\u4ece\u6839\u76ee\u5f55\u5f00\u59cb . \u8868\u793a\u5f53\u524d\u76ee\u5f55\uff0c .. \u8868\u793a\u4e0a\u4e00\u7ea7\u76ee\u5f55\uff0c\u66f4\u591a\u7684 . \u8868\u793a\u76ee\u5f55\u540d \u4efb\u610f\u8fde\u7eed\u7684 / \u89c6\u4e3a\u5355\u4e2a / \u8fd4\u56de\u7b49\u4ef7\u7684\u89c4\u8303\u8def\u5f84: \u59cb\u7ec8\u4ee5 / \u5f00\u5934\uff0c\u4e14\u4e24\u4e2a\u76ee\u5f55\u540d\u4e4b\u95f4\u5fc5\u6709\u4e00\u4e2a / \u6700\u540e\u4e00\u4e2a\u76ee\u5f55\u540d\u82e5\u5b58\u5728\uff0c\u4e0d\u4ee5 / \u7ed3\u5c3e \u4e0d\u542b . \u6216 .. Example: \u8f93\u5165\uff1apath = \"//a//./b/../../c///\" \u8f93\u51fa\uff1a\"/c\" Note: path \u662f\u4e00\u4e2a\u6709\u6548\u7684 Unix \u7edd\u5bf9\u8def\u5f84\uff0c\u7531 . , / \u6216 _ \u6784\u6210 (Medium) \u6a21\u62df\uff0c\u7701\u7a7a\u95f4\u5c31\u5728\u7ed3\u679c\u4e0a pop \uff0c\u7701\u65f6\u95f4\u5c31\u518d\u6765\u4e00\u4e2a stack\uff0c\u6ce8\u610f\u8003\u8651 special case solution class Solution { public : string simplifyPath ( string path ) { vector < string > dirs ; for ( int i = 1 ; i < path . size (); ) { for (; i < path . size (); ++ i ) { if ( path [ i ] != '/' ) { break ; } } int si = i ; if ( i == path . size ()) { break ; } for (; i < path . size (); ++ i ) { if ( path [ i ] == '/' ) { break ; } } string dir = path . substr ( si , i - si ); ++ i ; if ( dir == \".\" ) { continue ; } else if ( dir == \"..\" ) { if ( dirs . size () != 0 ) { dirs . pop_back (); } } else { dirs . push_back ( dir ); } } string res ; if ( dirs . size () == 0 ) { res += \"/\" ; } else { for ( string dir : dirs ) { res += \"/\" + dir ; } } return res ; } };","title":"71. simplify path"},{"location":"_problems/_leetcode/714_best_time_to_buy_and_sell_stock_with_transaction_fee/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 prices \uff0c\u5b83\u7684\u7b2c i \u4e2a\u5143\u7d20 prices[i] \u8868\u793a\u4e00\u652f\u7ed9\u5b9a\u80a1\u7968\u7b2c i \u5929\u7684\u4ef7\u683c\u3002\u975e\u8d1f\u6574\u6570 fee \u4ee3\u8868\u4e86\u4ea4\u6613\u80a1\u7968\u7684\u624b\u7eed\u8d39\u7528\u3002 \u4f60\u53ef\u4ee5\u65e0\u9650\u6b21\u5730\u5b8c\u6210\u4ea4\u6613\uff0c\u4f46\u662f\u4f60\u6bcf\u7b14\u4ea4\u6613\u90fd\u9700\u8981\u4ed8\u624b\u7eed\u8d39\u3002\u5982\u679c\u4f60\u5df2\u7ecf\u8d2d\u4e70\u4e86\u4e00\u4e2a\u80a1\u7968\uff0c\u5728\u5356\u51fa\u5b83\u4e4b\u524d\u4f60\u5c31\u4e0d\u80fd\u518d\u7ee7\u7eed\u8d2d\u4e70\u80a1\u7968\u4e86\u3002 \u8fd4\u56de\u83b7\u5f97\u5229\u6da6\u7684\u6700\u5927\u503c\u3002 Example1: \u8f93\u5165: prices = [1, 3, 2, 8, 4, 9], fee = 2 \u8f93\u51fa: 8 \u89e3\u91ca: \u80fd\u591f\u8fbe\u5230\u7684\u6700\u5927\u5229\u6da6: \u5728\u6b64\u5904\u4e70\u5165 prices[0] = 1 \u5728\u6b64\u5904\u5356\u51fa prices[3] = 8 \u5728\u6b64\u5904\u4e70\u5165 prices[4] = 4 \u5728\u6b64\u5904\u5356\u51fa prices[5] = 9 \u603b\u5229\u6da6: ((8 - 1) - 2) + ((9 - 4) - 2) = 8. Note: 0 < prices.length <= 50000 0 < prices[i] < 50000 0 <= fee < 50000 \u548c 122. best time to sell stock ii \u57fa\u672c\u4e00\u81f4\uff0c\u53ea\u662f\u4e0d\u80fd\u8d2a\u5fc3 solution public int maxProfit ( int [] prices , int fee ) { int N = prices . length ; int dp0 = 0 , dp1 = - prices [ 0 ] ; for ( int i = 1 ; i < N ; ++ i ) { dp0 = Math . max ( dp0 , dp1 + prices [ i ] - fee ); dp1 = Math . max ( dp1 , dp0 - prices [ i ] ); } return dp0 ; }","title":"714. best time to sell stock with transaction fee"},{"location":"_problems/_leetcode/72_edit_distance/","text":"\u7ed9\u4f60\u4e24\u4e2a\u5355\u8bcd word1 \u548c word2 \uff0c\u8bf7\u4f60\u8ba1\u7b97\u51fa\u5c06 word1 \u8f6c\u6362\u6210 word2 \u6240\u4f7f\u7528\u7684\u6700\u5c11\u64cd\u4f5c\u6570 \u4f60\u53ef\u4ee5\u5bf9\u4e00\u4e2a\u5355\u8bcd\u8fdb\u884c\u5982\u4e0b\u4e09\u79cd\u64cd\u4f5c\uff1a \u63d2\u5165\u4e00\u4e2a\u5b57\u7b26 \u5220\u9664\u4e00\u4e2a\u5b57\u7b26 \u66ff\u6362\u4e00\u4e2a\u5b57\u7b26 Example1: \u8f93\u5165\uff1aword1 = \"horse\", word2 = \"ros\" \u8f93\u51fa\uff1a3 \u89e3\u91ca\uff1a horse -> rorse (\u5c06 'h' \u66ff\u6362\u4e3a 'r') rorse -> rose (\u5220\u9664 'r') rose -> ros (\u5220\u9664 'e') Example2: \u8f93\u5165\uff1aword1 = \"intention\", word2 = \"execution\" \u8f93\u51fa\uff1a5 \u89e3\u91ca\uff1a intention -> inention (\u5220\u9664 't') inention -> enention (\u5c06 'i' \u66ff\u6362\u4e3a 'e') enention -> exention (\u5c06 'n' \u66ff\u6362\u4e3a 'x') exention -> exection (\u5c06 'n' \u66ff\u6362\u4e3a 'c') exection -> execution (\u63d2\u5165 'u') Note: 0 <= word1.length, word2.length <= 50 word1 and word2 consist of lowercase English letters. \u4ee5 \"horse\" \u548c \"rosy\" \u4e3a\u4f8b\uff0c\u7f16\u8f91\u8ddd\u79bb\u66f4\u51c6\u786e\u7684\u8bf4\u662f\u8fd9\u6837\u7684\u8fc7\u7a0b: $$ \\enspace \\begin{array}{lll} \\text{Operation} & \\mathrm{word1} & \\mathrm{word2} \\\\ \\hline \\textit{initial strings} & \\underline horse & \\text{\\textunderscore} \\\\ \\text{replace by } r & h\\underline orse & r\\text{\\textunderscore} \\\\ \\text{copy} & ho\\underline rse & ro\\text{\\textunderscore} \\\\ \\text{delete} & hor\\underline se & ro\\text{\\textunderscore} \\\\ \\text{copy} & hors\\underline e & ros\\text{\\textunderscore} \\\\ \\text{delete} & horse\\underline\\ & ros\\text{\\textunderscore} \\\\ \\text{insert } y & horse\\underline\\ & rosy\\text{\\textunderscore} \\end{array} $$ \u5404\u79cd\u64cd\u4f5c\u7684\u89c4\u5f8b\u53ef\u603b\u7ed3\u4e3a: $\\text{Operation}$ $\\text{effect}$ $\\text{cost}$ $\\text{replace}$ i+=1, j+=1 1 $\\text{insert}$ j+=1 1 $\\text{delete}$ i+=1 1 $\\text{copy}$ i+=1, j+=1 0 \u672c\u9898\u7684\u72b6\u6001\u65b9\u7a0b: $$ dp[i][j] = \\min\\lbrace \\ dp[i][j-1]+1,\\enspace dp[i-1][j]+1,\\enspace dp[i-1][j-1] + (\\mathrm{word1}[i] \\ne \\mathrm{word2}[j]) \\ \\rbrace $$ solution public int minDistance ( String word1 , String word2 ) { int M = word1 . length (), N = word2 . length (); int [][] dp = new int [ M + 1 ][ N + 1 ] ; for ( int j = 0 ; j <= N ; ++ j ) dp [ 0 ][ j ] = j ; for ( int i = 1 ; i <= M ; ++ i ) { dp [ i ][ 0 ] = i ; for ( int j = 1 ; j <= N ; ++ j ) { dp [ i ][ j ] = Math . min ( dp [ i ][ j - 1 ] , dp [ i - 1 ][ j ] ) + 1 ; dp [ i ][ j ] = Math . min ( dp [ i ][ j ] , dp [ i - 1 ][ j - 1 ] + (( word1 . charAt ( i - 1 ) == word2 . charAt ( j - 1 )) ? 0 : 1 )); } } return dp [ M ][ N ] ; }","title":"72. edit distance"},{"location":"_problems/_leetcode/74/","text":"\u5224\u65ad\u77e9\u9635\u662f\u5426\u5b58\u5728\u4e00\u4e2a\u76ee\u6807\u503c\u3002\u77e9\u9635\u7684\u7279\u70b9: \u6bcf\u884c\u4ece\u5de6\u5230\u53f3\u9012\u589e\uff0c\u6bcf\u884c\u7b2c\u4e00\u4e2a\u6570\u5927\u4e8e\u4e0a\u4e00\u884c\u6700\u540e\u4e00\u4e2a Example1: \u8f93\u5165\uff1amatrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 \u8f93\u51fa\uff1atrue (Medium) lower_bound \u6539\u4e00\u4e0b\u76f8\u7b49\u6761\u4ef6 solution class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { const int M = matrix . size (), N = matrix [ 0 ]. size (); int left = 0 , right = M * N ; while ( left < right ) { int mid = left + ( right - left ) / 2 ; int num = getNumber ( matrix , mid ); if ( num < target ) { left = mid + 1 ; } else if ( num > target ) { right = mid ; } else { return true ; } } return false ; } inline int getNumber ( vector < vector < int >> & matrix , int index ) { return matrix [ index / matrix [ 0 ]. size ()][ index % matrix [ 0 ]. size ()]; } };","title":"74. search a 2d matrix"},{"location":"_problems/_leetcode/79/","text":"\u7ed9\u5b9a mxn \u4e8c\u7ef4\u7f51\u683c board \u548c\u5355\u8bcd word \uff0c\u5982\u679c word \u5b58\u5728\u4e8e\u7f51\u683c\u4e2d\u8fd4\u56de true \uff0c\u5426\u5219\u8fd4\u56de false \u3002 \u5355\u8bcd\u5fc5\u987b\u6309\u7167\u5b57\u6bcd\u987a\u5e8f\uff0c\u901a\u8fc7\u76f8\u90bb\u5355\u5143\u683c\u5185\u7684\u5b57\u6bcd\u6784\u6210\u3002 Example1: \u8f93\u5165\uff1aboard = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\" \u8f93\u51fa\uff1atrue Note: 1 <= m, n <= 6 1 <= word.length <= 15 (Medium) \u57fa\u672c\u7684\u6392\u5217 DFS\uff0c\u6ce8\u610f\u9012\u5f52\u7684\u8fb9\u754c solution class Solution { public : bool exist ( vector < vector < char >> & board , string word ) { vector < vector < bool >> visited ( board . size (), vector < bool > ( board [ 0 ]. size ())); bool res = false ; for ( int i = 0 ; i < board . size (); ++ i ) { for ( int j = 0 ; j < board [ i ]. size (); ++ j ) { res |= dfs ( board , visited , word , 0 , i , j ); } if ( res ) break ; } return res ; } bool dfs ( vector < vector < char >>& board , vector < vector < bool >>& visited , string word , int idx , int i , int j ) { if ( board [ i ][ j ] != word [ idx ]) return false ; visited [ i ][ j ] = true ; if ( idx + 1 == word . size ()) return true ; bool res = false ; for ( int * dir : DIRECTIONS ) { int ni = i + dir [ 0 ], nj = j + dir [ 1 ]; if ( inArea ( board , ni , nj ) && ! visited [ ni ][ nj ]) res |= dfs ( board , visited , word , idx + 1 , ni , nj ); if ( res ) break ; } visited [ i ][ j ] = false ; return res ; } bool inArea ( vector < vector < char >>& board , int i , int j ) { return i >= 0 && i < board . size () && j >= 0 && j < board [ 0 ]. size (); } int DIRECTIONS [ 4 ][ 2 ] = {{ 0 , 1 }, { 0 , -1 }, { 1 , 0 }, { -1 , 0 }}; };","title":"79. word search"},{"location":"_problems/_leetcode/803_bricks_failing_when_hit/","text":"\u6709\u4e00\u4e2a m x n \u7684\u4e8c\u5143\u7f51\u683c\uff0c\u5176\u4e2d 1 \u8868\u793a\u7816\u5757\uff0c 0 \u8868\u793a\u7a7a\u767d\u3002\u7816\u5757 \u7a33\u5b9a\uff08\u4e0d\u4f1a\u6389\u843d\uff09\u7684\u524d\u63d0\u662f\uff1a \u4e00\u5757\u7816\u76f4\u63a5\u8fde\u63a5\u5230\u7f51\u683c\u7684\u9876\u90e8\uff0c\u6216\u8005 \u81f3\u5c11\u6709\u4e00\u5757\u76f8\u90bb\uff084 \u4e2a\u65b9\u5411\u4e4b\u4e00\uff09\u7816\u5757 \u7a33\u5b9a \u4e0d\u4f1a\u6389\u843d\u65f6 \u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4 hits \uff0c\u8fd9\u662f\u9700\u8981\u4f9d\u6b21\u6d88\u9664\u7816\u5757\u7684\u4f4d\u7f6e\u3002\u6bcf\u5f53\u6d88\u9664 hits[i] = (rowi, coli) \u4f4d\u7f6e\u4e0a\u7684\u7816\u5757\u65f6\uff0c\u5bf9\u5e94\u4f4d\u7f6e\u7684\u7816\u5757\uff08\u82e5\u5b58\u5728\uff09\u4f1a\u6d88\u5931\uff0c\u7136\u540e\u5176\u4ed6\u7684\u7816\u5757\u53ef\u80fd\u56e0\u4e3a\u8fd9\u4e00\u6d88\u9664\u64cd\u4f5c\u800c\u6389\u843d\u3002\u4e00\u65e6\u7816\u5757\u6389\u843d\uff0c\u5b83\u4f1a\u7acb\u5373\u4ece\u7f51\u683c\u4e2d\u6d88\u5931\uff08\u5373\uff0c\u5b83\u4e0d\u4f1a\u843d\u5728\u5176\u4ed6\u7a33\u5b9a\u7684\u7816\u5757\u4e0a\uff09 \u8fd4\u56de\u4e00\u4e2a\u6570\u7ec4 result \uff0c\u5176\u4e2d result[i] \u8868\u793a\u7b2c i \u6b21\u6d88\u9664\u64cd\u4f5c\u5bf9\u5e94\u6389\u843d\u7684\u7816\u5757\u6570\u76ee\u3002\u6ce8\u610f\uff0c\u6d88\u9664\u53ef\u80fd\u6307\u5411\u662f\u6ca1\u6709\u7816\u5757\u7684\u7a7a\u767d\u4f4d\u7f6e\uff0c\u5982\u679c\u53d1\u751f\u8fd9\u79cd\u60c5\u51b5\uff0c\u5219\u6ca1\u6709\u7816\u5757\u6389\u843d\u3002 Example1: \u8f93\u5165\uff1agrid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]] \u8f93\u51fa\uff1a[2] \u89e3\u91ca\uff1a \u7f51\u683c\u5f00\u59cb\u4e3a\uff1a [[1,0,0,0]\uff0c [1,1,1,0]] \u6d88\u9664 (1,0) \u5904\u7684\u7816\u5757\uff0c\u5f97\u5230\u7f51\u683c\uff1a [[1,0,0,0] [0,1,1,0]] \u4e24\u4e2a\u7816\u5757\u4e0d\u518d\u7a33\u5b9a\uff0c\u56e0\u4e3a\u5b83\u4eec\u4e0d\u518d\u4e0e\u9876\u90e8\u76f8\u8fde\uff0c\u4e5f\u4e0d\u518d\u4e0e\u53e6\u4e00\u4e2a\u7a33\u5b9a\u7684\u7816\u76f8\u90bb\uff0c\u56e0\u6b64\u5b83\u4eec\u5c06\u6389\u843d\u3002\u5f97\u5230\u7f51\u683c\uff1a [[1,0,0,0], [0,0,0,0]] \u56e0\u6b64\uff0c\u7ed3\u679c\u4e3a [2] Note: 1 <= grid.length, grid[i].length <= 200 0 <= hits.length <= 4 * 10^4 \u6240\u6709 (xi, yi) \u4e92\u4e0d\u76f8\u540c \u5e76\u67e5\u96c6\u9002\u7528\u4e8e\u8ba1\u7b97\u8fde\u901a\u5206\u91cf\uff0c\u4f46\u672c\u9898\u9700\u8981\u300c\u6253\u6389\u4e00\u4e2a\u6389\u843d\u591a\u5c11\u7816\u5757\u300d\u8f6c\u6362\u4e3a\u300c\u586b\u8865\u4e00\u4e2a\u589e\u52a0\u591a\u5c11\u7816\u5757\u300d\uff0ci.e. \u9006\u5411\u586b\u8865\u88ab\u6253\u6389\u7684\u7816\u5757\u3002\u8003\u8651\u51e0\u79cd\u7279\u6b8a\u60c5\u5f62: hit \u4e86\u4e00\u4e2a\u81ea\u59cb\u81f3\u7ec8\u4e3a 0 \u7684\u4f4d\u7f6e\uff0c\u9006\u5411\u586b\u8865\u65f6\u8981\u5ffd\u7565\u8fd9\u6837\u7684 hit hit \u4e86\u4e00\u4e2a\u66fe\u7ecf\u4e3a 1 \u4f46\u540e\u6765\u6389\u4e86\u7684\u4f4d\u7f6e\uff0c\u9006\u5411\u586b\u8865\u65f6\u76f8\u5f53\u4e8e 1 \u4e0a\u586b 1\uff0c\u53ef\u4ee5\u4e0d\u7528\u8003\u8651 hit \u4e86\u4e00\u4e2a\u66fe\u7ecf hit \u8fc7\u7684\u4f4d\u7f6e\uff0c\u9006\u5411\u586b\u8865\u65f6\u53ea\u6709\u7b2c\u4e00\u6b21 hit \u662f\u6709\u6548\u7684\uff0c\u597d\u5728\u8f93\u5165\u5df2\u7ecf\u53bb\u91cd \u5b9e\u73b0\u7ec6\u8282\uff1a \u53ea\u4f7f\u7528\u8def\u5f84\u538b\u7f29 \u5b89\u6392\u4e00\u4e2a\u54e8\u5175\u7ed3\u70b9\u8868\u793a\u5c4b\u9876\uff0c\u4f5c\u7528\u5728\u4e8e\u53ef\u4ee5\u968f\u65f6\u8bbf\u95ee\u5c4b\u9876\u7ed3\u70b9\u96c6\u7684\u603b\u6570\uff0c\u56e0\u6b64\u4e0d\u9700\u8981\u4e00\u5b9a\u4e3a\u6839\uff0c\u4f46\u586b\u8865\u65f6\u9700\u8981\u8003\u8651\u586b\u8865\u5c4b\u9876\u7ed3\u70b9\u7684\u60c5\u51b5 Solution X class Solution { private int M , N ; public static final int [][] DIRECTIONS = {{ 0 , 1 }, { 1 , 0 }, { - 1 , 0 }, { 0 , - 1 }}; public int [] hitBricks ( int [][] grid , int [][] hits ) { this . M = grid . length ; this . N = grid [ 0 ] . length ; // \u6b63\u5411\u6e05\u9664\u7816\u5757\uff0c\u5e76\u6807\u8bb0\u65e0\u6548\u7684 hit for ( int k = hits . length - 1 ; k >= 0 ; -- k ) { int i = hits [ k ][ 0 ] , j = hits [ k ][ 1 ] ; if ( grid [ i ][ j ] == 0 ) hits [ k ][ 0 ] = - 1 ; else grid [ i ][ j ] = 0 ; } // \u521d\u59cb\u5316\u7f51\u683c UFSet ufset = new UFSet ( M , N ); for ( int i = 1 ; i < M ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) { if ( grid [ i ][ j ] == 0 ) continue ; if ( grid [ i - 1 ][ j ] == 1 ) ufset . union ( i * N + j , ( i - 1 ) * N + j ); if ( j != N - 1 && grid [ i ][ j + 1 ] == 1 ) ufset . union ( i * N + j , i * N + j + 1 ); } } // \u9006\u5411\u586b\u8865 int [] res = new int [ hits . length ] ; for ( int k = hits . length - 1 ; k >= 0 ; -- k ) { int i = hits [ k ][ 0 ] , j = hits [ k ][ 1 ] ; if ( i == - 1 ) continue ; grid [ i ][ j ] = 1 ; int brkNum = 1 , addSum = 0 ; for ( int [] dir : DIRECTIONS ) { int ni = i + dir [ 0 ] , nj = j + dir [ 1 ] ; if ( inArea ( ni , nj ) && grid [ ni ][ nj ] == 1 ) { boolean flag = ufset . isStable ( ni * N + nj ); ufset . union ( i * N + j , ni * N + nj ); int newSize = ufset . getSize ( i * N + j ); if ( ! flag ) { // \u5982\u679c\u65b0\u5408\u5e76\u7684\u533a\u57df\u672a\u8fde\u63a5\u5c4b\u9876 addSum += newSize - brkNum ; } brkNum = newSize ; } } if ( ufset . isStable ( i * N + j )) res [ k ] = addSum ; } return res ; } public boolean inArea ( int x , int y ) { return x >= 0 && x < M && y >= 0 && y < N ; } private class UFSet { public int [] nodes , rank , stable ; public UFSet ( int M , int N ) { int size = M * N ; nodes = new int [ size ] ; rank = new int [ size ] ; stable = new int [ size ] ; for ( int i = 0 ; i < size ; ++ i ) { nodes [ i ] = i ; rank [ i ] = 1 ; if ( i < N ) stable [ i ] = 1 ; } } public void union ( int x , int y ) { int rx = find ( x ), ry = find ( y ); if ( rx == ry ) return ; if ( rank [ rx ] > rank [ ry ] ) { nodes [ ry ] = rx ; rank [ rx ] += rank [ ry ] ; } else { nodes [ rx ] = ry ; rank [ ry ] += rank [ rx ] ; } if (( stable [ rx ] | stable [ ry ] ) == 1 ) stable [ rx ] = stable [ ry ] = 1 ; } public int find ( int x ) { return x == nodes [ x ] ? x : ( nodes [ x ] = find ( nodes [ x ] )); } public int getSize ( int x ) { return rank [ find ( x ) ] ; } public boolean isStable ( int x ) { return stable [ find ( x ) ] == 1 ; } } } Solution (standard) class Solution { private int M , N ; public static final int [][] DIRECTIONS = {{ 0 , 1 }, { 1 , 0 }, { - 1 , 0 }, { 0 , - 1 }}; public int [] hitBricks ( int [][] grid , int [][] hits ) { this . M = grid . length ; this . N = grid [ 0 ] . length ; for ( int k = hits . length - 1 ; k >= 0 ; -- k ) { int i = hits [ k ][ 0 ] , j = hits [ k ][ 1 ] ; if ( grid [ i ][ j ] == 0 ) hits [ k ][ 0 ] = - 1 ; else grid [ i ][ j ] = 0 ; } UFSet ufset = new UFSet ( M , N ); for ( int j = 0 ; j < N ; ++ j ) if ( grid [ 0 ][ j ] == 1 ) ufset . union ( j , M * N ); for ( int i = 1 ; i < M ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) { if ( grid [ i ][ j ] == 0 ) continue ; if ( grid [ i - 1 ][ j ] == 1 ) ufset . union ( i * N + j , ( i - 1 ) * N + j ); if ( j != N - 1 && grid [ i ][ j + 1 ] == 1 ) ufset . union ( i * N + j , i * N + j + 1 ); } } int [] res = new int [ hits . length ] ; for ( int k = hits . length - 1 ; k >= 0 ; -- k ) { int i = hits [ k ][ 0 ] , j = hits [ k ][ 1 ] ; if ( i == - 1 ) continue ; int former = ufset . getCeilNum (); if ( i == 0 ) ufset . union ( j , M * N ); grid [ i ][ j ] = 1 ; for ( int [] dir : DIRECTIONS ) { int ni = i + dir [ 0 ] , nj = j + dir [ 1 ] ; if ( inArea ( ni , nj ) && grid [ ni ][ nj ] == 1 ) ufset . union ( i * N + j , ni * N + nj ); } int latter = ufset . getCeilNum (); res [ k ] = Math . max ( 0 , latter - former - 1 ); } return res ; } public boolean inArea ( int x , int y ) { return x >= 0 && x < M && y >= 0 && y < N ; } public static void main ( String [] args ) { Solution s = new Solution (); int [][] a1 = { { 1 , 0 , 1 }, { 1 , 1 , 1 } }; int [][] hits = { { 0 , 0 }, { 0 , 2 }, { 1 , 1 } }; int [] res = s . hitBricks ( a1 , hits ); for ( int i = 0 ; i < res . length ; ++ i ) System . out . print ( res [ i ] + \" \" ); } private class UFSet { public int [] nodes , rank ; public UFSet ( int M , int N ) { int size = M * N + 1 ; nodes = new int [ size ] ; rank = new int [ size ] ; for ( int i = 0 ; i < size ; ++ i ) { nodes [ i ] = i ; rank [ i ] = 1 ; } } public void union ( int x , int y ) { int rx = find ( x ), ry = find ( y ); if ( rx == ry ) return ; nodes [ rx ] = ry ; rank [ ry ] += rank [ rx ] ; } public int find ( int x ) { return x == nodes [ x ] ? x : ( nodes [ x ] = find ( nodes [ x ] )); } public int getCeilNum () { return rank [ find ( rank . length - 1 ) ] ; } } } \u590d\u6742\u5ea6\uff1a\u7531\u4e8e\u4ec5\u4f7f\u7528\u8def\u5f84\u538b\u7f29\uff0c\u4e3a $O((\\mathrm{len\\ of\\ \\mathsf{hits}} + MN)\\cdot \\log(MN))$","title":"803. bricks failing when hit"},{"location":"_problems/_leetcode/84/","text":"\u7ed9\u5b9a n \u4e2a\u975e\u8d1f\u6574\u6570\uff0c\u7528\u6765\u8868\u793a\u67f1\u72b6\u56fe\u4e2d\u5404\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u6bcf\u4e2a\u67f1\u5b50\u5f7c\u6b64\u76f8\u90bb\uff0c\u4e14\u5bbd\u5ea6\u4e3a 1\u3002\u6c42\u8be5\u67f1\u72b6\u56fe\u80fd\u52fe\u52d2\u51fa\u7684\u6700\u5927\u77e9\u5f62\u7684\u9762\u79ef\u3002 Example: \u8f93\u5165\uff1aheights = [2,1,5,6,2,3] \u8f93\u51fa\uff1a10 \u89e3\u91ca\uff1a\u6700\u5927\u7684\u77e9\u5f62\u4e3a [5,6] \u533a\u57df\uff0c\u9762\u79ef\u4e3a 10 Note: 1 <= heights.length <= 10^5 0 <= heights[i] <= 10^4 (Hard) \u8003\u8651\u5355\u8c03\u6808 (\u9012\u589e) \u7684\u6027\u8d28: mono[i] \u5165\u6808\uff0c\u4f4d\u7f6e\u4e3a i \uff0c\u5219 mono[i-1] \u662f\u5728\u539f\u6570\u7ec4 mono[i] \u5de6\u4fa7\u7b2c\u4e00\u4e2a\u4e25\u683c\u5c0f\u4e8e\u5b83\u7684\u5143\u7d20 mono[i] \u672a\u5fc5\u662f mono[i-1] \u53f3\u4fa7\u7b2c\u4e00\u4e2a\u6bd4\u5b83\u5927\u7684\u5143\u7d20 mono[i] \u51fa\u6808\uff0c\u5219\u9876\u66ff\u5b83\u7684\u662f\u539f\u6570\u7ec4\u4e2d\u5b83\u53f3\u4fa7\u7b2c\u4e00\u4e2a\u4e25\u683c\u5c0f\u4e8e\u5b83\u7684\u5143\u7d20 (\u6ca1\u51fa\u6808: \u6ca1\u6709\u66f4\u5c0f\u7684) \u679a\u4e3e\u6240\u6709\u9ad8\u5ea6\u7684\u77e9\u5f62: \u4ece\u6bcf\u4e2a\u67f1\u5b50\u51fa\u53d1\uff0c\u5411\u4e24\u4fa7\u5bfb\u627e\u7b2c\u4e00\u4e2a\u6bd4\u5b83\u5c0f\u7684\u67f1\u5b50\uff0c\u5206\u522b\u8ba1\u7b97\u5de6\u534a\u548c\u53f3\u534a\u9762\u79ef \u6ce8\u610f\u8003\u8651\u6709\u91cd\u590d\u5143\u7d20\u7684 case \u65f6\u95f4 $O(n)$\uff0c\u7a7a\u95f4 $O(n)$ ... \u7b2c\u4e00\u6b21\u505a\u7684\u65f6\u5019\u53d7\u5230 85. \u7684\u5f71\u54cd\uff0c\u6c42\u6bcf\u589e\u52a0\u4e00\u4e2a\u67f1\u5b50\u4f1a\u591a\u51fa\u54ea\u4e2a\u77e9\u5f62\uff0c\u6700\u574f\u65f6\u95f4 $O(n^2)$ solution class Solution { public : int largestRectangleArea ( vector < int > & heights ) { vector < int > monoStack ( heights . size ()); vector < int > tmpAreas ( heights . size ()); // \u5de6\u534a\u9762\u79ef int maxArea = 0 , top = -1 ; for ( int i = 0 ; i < heights . size (); ++ i ) { while ( top != -1 && heights [ monoStack [ top ]] >= heights [ i ]) { int topIdx = monoStack [ top ]; maxArea = std :: max ( maxArea , tmpAreas [ topIdx ] + ( i - topIdx ) * heights [ topIdx ]); -- top ; } monoStack [ ++ top ] = i ; if ( top != 0 ) { tmpAreas [ i ] += ( i - monoStack [ top - 1 ] - 1 ) * heights [ i ]; } else { // \u5de6\u534a\u90e8\u6ca1\u6709\u66f4\u5c0f\u7684 tmpAreas [ i ] += i * heights [ i ]; } } // pop \u6389\u6808\u4e2d\u5269\u4f59\u5143\u7d20 (\u53f3\u534a\u90e8\u6ca1\u6709\u66f4\u5c0f\u7684) for (; top >= 0 ; -- top ) { int topIdx = monoStack [ top ]; maxArea = std :: max ( maxArea , tmpAreas [ topIdx ] + (( int ) heights . size () - topIdx ) * heights [ topIdx ]); } return maxArea ; } };","title":"84. largest rectangle in histogram"},{"location":"_problems/_leetcode/85/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u4ec5\u5305\u542b 0 \u548c 1 \u7684\u4e8c\u7ef4\u77e9\u9635\uff0c\u8fd4\u56de\u53ea\u5305\u542b 1 \u7684\u6700\u5927\u77e9\u5f62\u9762\u79ef\u3002 Example: \u8f93\u5165\uff1amatrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"], [\"1\",\"0\",\"1\",\"1\",\"1\"], [\"1\",\"1\",\"1\",\"1\",\"1\"], [\"1\",\"0\",\"0\",\"1\",\"0\"]] \u8f93\u51fa\uff1a6 Note: 0 <= M, N <= 200 (Hard) \u521a\u5f00\u59cb\u7684\u601d\u8def\u662f\u52a8\u6001\u89c4\u5212\uff0c\u4ee4 dp[i][j] \u8868\u793a\u4ee5 matrix[i][j] \u4e3a\u53f3\u4e0b\u89d2\u7684\u77e9\u5f62\u957f\u548c\u5bbd\uff0c\u95ee\u9898\u5728\u4e8e\uff1a \u2003\u2003\u2003 dp[i][j] \u65e0\u6cd5\u786e\u5b9a\u9009\u62e9 dp[i-1][j] \u7684\u54ea\u4e2a\u77e9\u5f62\uff0c\u56e0\u6b64\u80af\u5b9a\u8fd8\u9700\u8981\u4e00\u4e2a\u7ef4\u5ea6\u3002\u8fd9\u79cd\u505a\u6cd5\u7684\u5173\u952e\u95ee\u9898\u5728\u4e8e\u6ca1\u80fd\u5b8c\u6574\u679a\u4e3e\u77e9\u5f62\u7684\u5e95\u8fb9\uff0c\u56e0\u6b64\u53ef\u4ee5\u6bcf\u904d\u5386\u5230 dp[i][j] \u5c31\u5411\u524d\u679a\u4e3e\uff0c\u7136\u540e\u7ef4\u62a4\u4e00\u4e2a\u53f3\u4fa7\u8fb9\u7684\u503c (\u6700\u5c0f\u7684\u8fde\u7eed 1 \u7684\u4e2a\u6570)\uff0c\u8fd9\u6837\u5c31\u5b8c\u6574\u679a\u4e3e\u4e86\u6240\u6709\u77e9\u5f62 \u65f6\u95f4 $O(m^2 n)$\uff0c\u7a7a\u95f4 $O(mn)$ (\u5b9e\u9645\u4ee3\u7801\u679a\u4e3e\u7684\u53f3\u4fa7\u8fb9\uff0c\u7ef4\u62a4\u5e95\u8fb9\u8fde\u7eed 1) \u4e5f\u53ef\u4ee5\u6cbf\u7528 84. \u67f1\u72b6\u56fe\u4e2d\u7684\u6700\u5927\u77e9\u5f62 \u7684\u65b9\u6cd5\uff0c\u5c06\u672c\u9898\u89c6\u4e3a\u67f1\u72b6\u56fe \u65f6\u95f4 $O(mn)$\uff0c\u7a7a\u95f4 $O(mn)$ solution enumeration class Solution { public : int maximalRectangle ( vector < vector < char >>& matrix ) { const int M = matrix . size (); if ( M == 0 ) return 0 ; const int N = matrix [ 0 ]. size (); int maxArea = 0 ; vector < vector < int >> leftWidth ( M , vector < int > ( N )); for ( int i = 0 ; i < M ; ++ i ) { int curWidth = 0 ; for ( int j = 0 ; j < N ; ++ j ) { if ( matrix [ i ][ j ] == '1' ) { ++ curWidth ; } else { curWidth = 0 ; } leftWidth [ i ][ j ] = curWidth ; int width = curWidth ; for ( int k = i ; k >= 0 ; -- k ) { width = std :: min ( width , leftWidth [ k ][ j ]); maxArea = std :: max ( maxArea , width * ( i - k + 1 )); if ( width == 0 ) break ; } } } return maxArea ; } }; histogram class Solution { public : int maximalRectangle ( vector < vector < char >>& matrix ) { const int M = matrix . size (); if ( M == 0 ) return 0 ; const int N = matrix [ 0 ]. size (); int maxArea = 0 ; vector < int > histogram ( N ); for ( int i = 0 ; i < M ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) { if ( matrix [ i ][ j ] == '1' ) { ++ histogram [ j ]; } else { histogram [ j ] = 0 ; } } maxArea = std :: max ( maxArea , largestRectangleArea ( histogram )); } return maxArea ; } int largestRectangleArea ( vector < int >& heights ) { vector < int > monoStack ( heights . size ()); vector < int > tmpAreas ( heights . size ()); // \u5de6\u534a\u9762\u79ef int maxArea = 0 , top = -1 ; for ( int i = 0 ; i < heights . size (); ++ i ) { while ( top != -1 && heights [ monoStack [ top ]] >= heights [ i ]) { int topIdx = monoStack [ top ]; maxArea = std :: max ( maxArea , tmpAreas [ topIdx ] + ( i - topIdx ) * heights [ topIdx ]); -- top ; } monoStack [ ++ top ] = i ; if ( top != 0 ) { tmpAreas [ i ] += ( i - monoStack [ top - 1 ] - 1 ) * heights [ i ]; } else { // \u5de6\u534a\u90e8\u6ca1\u6709\u66f4\u5c0f\u7684 tmpAreas [ i ] += i * heights [ i ]; } } // pop \u6389\u6808\u4e2d\u5269\u4f59\u5143\u7d20 (\u53f3\u534a\u90e8\u6ca1\u6709\u66f4\u5c0f\u7684) for (; top >= 0 ; -- top ) { int topIdx = monoStack [ top ]; maxArea = std :: max ( maxArea , tmpAreas [ topIdx ] + (( int ) heights . size () - topIdx ) * heights [ topIdx ]); } return maxArea ; } };","title":"85. maximal rectangle"},{"location":"_problems/_leetcode/852/","text":"\u5c71\u8109\u6570\u7ec4\u7684\u5b9a\u4e49: arr.length >= 3 \u5b58\u5728 i \u4f7f\u5f97 arr[0] < ... < arr[i-1] < arr[i] > arr[i+1] > ... > arr[last] \u7ed9\u5b9a\u5c71\u8109\u6570\u7ec4 arr \uff0c\u8fd4\u56de\u4e0b\u6807 i Example: \u8f93\u5165\uff1aarr = [24,69,100,99,79,78,67,36,26,19] \u8f93\u51fa\uff1a2 Note: arr \u4e00\u5b9a\u662f\u5c71\u8109\u6570\u7ec4 (Easy) \u5178\u578b\u4e8c\u5206 solution ```cpp class Solution { public: int peakIndexInMountainArray(vector & arr) { int left = 0, right = arr.size() - 1; while (left < right) { int mid = left + (right - left) / 2; if (arr[mid + 1] > arr[mid]) // [mid+1, right] left = mid + 1; else // [left, mid] right = mid; } return left; } }; ``` ```","title":"852. peak index in a mountain array"},{"location":"_problems/_leetcode/86/","text":"\u7ed9\u5b9a\u94fe\u8868\u5934\u7ed3\u70b9 head \u548c\u7279\u5b9a\u503c x \uff0c\u5bf9\u94fe\u8868\u5206\u9694\uff0c\u4f7f\u5f97\u6240\u6709\u5c0f\u4e8e x \u7684\u8282\u70b9\u51fa\u73b0\u5728\u5927\u4e8e\u7b49\u4e8e x \u7684\u8282\u70b9\u4e4b\u524d\uff0c\u4fdd\u7559\u5143\u7d20\u76f8\u5bf9\u987a\u5e8f\u3002 Example: \u8f93\u5165\uff1ahead = [1,4,3,2,5,2], x = 3 \u8f93\u51fa\uff1a[1,2,2,4,3,5] Note: \u8282\u70b9\u6570\u76ee\u5728 [0, 200] \u5185 (Medium) \u7b80\u5355\u6a21\u62df solution class Solution { public : ListNode * partition ( ListNode * head , int x ) { ListNode * head1 = new ListNode ; ListNode * head2 = new ListNode ; ListNode * cur1 = head1 , * cur2 = head2 ; for ( ListNode * node = head ; node != nullptr ; ) { if ( node -> val < x ) { cur1 -> next = node ; cur1 = node ; } else { cur2 -> next = node ; cur2 = node ; } ListNode * last = node ; node = node -> next ; last -> next = nullptr ; } cur1 -> next = head2 -> next ; ListNode * res = head1 -> next ; delete head1 ; delete head2 ; return res ; } };","title":"86. partition list"},{"location":"_problems/_leetcode/875/","text":"\u73c2\u73c2\u7231\u5403\u9999\u8549\uff0c\u5171\u6709 N \u5806\u9999\u8549\uff0c\u7b2c i \u5806\u4e2d\u6709 piles[i] \u6839\u9999\u8549\uff0c\u8b66\u536b\u5df2\u7ecf\u79bb\u5f00\uff0c\u5c06\u5728 H \u5c0f\u65f6\u540e\u56de\u6765\u3002 \u73c2\u73c2\u7684\u5403\u6cd5: \u6bcf\u5c0f\u65f6\u9009\u62e9\u4e00\u5806\u9999\u8549\uff0c\u4ece\u4e2d\u5403\u6389 K \u6839 (\u5c0f\u4e8e\u5c31\u5168\u5403)\uff0c\u6c42\u53ef\u4ee5\u5728 H \u5c0f\u65f6\u5185\u5403\u6389\u6240\u6709\u9999\u8549\u7684\u6700\u5c0f\u901f\u5ea6 K Example: \u8f93\u5165: piles = [3,6,7,11], H = 8 \u8f93\u51fa: 4 Note: 1 <= piles.length <= 10^4 piles.length <= H <= 10^9 1 <= piles[i] <= 10^9 (Medium) \u7531\u4e8e piles.length <= H \uff0c K \u4e00\u5b9a\u5b58\u5728\uff0c\u8303\u56f4 [1, max_element_in_piles] \uff0c\u6bcf\u4e2a K \u5bf9\u5e94\u4e00\u4e2a\u65f6\u95f4\uff0c\u53ef\u4ee5\u76f4\u63a5\u4e8c\u5206\uff0c\u4ee3\u7801\u601d\u8def\u548c 410 \u4e00\u6837\u3002 \u53ef\u4ee5\u76f4\u63a5\u8ba9 max=10^9 \uff0c\u4f1a\u66f4\u5feb\u4e00\u4e9b solution class Solution { public : int minEatingSpeed ( vector < int >& piles , int h ) { int left = 1 , right = 1000000000 ; while ( left < right ) { int mid = left + ( right - left ) / 2 ; if ( eatingHours ( piles , mid ) <= h ) { right = mid ; } else { left = mid + 1 ; } } return left ; } int eatingHours ( vector < int >& piles , int speed ) { int res = 0 ; for ( int pile : piles ) res += ( pile - 1 ) / speed + 1 ; return res ; } };","title":"875. koko eating bananas"},{"location":"_problems/_leetcode/876/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5934\u7ed3\u70b9\u4e3a head \u7684\u975e\u7a7a\u5355\u94fe\u8868\uff0c\u8fd4\u56de\u94fe\u8868\u7684\u4e2d\u95f4\u7ed3\u70b9\u3002\u5982\u679c\u6709\u4e24\u4e2a\u4e2d\u95f4\u7ed3\u70b9\uff0c\u5219\u8fd4\u56de\u7b2c\u4e8c\u4e2a\u4e2d\u95f4\u7ed3\u70b9\u3002 (Easy) \u53f3\u4e2d: ListNode * middleNode ( ListNode * head ) { ListNode * slow = head , * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } \u5de6\u4e2d: ListNode * middleNode ( ListNode * head ) { ListNode * slow = head , * fast = head -> next ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; }","title":"876. middle of the linked list"},{"location":"_problems/_leetcode/887/","text":"\u7ed9\u5b9a k \u4e2a\u9e21\u86cb\u548c\u4e00\u4e2a\u4ece 1 \u5230 n \u5c42\u697c\u7684\u5efa\u7b51\u3002\u5df2\u77e5\u5b58\u5728\u697c\u5c42 f ( 1 <= f <= n )\uff0c > f \u7684\u697c\u5c42\u6254\u9e21\u86cb\u90fd\u4f1a\u788e\uff0c <= f \u6254\u5219\u4e0d\u4f1a\u788e\u3002\u4ece\u4e00\u4e2a\u697c\u5c42\u6254\u4e0b\u9e21\u86cb\u89c6\u4e3a\u4e00\u6b21\u64cd\u4f5c\uff0c\u4e00\u65e6\u9e21\u86cb\u788e\u4e86\u540e\u9762\u5c31\u4e0d\u80fd\u518d\u7528\uff0c\u6ca1\u788e\u5219\u53ef\u4ee5\u91cd\u590d\u4f7f\u7528\uff0c\u6c42\u80fd\u786e\u5b9a f \u7684\u503c\u7684\u6700\u5c0f\u64cd\u4f5c\u6b21\u6570\u3002 Example1: \u8f93\u5165\uff1ak = 1, n = 2 \u8f93\u51fa\uff1a2 Example2: \u8f93\u5165: k = 2, n = 6 \u8f93\u51fa: 3 Note: 1 <= k <= 100 1 <= n <= 10^4 (Hard) \u901a\u8fc7\u4e8c\u5206\u5212\u5b9a\u7a7a\u95f4\u83b7\u5f97\u6700\u5c3d\u53ef\u80fd\u5c11\u7684\u64cd\u4f5c\u6b21\u6570\u3002\u8bbe\u5b9a\u72b6\u6001 (k, n) : \u6709 k \u4e2a\u9e21\u86cb\u4e14\u697c\u5c42 f \u5728 [1, n] \u5185\uff0c\u6bcf\u6b21\u9009\u53d6 mid = x (1 <= x <= n) \u9e21\u86cb\u788e\u4e86\uff0c (k-1, x-1) \u9e21\u86cb\u6ca1\u788e\uff0c (k, n-x) \u7531\u6b64\u53ef\u5f97\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b: $\\displaystyle dp(k, n) = \\max_{1\\leq x \\leq n}\\lbrace \\ \\ \\min\\lbrace dp(k-1,x-1),\\ dp(k, n-x)\\rbrace + 1 \\ \\ \\rbrace$ \u65f6\u95f4\u4e3a $O(kn^2)$\u3002\u5916\u5faa\u73af\u4ee5 x \u4e3a\u53d8\u91cf\uff0c dp(k,n-x) \u968f x \u9012\u51cf\uff0c dp(k-1,x-1) \u968f x \u9012\u589e \u56e0\u6b64 $f(x)=\\min\\lbrace dp(k-1,x-1),\\ dp(k,n-x)\\rbrace$ \u7684\u6700\u5927\u503c\u5728\u4ea4\u70b9\u5904\uff0c\u800c\u6c42\u4ea4\u70b9\u53ef\u4ee5\u901a\u8fc7\u4e8c\u5206\u5b9e\u73b0\uff0c\u601d\u8def: \u6700\u7ec8\u7ed3\u679c\u4e3a\u957f\u4e3a 2 \u7684\u95ed\u533a\u95f4 [L, R] \uff0c\u8868\u793a\u843d\u5728\u4ea4\u70b9\u4e24\u7aef\u7684\u6574\u6570 (\u4e5f\u53ef\u80fd\u67d0\u4e2a\u843d\u5728\u4ea4\u70b9\u4e0a) \u4fdd\u8bc1 L \u548c R \u4e00\u5b9a\u5728\u533a\u95f4\u4e2d\uff0c\u4e0b\u4e00\u8f6e\u7684\u533a\u95f4\u5fc5\u987b\u5305\u62ec mid \u4f18\u5316\u540e\u65f6\u95f4\u4e3a $O(kn\\log n)$ solution class Solution { public : int superEggDrop ( int k , int n ) { vector < vector < int >> cache ( k + 1 , vector < int > ( n + 1 )); return dp ( k , n , cache ); } int dp ( int k , int n , vector < vector < int >> & cache ) { if ( k == 1 ) return n ; if ( n == 0 ) return 0 ; if ( cache [ k ][ n ] != 0 ) return cache [ k ][ n ]; int left = 1 , right = n ; // closed interval [1, n] while ( left < right - 1 ) { int mid = left + ( right - left ) / 2 ; int valUp = dp ( k , n - mid , cache ); // decrease int valDown = dp ( k - 1 , mid - 1 , cache ); // increase if ( valUp > valDown ) { left = mid ; } else { right = mid ; } } int res = std :: min ( dp ( k , n - left , cache ), dp ( k - 1 , right - 1 , cache )) + 1 ; cache [ k ][ n ] = res ; return res ; } };","title":"887. super egg drop"},{"location":"_problems/_leetcode/91/","text":"\u4e00\u6761\u5305\u542b\u5b57\u6bcd A-Z \u7684\u6d88\u606f\u6309\u5982\u4e0b\u65b9\u5f0f\u7f16\u7801: `A' -> 1 'B' -> 2 ... 'Z' -> 26 \u7ed9\u5b9a\u4e00\u4e2a\u53ea\u542b\u6570\u5b57\u7684\u975e\u7a7a\u5b57\u7b26\u4e32 s \uff0c\u8fd4\u56de\u89e3\u7801\u65b9\u6cd5\u603b\u6570 Example: \u8f93\u5165\uff1as = \"226\" \u8f93\u51fa\uff1a3 \u89e3\u91ca\uff1a\u5b83\u53ef\u4ee5\u89e3\u7801\u4e3a \"BZ\" (2 26), \"VF\" (22 6), \u6216\u8005 \"BBF\" (2 2 6) \u3002 Note: 1 <= s.length <= 100 (Medium) \u52a8\u6001\u89c4\u5212\uff0c dp[i] \u53ea\u6d89\u53ca dp[i-1] \u548c dp[i-2] \uff0c\u7a7a\u95f4\u53ef\u4f18\u5316 solution class Solution { public : int numDecodings ( string s ) { vector < int > dp ( s . size () + 1 ); dp [ 0 ] = 1 ; if ( s [ 0 ] != '0' ) dp [ 1 ] = 1 ; for ( int i = 2 ; i < dp . size (); ++ i ) { if ( s [ i - 1 ] != '0' ) // '0'-'9' dp [ i ] += dp [ i - 1 ]; if ( s [ i - 2 ] == '1' || ( s [ i - 2 ] == '2' && s [ i - 1 ] >= '0' && s [ i - 1 ] <= '6' )) // '00' - '99' dp [ i ] += dp [ i - 2 ]; } return dp . back (); } };","title":"91. decode ways"},{"location":"_problems/_leetcode/939/","text":"\u7ed9\u5b9a\u5728 xy \u5e73\u9762\u4e0a\u7684\u4e00\u7ec4\u70b9\uff0c\u786e\u5b9a\u7531\u8fd9\u4e9b\u70b9\u7ec4\u6210\u7684\u77e9\u5f62\u7684\u6700\u5c0f\u9762\u79ef\uff0c\u5176\u4e2d\u77e9\u5f62\u7684\u8fb9\u5e73\u884c\u4e8e x/y \u8f74\uff0c\u5982\u679c\u6ca1\u6709\u4efb\u4f55\u77e9\u5f62\u5c31\u8fd4\u56de 0\u3002 Example1: \u8f93\u5165\uff1a[[1,1],[1,3],[3,1],[3,3],[2,2]] \u8f93\u51fa\uff1a4 \u8f93\u5165\uff1a[[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]] \u8f93\u51fa\uff1a2 Note: 0 <= points[i][0], points[i][1] <= 40000 1 <= points.length <= 500 (Medium) \u8003\u54c8\u5e0c solution class Solution { public : struct point_hash { size_t operator ()( const pair < int , int > & p ) const { return p . first * 40001 + p . second ; } }; int minAreaRect ( vector < vector < int >> & points ) { int minArea = INT32_MAX ; unordered_set < pair < int , int > , point_hash > pointSet ; for ( int i = 0 ; i < points . size (); ++ i ) { pointSet . insert ({ points [ i ][ 0 ], points [ i ][ 1 ]}); } for ( int i = 0 ; i < points . size () - 1 ; ++ i ) { for ( int j = i + 1 ; j < points . size (); ++ j ) { if ( points [ i ][ 0 ] == points [ j ][ 0 ] || points [ i ][ 1 ] == points [ j ][ 1 ]) { continue ; } int area = abs (( points [ i ][ 0 ] - points [ j ][ 0 ]) * ( points [ i ][ 1 ] - points [ j ][ 1 ])); if ( pointSet . count ({ points [ i ][ 0 ], points [ j ][ 1 ]}) == 1 && pointSet . count ({ points [ j ][ 0 ], points [ i ][ 1 ]}) == 1 ) { minArea = min ( minArea , area ); } } } return ( minArea == INT32_MAX ) ? 0 : minArea ; } };","title":"939. minimum area rectangle"},{"location":"_problems/_leetcode/96/","text":"\u7ed9\u5b9a\u6574\u6570 n \uff0c\u6c42\u7531 n \u4e2a\u7ed3\u70b9\u7ec4\u6210\u7684\u4e0d\u540c\u7684 BST \u79cd\u7c7b\uff0c\u7ed3\u70b9\u503c\u7531 1 \u5230 n \u4e92\u4e0d\u76f8\u540c\u3002 Example: <0>:1, <1>:1, <2>:2, <3>:5, <4>:14, <5>:42 Note: 1 <= n <= 19 (Medium) $\\displaystyle T(n) = \\sum_0^{n-1} T(i) \\times T(n - 1 - i)$ solution class Solution { public : int numTrees ( int n ) { vector < int > res ( n + 1 ); res [ 0 ] = res [ 1 ] = 1 ; for ( int i = 2 ; i < res . size (); ++ i ) { for ( int j = 0 ; j < i ; ++ j ) { res [ i ] += res [ j ] * res [ i - 1 - j ]; } } return res . back (); } }; Catalan \u6570\uff1a\u7ed9\u5b9a n \u4e2a\u6570\uff0c\u8fdb\u6808\u76f8\u5bf9\u6b21\u5e8f\u4e3a 1 ~ n \uff0c\u6c42\u51fa\u6808\u6b21\u5e8f\u6709\u591a\u5c11\u79cd \u5165\u6808\u8868\u793a\u4e3a $+1$\uff0c\u51fa\u6808\u8868\u793a\u4e3a $-1$\uff0c\u6bcf\u79cd\u7ec4\u5408\u4ee3\u8868\u4e00\u79cd\u51fa\u6808\u6b21\u5e8f\uff0c\u5171 $C^n_{2n}$ \u79cd \u82e5\u7ec4\u5408\u7684\u67d0\u4e2a\u524d\u7f00\u548c $< 0$\uff0c\u4ee3\u8868\u8be5\u5e8f\u5217\u4e0d\u5408\u6cd5\uff0c\u8bbe\u4e0d\u5408\u6cd5\u96c6\u5408\u4e3a $M$\uff0c\u6784\u5efa $f:M\\to N$\uff0c$f$ \u8868\u793a\u628a $m\\in M$ \u7b2c\u4e00\u4e2a\u4e0d\u5408\u6cd5\u524d\u7f00\u9010\u4e2a\u5143\u7d20\u53d6\u53cd\uff0c\u5219 $n=f(m)$ \u5171\u6709 $n+1$ \u4e2a $+1$ \u548c $n-1$ \u4e2a $-1$ $f$ \u4e3a\u53cc\u5c04\uff0c$f^{-1}$ \u53ea\u9700\u53d6 $n$ \u7684\u7b2c\u4e00\u4e2a\u524d\u7f00\u548c $> 0$ \u7684\u524d\u7f00\uff0c\u4e14 $N$ \u8868\u793a\u300c$n+1$ \u4e2a $+1$ \u548c $n-1$ \u4e2a $-1$ \u7684\u6240\u6709\u7ec4\u5408\u300d\uff0c$|N|=C_{2n}^{n+1}$ \u7efc\u4e0a, $\\displaystyle T_n = C_{2n}^n - C_{2n}^{n+1} = \\frac{1}{n+1} C^n_{2n}$ \u2002 $\\displaystyle T_{n+1} = \\frac{4n+2}{n+2} T_n$ \u53d8\u5f62: \u62ec\u53f7\u5339\u914d\uff1a\u2002 \u51fa\u6808\u4ee3\u8868\u4e0e\u6808\u9876\u62ec\u53f7\u5339\u914d \u6709 n+1 \u4e2a\u53f6\u5b50\u7ed3\u70b9\u7684\u6ee1\u4e8c\u53c9\u6811\u7684\u4e2a\u6570: \u2002 $n$ \u4e2a\u5ea6\u4e3a 2 \u7684\u5185\u7ed3\u70b9\uff0c\u5171 6 \u6761\u8fb9\uff0c\u5148\u5e8f\u904d\u5386\u6b64\u6811\uff0c\u5411\u5de6\u8d70\u8bb0\u4e3a $+1$ \u5411\u53f3\u8bb0\u4e3a $-1$\uff0c\u7531\u4e8e\u662f\u6ee1\u4e8c\u53c9\u6811\uff0c\u6bcf\u4e2a $-1$ \u5fc5\u6709\u4e00\u4e2a $+1$ \u4e0e\u4e4b\u5339\u914d\uff0c\u7b26\u5408\u5361\u7279\u5170\u6570\u5b9a\u4e49 \u672c\u9898 $\\Leftrightarrow$ $n$ \u4e2a\u7ed3\u70b9\u6709\u591a\u5c11\u79cd\u4e8c\u53c9\u6811 $\\Leftrightarrow$ $n+1$ \u4e2a\u53f6\u5b50... solution class Solution { public : int numTrees ( int n ) { long res = 1 ; for ( int i = 2 ; i <= n ; ++ i ) { res = res * ( 4 * i - 2 ) / ( i + 1 ); } return res ; } };","title":"96. unique binary search trees"},{"location":"_problems/_leetcode/97/","text":"\u7ed9\u5b9a\u5b57\u7b26\u4e32 s1 = s11 + s12 + ... \u548c s2 = s21 + s22 + ... \uff0c\u5224\u65ad s3 \u662f\u5426\u7531 s1 \u548c s2 \u4ea4\u9519\u800c\u6210 Example1: \u8f93\u5165\uff1as1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\" \u8f93\u51fa\uff1atrue Note: (Medium) \u7ecf\u5178\u8d8a\u7ea7 dp[i][j] = dp[i][j] || dp[i-1][j] or dp[i][j] || dp[i][j-1] solution class Solution { public : bool isInterleave ( string s1 , string s2 , string s3 ) { int M = s1 . size (), N = s2 . size (); if ( M + N != s3 . size ()) { return false ; } vector < vector < bool >> dp ( M + 1 , vector < bool > ( N + 1 )); dp [ 0 ][ 0 ] = true ; for ( int i = 0 ; i <= M ; ++ i ) { for ( int j = 0 ; j <= N ; ++ j ) { if ( i != 0 && s1 [ i - 1 ] == s3 [ i + j - 1 ]) dp [ i ][ j ] = dp [ i ][ j ] || dp [ i - 1 ][ j ]; if ( j != 0 && s2 [ j - 1 ] == s3 [ i + j - 1 ]) dp [ i ][ j ] = dp [ i ][ j ] || dp [ i ][ j - 1 ]; } } return dp [ M ][ N ]; } };","title":"97. interleaving string"},{"location":"_problems/_leetcode/979/","text":"\u7ed9\u5b9a\u4e00\u4e2a\u6709 N \u4e2a\u7ed3\u70b9\u7684\u4e8c\u53c9\u6811\u7684\u6839\u7ed3\u70b9 root \uff0c\u6811\u4e2d\u7684\u6bcf\u4e2a\u7ed3\u70b9\u4e0a\u90fd\u5bf9\u5e94\u6709 node.val \u679a\u786c\u5e01\uff0c\u5e76\u4e14\u603b\u5171\u6709 N \u679a\u786c\u5e01\u3002 \u5728\u4e00\u6b21\u79fb\u52a8\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u4e24\u4e2a\u76f8\u90bb\u7684\u7ed3\u70b9\uff0c\u7136\u540e\u5c06\u4e00\u679a\u786c\u5e01\u4ece\u5176\u4e2d\u4e00\u4e2a\u7ed3\u70b9\u79fb\u52a8\u5230\u53e6\u4e00\u4e2a\u7ed3\u70b9\u3002(\u79fb\u52a8\u53ef\u4ee5\u662f\u4ece\u7236\u7ed3\u70b9\u5230\u5b50\u7ed3\u70b9\uff0c\u6216\u8005\u4ece\u5b50\u7ed3\u70b9\u79fb\u52a8\u5230\u7236\u7ed3\u70b9\u3002)\u3002 \u8fd4\u56de\u4f7f\u6bcf\u4e2a\u7ed3\u70b9\u4e0a\u53ea\u6709\u4e00\u679a\u786c\u5e01\u6240\u9700\u7684\u79fb\u52a8\u6b21\u6570\u3002 Example: \u8f93\u5165\uff1a[1,0,0,null,3] \u8f93\u51fa\uff1a4 Note: 1<= N <= 100 0 <= node.val <= N (Medium) (a). 1 (b). 3 / \\ / \\ 0 0 0 0 / \\ / \\ 2 2 2 0 \u4e00\u5f00\u59cb\u7684\u601d\u8def: \u9996\u5148\u672c\u9898\u7684\u79fb\u52a8\u662f\u6709\u6700\u4f18\u65b9\u5f0f\u7684\uff0c\u5982\u4f8b (a). \u6240\u793a\uff0c\u76f4\u89c9\u6765\u770b\u5e94\u5728\u5b50\u6811\u5185\u90e8\u79fb\u52a8 \u8d2a\u5fc3\u662f\u4e0d\u5bf9\u7684\uff0c\u5982 (b). \u6240\u793a \u300c\u6700\u4f18\u300d\u7684\u5207\u5165\u70b9\u5728\u4e8e\u53f6\u7ed3\u70b9\uff0c\u53f6\u7ed3\u70b9\u53ea\u6709\u4e00\u4e2a\u90bb\u5c45 \u5982\u679c leaf.val > 1 \uff0c\u591a\u4f59\u786c\u5e01\u4e00\u5b9a\u8981\u7ecf\u8fc7\u7236\u7ed3\u70b9\uff0c\u79fb\u52a8\u540e\u7684\u6811\u52a0\u79fb\u52a8\u8ddd\u79bb\u7ec4\u6210\u539f\u95ee\u9898\u7684\u6700\u4f18\u89e3 \u5982\u679c leaf.val = 0 \uff0c\u90a3\u4ece\u7236\u7ed3\u70b9\u62ff\u4e00\u4e2a (\u5411\u4e0a\u9001\u4e00\u4e2a -1 \u7684\u6743\u503c) \u4e5f\u7b26\u5408\u8d2a\u5fc3\u9009\u62e9\u6027 \u4e4b\u540e\uff0c\u5c31\u53ef\u4ee5\u5411\u4e0a\u9012\u5f52 \u7efc\u4e0a\uff0c\u53ef\u4ee5\u7528\u540e\u5e8f\u9012\u5f52\u5b9e\u73b0\u8fd9\u4e2a\u8d2a\u5fc3\u9009\u62e9\u7684\u8fc7\u7a0b Adcodes class Solution { public : int distributeCoins ( TreeNode * root ) { traverse ( root ); return dist ; } int traverse ( TreeNode * root ) { if ( root == nullptr ) return 0 ; int leftSum = traverse ( root -> left ); int rightSum = traverse ( root -> right ); dist += abs ( leftSum ) + abs ( rightSum ); return leftSum + rightSum + root -> val - 1 ; } int abs ( int & n ) { return n > 0 ? n : - n ; } private : int dist = 0 ; }; \u65f6\u95f4 $O(n)$\uff0c\u7a7a\u95f4\u4e0a\u9012\u5f52 $O(h)$","title":"979. distribute coins in binary tree"},{"location":"_problems/_leetcode/987/","text":"\u7ed9\u5b9a\u4e8c\u53c9\u6811\u6839\u7ed3\u70b9 root \uff0c\u8ba1\u7b97\u4e8c\u53c9\u6811\u5782\u5e8f\u5e8f\u5217\u3002\u5bf9\u4e8e\u4f4d\u4e8e (row, col) \u7684\u6bcf\u4e2a\u7ed3\u70b9\uff0c\u5176\u5de6\u53f3\u5b50\u7ed3\u70b9\u5206\u522b\u4f4d\u4e8e (row+1, col-1) \u548c (row+1, col+1) \uff0c\u6811\u7684\u6839\u7ed3\u70b9\u4f4d\u4e8e (0, 0) \u3002\u5782\u5e8f\u904d\u5386\u5373\u4ece\u6700\u5de6\u4fa7\u7684\u5217\u5f00\u59cb\u4e00\u76f4\u904d\u5386\u5230\u6700\u53f3\u4fa7\u7684\u5217\u7ed3\u675f\uff0c\u6bcf\u4e00\u5217\u6309\u884c\u4ece\u4e0a\u5230\u4e0b\u904d\u5386\uff0c\u5982\u679c\u540c\u884c\u540c\u5217\u4e0a\u6709\u591a\u4e2a\u7ed3\u70b9\uff0c\u5219\u6309\u7ed3\u70b9\u7684\u503c\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\u3002 Example: \u8f93\u5165\uff1aroot = [3,9,20,null,null,15,7] \u8f93\u51fa\uff1a[[9],[3,15],[20],[7]] \u89e3\u91ca\uff1a \u5217 -1 \uff1a\u53ea\u6709\u7ed3\u70b9 9 \u5728\u6b64\u5217\u4e2d\u3002 \u5217 0 \uff1a\u53ea\u6709\u7ed3\u70b9 3 \u548c 15 \u5728\u6b64\u5217\u4e2d\uff0c\u6309\u4ece\u4e0a\u5230\u4e0b\u987a\u5e8f\u3002 \u5217 1 \uff1a\u53ea\u6709\u7ed3\u70b9 20 \u5728\u6b64\u5217\u4e2d\u3002 \u5217 2 \uff1a\u53ea\u6709\u7ed3\u70b9 7 \u5728\u6b64\u5217\u4e2d\u3002 Note: \u7ed3\u70b9\u603b\u6570\u5728 [1, 1000] \u5185 (Hard) \u904d\u5386 + \u6392\u5e8f solution class Solution { public : vector < vector < int >> verticalTraversal ( TreeNode * root ) { vector < tuple < int , int , int >> nodes ; traversal ( root , 0 , 0 , nodes ); sort ( nodes . begin (), nodes . end ()); vector < vector < int >> res ; int lastCol = INT32_MIN ; for ( auto & [ col , row , val ] : nodes ) { if ( col != lastCol ) { lastCol = col ; res . emplace_back (); } res . back (). push_back ( val ); } return res ; } void traversal ( TreeNode * root , int x , int y , vector < tuple < int , int , int >> & nodes ) { if ( ! root ) return ; nodes . push_back ({ y , x , root -> val }); traversal ( root -> left , x + 1 , y - 1 , nodes ); traversal ( root -> right , x + 1 , y + 1 , nodes ); } };","title":"987. vertical order traversal of a binary tree"},{"location":"_problems/_leetcode/996/","text":"\u5b9a\u4e49: \u5bf9\u975e\u8d1f\u6574\u6570\u6570\u7ec4 A \uff0c\u82e5 A \u7684\u6bcf\u5bf9\u76f8\u90bb\u6570\u7ec4\u548c\u662f\u4e00\u4e2a\u5b8c\u5168\u5e73\u65b9\u6570\uff0c\u5219\u79f0 A \u4e3a\u6b63\u65b9\u5f62\u6570\u7ec4 \u7ed9\u5b9a A \uff0c\u8fd4\u56de\u5b83\u7684\u6b63\u65b9\u5f62\u6392\u5217\u7684\u6570\u76ee\u3002\u4e24\u4e2a\u6392\u5217 A1 \u548c A2 \u4e0d\u540c\u7684\u5145\u8981\u6761\u4ef6\u662f\u5b58\u5728\u67d0\u4e2a i \uff0c\u4f7f\u5f97 A1[i] != A2[i] Example: \u8f93\u5165\uff1a[1,17,8] \u8f93\u51fa\uff1a2 \u89e3\u91ca\uff1a[1,8,17] \u548c [17,8,1] \u90fd\u662f\u6709\u6548\u7684\u6392\u5217\u3002\u8f93\u5165\uff1anums = [1,2,3] Note: 1 <= A.length <= 12 0 <= A[i] <= 1e9 (Medium) \u548c 47. \u5168\u6392\u5217 2 \u51e0\u4e4e\u4e00\u6837\uff0c\u533a\u522b\u5728\u4e8e\u524d\u8005\u53ef\u4ee5\u89c6\u4e3a\u5bf9\u5b8c\u5168\u56fe DFS\uff0c\u672c\u9898\u9700\u8981\u5efa\u56fe \u9996\u5148\uff0c\u6839\u636e\u548c\u662f\u5426\u4e3a\u5e73\u65b9\u6570\uff0c\u5efa\u7acb\u4e00\u5f20\u90bb\u63a5\u8868\uff0c\u76f8\u540c\u7684\u6570\u8fde\u63a5\u60c5\u51b5\u4e00\u6837\uff0c\u76f4\u63a5\u7528 map \u5efa \u4f7f\u7528 count map \u4fdd\u8bc1\u627e\u5230\u7684\u5168\u6392\u5217\u4e0d\u4f1a\u91cd\u590d \u9700\u8981\u6ce8\u610f\u7684\u70b9: \u53ef\u4ee5\u7528 (int) sqrt(x) ^2 == x \u7684\u65b9\u5f0f\u5224\u65ad\u662f\u5426\u4e3a\u5e73\u65b9\u6570\uff0c\u4f46\u8981\u6ce8\u610f\u67d0\u4e9b\u5b9e\u73b0 sqrt(x^2) \u7684\u8fd4\u56de\u503c\u53ef\u80fd\u6bd4 x \u5c0f\u4e00\u70b9\u70b9\uff0c\u7531 double->int \u7684 round-to-zero \u5c31\u53d8\u6210\u4e86 x-1 \uff0c\u56e0\u6b64\u52a0\u4e86 0.5 \u53ef\u4ee5\u901a\u8fc7\u4f4d\u8fd0\u7b97\u8bb0\u5f55\u8bbf\u95ee\u72b6\u6001\uff0c\u4ece\u800c\u7528 memory[i][state] \u8bb0\u5f55\u7ed3\u679c\uff0c\u4f46\u8fd9\u6837\u5c31\u4e0d\u80fd\u7528 map \u7684\u65b9\u5f0f\u53bb\u91cd\uff0c\u53ea\u80fd\u5168\u90e8\u904d\u5386\u7136\u540e\u518d\u9664\u4ee5 n! \uff0c\u4e5f\u4f1a\u635f\u5931\u4e00\u4e9b\u65f6\u95f4 \u6613\u9519: \u6784\u9020\u90bb\u63a5\u8868\u53ea\u52a0\u4e86\u4e00\u4e2a solution class Solution { public : int numSquarefulPerms ( vector < int >& nums ) { unordered_map < int , unordered_set < int >> graph ; unordered_map < int , int > num2count ; for ( int i = 0 ; i < nums . size (); ++ i ) { num2count [ nums [ i ]] ++ ; for ( int j = i + 1 ; j < nums . size (); ++ j ) { if ( isSquareNumber ( nums [ i ] + nums [ j ])) { graph [ nums [ i ]]. insert ( nums [ j ]); graph [ nums [ j ]]. insert ( nums [ i ]); } } } int res = 0 ; for ( auto iter = num2count . begin (); iter != num2count . end (); ++ iter ) { res += genSquarePerms ( graph , num2count , iter -> first , 1 , nums . size ()); } return res ; } private : int genSquarePerms ( unordered_map < int , unordered_set < int >>& graph , unordered_map < int , int >& num2count , int num , int depth , int size ) { if ( depth == size ) { return 1 ; } int res = 0 ; num2count [ num ] -- ; for ( int neighbor : graph [ num ]) { if ( num2count [ neighbor ] != 0 ) { res += genSquarePerms ( graph , num2count , neighbor , depth + 1 , size ); } } num2count [ num ] ++ ; return res ; } bool isSquareNumber ( int x ) { int sqx = ( int ) ( sqrt ( x ) + 0.5 ); return sqx * sqx == x ; } };","title":"996. number of squareful arrays"},{"location":"_problems/_others/others/","text":"1. \u4e24\u6570\u76f8\u52a0 (\u767d\u7ed9\uff0c\u4ed4\u7ec6) 313. \u8d85\u7ea7\u4e11\u6570 (\u5de7\u5999 k \u6307\u9488) 209. \u53cd\u8f6c\u94fe\u8868 (...) 31. \u4e0b\u4e00\u4e2a\u6392\u5217 (\u4e24\u6b21\u904d\u5386) 556. \u4e0b\u4e00\u4e2a\u66f4\u5927\u5143\u7d20 III (\u4e0b\u4e00\u4e2a\u6392\u5217) 60. \u6392\u5217\u5e8f\u5217 (\u627e\u7b2c k \u5927\u7684\u6392\u5217\uff0c\u4e00\u8f6e\u904d\u5386) 384. \u6253\u4e71\u6570\u7ec4 (\u6d17\u724c\u7b97\u6cd5) 134. \u52a0\u6cb9\u7ad9 (\u52a0\u901f\u5339\u914d) 208. \u5b9e\u73b0 Trie 386. \u5b57\u5178\u5e8f\u6392\u6570 (trie \u524d\u5e8f\u904d\u5386) 440. \u5b57\u5178\u5e8f\u7684\u7b2c K \u5c0f\u6570\u5b57 (Kth trie) 179. \u6700\u5927\u6570 (\u6392\u5e8f)","title":"Others"},{"location":"_problems/_search/search/","text":"\u6392\u5217 DFS \ud83e\uddd0 \u6839\u636e\u7ed9\u5b9a\u6761\u4ef6\uff0c\u751f\u6210\u6240\u6709\u7684\u5e8f\u5217\u6392\u5217: \u6784\u9020\u539f\u95ee\u9898\u7684 DFS \u641c\u7d22\u6811 (\u6240\u6709\u53f6\u8282\u70b9\u6df1\u5ea6\u76f8\u540c)\uff0c\u7136\u540e\u5957\u7528 DFS \u6a21\u677f\u5373\u53ef \u5982\u679c\u5e8f\u5217\u957f\u5ea6\u5f88\u5c0f\uff0c\u53ef\u7528\u72b6\u6001\u538b\u7f29\u4f18\u5316 \u4f8b\u5b50: 526. \u4f18\u7f8e\u7684\u6392\u5217 (\u5178\u578b\u7684\u7531 DFS \u641c\u7d22\u5230\u8bb0\u5fc6\u5316\u641c\u7d22\u518d\u5230 DP) 46. \u5168\u6392\u5217 (\u56de\u6eaf\uff0c\u53d8\u5f0f DFS) 47. \u5168\u6392\u5217 2 (\u5168\u6392\u5217\u57fa\u7840\u4e0a\u505a\u4e2a\u5c0f\u4fee\u6539\u53bb\u91cd) 996. \u6b63\u65b9\u5f62\u6570\u7ec4\u7684\u6570\u76ee (\u5168\u6392\u5217 2 \u7684\u53d8\u5f62) 22. \u62ec\u53f7\u751f\u6210 72. \u5355\u8bcd\u641c\u7d22 212. \u5355\u8bcd\u641c\u7d22 II (\u5355\u8bcd\u641c\u7d22 + trie) 39. \u7ec4\u5408\u603b\u548c (\u53c2\u8003\u5b8c\u5168\u80cc\u5305\u7684 dfs) 40. \u7ec4\u5408\u603b\u548c II","title":"DFS / BFS"},{"location":"_problems/_search/search/#dfs","text":"\u6839\u636e\u7ed9\u5b9a\u6761\u4ef6\uff0c\u751f\u6210\u6240\u6709\u7684\u5e8f\u5217\u6392\u5217: \u6784\u9020\u539f\u95ee\u9898\u7684 DFS \u641c\u7d22\u6811 (\u6240\u6709\u53f6\u8282\u70b9\u6df1\u5ea6\u76f8\u540c)\uff0c\u7136\u540e\u5957\u7528 DFS \u6a21\u677f\u5373\u53ef \u5982\u679c\u5e8f\u5217\u957f\u5ea6\u5f88\u5c0f\uff0c\u53ef\u7528\u72b6\u6001\u538b\u7f29\u4f18\u5316 \u4f8b\u5b50: 526. \u4f18\u7f8e\u7684\u6392\u5217 (\u5178\u578b\u7684\u7531 DFS \u641c\u7d22\u5230\u8bb0\u5fc6\u5316\u641c\u7d22\u518d\u5230 DP) 46. \u5168\u6392\u5217 (\u56de\u6eaf\uff0c\u53d8\u5f0f DFS) 47. \u5168\u6392\u5217 2 (\u5168\u6392\u5217\u57fa\u7840\u4e0a\u505a\u4e2a\u5c0f\u4fee\u6539\u53bb\u91cd) 996. \u6b63\u65b9\u5f62\u6570\u7ec4\u7684\u6570\u76ee (\u5168\u6392\u5217 2 \u7684\u53d8\u5f62) 22. \u62ec\u53f7\u751f\u6210 72. \u5355\u8bcd\u641c\u7d22 212. \u5355\u8bcd\u641c\u7d22 II (\u5355\u8bcd\u641c\u7d22 + trie) 39. \u7ec4\u5408\u603b\u548c (\u53c2\u8003\u5b8c\u5168\u80cc\u5305\u7684 dfs) 40. \u7ec4\u5408\u603b\u548c II","title":"\u6392\u5217 DFS"},{"location":"_problems/_simul/simul/","text":"57. \u63d2\u5165\u533a\u95f4 (\u5411\u6709\u5e8f\u533a\u95f4\u5e8f\u5217\u4e2d\u63d2\u5165\u4e00\u4e2a\u533a\u95f4) 165. \u6bd4\u8f83\u7248\u672c\u53f7 498. \u5bf9\u89d2\u7ebf\u904d\u5386 166. \u5206\u6570\u5230\u5c0f\u6570 (\u6a21\u62df\u957f\u9664\u6cd5\uff0c\u8003\u8651\u5168 special case) 71. \u7b80\u5316\u8def\u5f84","title":"Simulation"}]}